[
    {
        "query_intent": "The question is asking for the total number of singers in the database. To achieve this, we need to count the number of records in the \"singer\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total count of records in the \"singer\" table, which represents the number of singers. To achieve this, we need to use an aggregate function to count the rows in the specified table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve the name, country, and age of all singers and to sort them by age in descending order. This requires selecting specific columns from a table and ordering the results.",
        "sql_skeleton": "SELECT _, _, _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking to retrieve the names, countries, and ages of all singers, sorted in descending order by their age. This requires selecting specific columns from a table and ordering the results.",
        "sql_skeleton": "SELECT _, _, _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking for the average, minimum, and maximum ages of singers from France. This requires calculating aggregate values for age and filtering the results to include only those from France.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the calculation of average, minimum, and maximum ages for all singers from France. This requires aggregating the age data for singers who are citizens of France.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name and release year of the song performed by the youngest singer. This requires selecting specific columns from a table and ordering the results by age in ascending order to find the youngest singer.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names and release years of songs performed by the youngest singer. This requires identifying the youngest singer and then retrieving the relevant song details.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for a list of unique countries from which singers older than 20 years are from. This requires filtering the data based on age and selecting distinct values of the country field.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for a list of unique countries that have singers who are older than 20 years. This requires filtering the data based on age and selecting distinct countries.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for a count of singers grouped by their country of origin. This requires aggregating data based on the country and counting the number of entries for each country.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of singers grouped by their country of origin. This requires counting the entries in the \"singer\" table and grouping the results by the \"country\" column.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for a list of song names by singers whose ages are above the average age of all singers. This requires filtering records based on a condition that involves a subquery to calculate the average age.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of songs performed by singers whose age is greater than the average age of all singers. This requires filtering records based on a condition that involves an aggregate function.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking to retrieve the location and name of all stadiums that have a capacity within the range of 5000 to 10000. This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking for the locations and names of stadiums that have a capacity within the range of 5000 to 10000. This requires filtering the data based on a condition and selecting specific columns from a table.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking for the maximum capacity and the average capacity of all stadiums. This requires calculating aggregate values from a dataset.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the calculation of the average and maximum capacities of all stadiums, which requires aggregate functions to compute these values.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is looking for the name and capacity of the stadium that has the highest average attendance. This requires sorting the stadiums by their average attendance in descending order and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name and capacity of the stadium that has the highest average attendance. This requires sorting the stadiums by their average attendance in descending order and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the total number of concerts that took place in either the year 2014 or 2015. To achieve this, we need to count the records in the `concert` table where the `Year` column matches either '2014' or '2015'.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of concerts that took place in either the year 2014 or 2015. To achieve this, we need to count the entries in the \"concert\" table where the \"Year\" column matches either \"2014\" or \"2015\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking to display the names of stadiums along with the count of concerts held in each stadium. This requires joining two tables (stadium and concert) on a common key (Stadium_ID), grouping the results by stadium name, and counting the number of concerts for each stadium.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of concerts that take place at each stadium. To achieve this, we need to count the number of concert records associated with each stadium and group the results by stadium. This requires joining the concert and stadium tables and then counting the concert entries, grouped by the stadium's ID.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the stadium name and capacity that hosted the most concerts in the year 2014 or later. This requires identifying the stadium with the highest count of associated concerts within the specified year range.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ >= _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name and capacity of the stadium that hosted the most concerts after the year 2013. This requires identifying the stadium with the highest number of associated concerts within the specified timeframe.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ > _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to identify the year that has the highest number of concerts. This requires counting the number of concerts for each year and then selecting the year with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the year that had the highest number of concerts. This requires counting the number of concerts for each year and then identifying the year with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of stadiums that do not have any associated concerts. This requires identifying stadiums that are not linked to any concert entries in the related tables.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of stadiums that do not have any associated concerts. This requires identifying stadiums that are not referenced in the concert table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for countries that have singers older than 40 and also have singers younger than 30. This requires identifying common countries from two separate sets of conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ INTERSECT SELECT _ FROM _ WHERE _ < _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of all stadiums, excluding those that hosted a concert in the year 2014. This requires filtering out specific records based on a condition related to another table.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of stadiums that did not host any concerts in the year 2014. This requires identifying stadiums that are not associated with any concerts in that year.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is asking to display the name and theme of all concerts along with the count of singers in each concert. This requires joining two tables (concert and singer_in_concert) and grouping the results by concert ID to count the number of singers per concert.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the names and themes of concerts, along with the count of singers participating in each concert. This requires joining two tables (concert and singer_in_concert) on a common key (concert_ID), grouping the results by concert name, and counting the number of singers per concert.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for a list of singer names along with the number of concerts each singer has participated in. This requires joining two tables (singer and singer_in_concert) and then counting the number of concerts for each singer.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the names of singers and the count of concerts they have participated in. This requires joining two tables (singer_in_concert and singer) and then grouping the results by singer names to count the number of concerts each singer has.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for a list of singer names who performed in concerts that took place in the year 2014. This requires joining multiple tables to match singers with their respective concerts and filtering the results based on the year of the concert.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of singers who participated in a concert that took place in the year 2014. To achieve this, we need to join multiple tables to match concerts with their respective singers and filter the results based on the year of the concert.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name and nationality of singers who have a song with the name 'Hey' in its title. This requires filtering the records in the singer table based on a condition applied to the song name.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the name and country of origin of singers who have at least one song with the word \"Hey\" in its title. This requires filtering the songs based on a condition and then retrieving specific details from the filtered results.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the names and locations of stadiums where concerts took place in both 2014 and 2015. This requires identifying stadiums that have concerts in both years and ensuring that the results are unique. The `JOIN` operation will link the `stadium` and `concert` tables based on the `Stadium_ID`, and the `WHERE` clause will filter the results for the specified years.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names and locations of stadiums that hosted concerts in both the years 2014 and 2015. This requires identifying stadiums that meet this condition by joining the concert and stadium tables and filtering based on the year.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to find the total number of concerts that took place in the stadium with the highest capacity. This requires identifying the stadium with the maximum capacity and then counting the number of concerts associated with that stadium.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the total number of concerts that took place in the stadium with the largest capacity. This requires counting the number of concerts and joining the concert and stadium tables, sorting the stadiums by capacity in descending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking to count the number of pets that have a weight greater than 10. This requires filtering the data based on a condition and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the total number of pets that have a weight greater than 10. To achieve this, we need to count the number of records in the \"Pets\" table where the \"weight\" column is greater than 10.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking to find the weight of the dog that is the youngest in age. This requires filtering the records to only include dogs, sorting them by age in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the weight of the youngest dog in the dataset. To achieve this, we need to filter the records to include only dogs, sort them by age in ascending order, and then select the weight of the first record.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is asking to find the maximum weight for each type of pet and to list both the maximum weight and the corresponding pet type. This requires grouping the data by pet type and then finding the maximum weight within each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to find the maximum weight and type for each type of pet. This requires grouping the data by pet type and then finding the maximum weight within each group.",
        "sql_skeleton": "SELECT _, _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to count the number of pets owned by students who are older than 20 years. This requires joining two tables (Student and Has_Pet) and filtering the results based on the age of the students.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of pets owned by students who are older than 20 years. This requires joining two tables (`Student` and `Has_Pet`) and filtering the results based on the age of the students.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of dog pets that are owned by female students. This requires joining multiple tables to filter and aggregate the data based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of dog pets that are raised by female students. This requires joining multiple tables to match students with their pets and filtering the results based on the student's gender and the type of pet.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to determine the number of unique pet types available in the dataset. This requires counting distinct values in the `pettype` column of the `pets` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of unique pet types available in the database. To achieve this, we need to count the distinct values in the `pettype` column of the `pets` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the first names of students who own either a cat or a dog. This requires joining multiple tables to match students with their pets and filtering the results based on the type of pet.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the first names of students who own either a cat or a dog as a pet. This requires joining multiple tables to match students with their pets and filtering the results based on the type of pet.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the first names of students who own both a cat and a dog. This requires identifying students with cat and dog pets and then finding the intersection of these two sets.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the first names of students who own both cats and dogs as pets. This requires identifying students who have pets of both types and then retrieving their first names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the major and age of students who do not own a cat. This requires filtering out students who have a cat from the list of all students.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE NOT _ IN (SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for the major and age of students who do not own a cat as a pet. This requires filtering out students who have a cat and then retrieving the relevant data for the remaining students.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE NOT _ IN (SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for the IDs of students who do not own a cat as a pet. This requires identifying students who are not associated with any cat pets and excluding those who are.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for the IDs of students who do not own cats as pets. This requires identifying students who do not have a pet of type 'CAT' and excluding those who do own a cat.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the first name and age of students who own a dog but do not own a cat. This requires filtering students based on their pet ownership and excluding those who have a cat.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ IN (SELECT _ FROM _ WHERE _ = _ EXCEPT SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for the first names of students who own a dog but do not own a cat. This requires filtering and set operations to exclude students who have both a dog and a cat.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the type and weight of the pet that is the youngest in age. This requires identifying the minimum age from the pets and then selecting the corresponding type and weight.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the type and weight of the youngest pet in the dataset. This requires identifying the minimum age among all pets and then retrieving the corresponding pet type and weight.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the unique identifiers (id) and weights of all pets that are older than one year. This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the identification number and weight of every pet that is older than one year. This requires filtering the data based on a condition and selecting specific columns from a table.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking to calculate the average and maximum age for each type of pet, which requires grouping the data by pet type and then performing aggregate calculations.",
        "sql_skeleton": "SELECT _, _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the calculation of the average and maximum ages of pets, grouped by each type of pet. This requires aggregating data based on the pet type and performing specific calculations on the age attribute.",
        "sql_skeleton": "SELECT _, _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to calculate the average weight of pets grouped by their type. This requires aggregating data based on the pet type and computing the average weight for each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the average weight of pets, grouped by each type of pet. This requires calculating the average value of the weight column and grouping the results by the pet type column.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the first names and ages of students who own at least one pet. This requires joining two tables: one containing student information and the other containing pet ownership information. The result should include only unique student entries.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the unique first names and ages of students who own pets. This requires identifying students who have pets and then retrieving their distinct first names and ages.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the ID of a pet that is owned by a student whose last name is 'Smith'. This requires joining two tables: one containing student information and the other containing pet ownership information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the unique identifier (ID) of the pet that is owned by a student whose last name is 'Smith'. This requires joining two tables: one containing student information and the other containing pet ownership information, and filtering the results based on the student's last name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of pets each student has and to include the student ID in the result. This requires joining two tables (Student and Has_Pet) and grouping the results by student ID to count the number of pets per student.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of pets each student has, but it requires listing the student IDs instead of their names. This involves counting the number of pets per student and grouping the results by student ID.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking to identify students who have more than one pet, and it requires retrieving the first name and gender of these students. This involves joining two tables (Student and Has_Pet), grouping the results by student ID, and filtering groups that have more than one pet.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the first names and genders of students who have more than one pet. This requires joining two tables (Student and Has_Pet) and filtering the results based on the count of pets per student.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the last name of a student who owns a cat that is exactly 3 years old. This requires joining two tables: one containing student information and the other containing pet information, and filtering the results based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the last name of a student who owns a cat that is 3 years old. This requires joining multiple tables to match students with their pets and filtering based on the pet's age and type.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the average age of students who do not own any pets. This requires filtering out students who have pets and then computing the average age of the remaining students.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking to calculate the average age of students who do not own any pets. This requires identifying students without pets and then computing the average age of this subset.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking for the total number of continents, which requires counting the entries in a table that lists continents.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of continents, which requires counting the entries in the \"CONTINENTS\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of countries in each continent, which requires counting the countries and grouping the results by continent. This involves joining two tables (CONTINENTS and COUNTRIES) and using aggregate functions to count the number of countries per continent.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to retrieve the ID, name, and the number of countries for each continent. This requires joining two tables (CONTINENTS and COUNTRIES) and grouping the results by the continent ID to count the number of countries.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the total number of countries listed in a database. To achieve this, we need to count the rows in the \"COUNTRIES\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of countries, which requires counting the entries in the \"COUNTRIES\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of models produced by each car maker, including the car maker's full name and ID. This requires counting the number of models per maker and joining the relevant tables to get the necessary information.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the full name of each car maker, along with their ID and the number of models they produce. This requires joining two tables (`car_makers` and `model_list`), counting the number of models per car maker, and grouping the results by car maker ID and name.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the model of the car that has the minimum horsepower. This requires joining two tables, filtering, sorting, and limiting the result to the first entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the model of the car that has the lowest horsepower. This requires joining two tables, sorting the results by horsepower in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the model of cars that have a weight lower than the average weight of all cars. This requires joining two tables, filtering based on a condition, and using an aggregate function to calculate the average weight.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the model of cars that have a weight smaller than the average weight of all cars. This requires filtering records based on a condition and joining tables to get the necessary data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of car makers that produced cars in the year 1970. This requires joining multiple tables to filter and retrieve the necessary data.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of car makers who produced cars in the year 1970. This requires joining multiple tables to match car makers with their respective cars and filtering the results based on the production year.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to find the make and production time (in years) of the cars that were produced in the earliest year. This requires joining two tables: one containing car details and the other containing car names, and then filtering the results to find the minimum production year.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the car maker and the year of the car that was produced in the earliest year. This requires identifying the minimum year from the dataset and then retrieving the corresponding car maker and year.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for a list of unique car models that were produced after the year 1980. This requires filtering the data based on the year and joining tables to get the necessary information.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for a list of unique car models that were produced after the year 1980. This requires joining two tables: one containing car details and the other containing car names, and then filtering the results based on the production year.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the number of car manufacturers in each continent. This requires counting the car makers grouped by their respective continents.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the name of each continent and the number of car makers associated with each continent. This requires joining two tables (countries and car_makers) based on a common key (countryId), grouping the results by continent, and counting the number of car makers in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking to identify the country that has the highest number of car manufacturers. This requires counting the number of car makers per country and then selecting the country with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the country that has the highest number of car manufacturers. This requires counting the number of car makers per country and then identifying the country with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the number of car models produced by each car maker, along with the full name of the maker. This requires counting the number of models per maker and joining tables to retrieve the maker's full name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the count of car models produced by each car maker, along with the ID and full name of each maker. This requires joining two tables (`car_makers` and `model_list`) on a common key (`maker` and `id`), grouping the results by the car maker's ID and full name, and counting the number of car models for each group.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the acceleration value of a specific car model, \"amc hornet sportabout (sw)\". To achieve this, we need to join two tables: one containing car data and the other containing car names, and then filter the results based on the car model name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the acceleration value of a specific car model, \"amc hornet sportabout (sw)\". To achieve this, we need to join two tables: one containing car details and the other containing car names, and then filter the results based on the car model.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of car manufacturers located in France. To achieve this, we need to count the entries in the `car_makers` table where the `Country` column matches \"France\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of car manufacturers (makers) based in France. To achieve this, we need to count the entries in the `car_makers` table where the country is France.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of car models that are produced in the USA. To achieve this, we need to count the number of entries in a table that contains car model information and filter those entries based on the country of production.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of car models produced in the United States. To achieve this, we need to count the entries in a database that meet specific conditions: the country is the United States, and the entries are related to car models.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the average miles per gallon (mpg) of cars that have 4 cylinders. To achieve this, we need to filter the data to include only cars with 4 cylinders and then calculate the average mpg for those cars.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the average miles per gallon (MPG) of vehicles that have 4 cylinders. This requires filtering the data to include only those vehicles with 4 cylinders and then calculating the average MPG for this subset of data.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the minimum weight of cars that have 8 cylinders and were produced in the year 1974. This requires filtering the data based on specific conditions and then finding the minimum value within the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the minimum weight of cars that have 8 cylinders and were produced in the year 1974. This requires filtering the data based on specific conditions and then finding the minimum value of the weight attribute.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of all car makers and their respective models. This requires retrieving data from two related tables: one containing car makers and the other containing car models.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for a list of makers and their corresponding models from a database. This requires selecting specific columns from a table that contains this information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for a list of countries that have at least one car maker, including the country name and its ID. This requires joining two tables: one containing car makers and the other containing country information, and then filtering the results to include only those countries that have at least one car maker.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names and IDs of countries that have at least one car manufacturer. This requires joining two tables (countries and car_makers) and filtering the results to include only those countries that have at least one associated car maker.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is asking for the count of cars that have a horsepower greater than 150. To achieve this, we need to filter the records based on the horsepower condition and then count the number of matching records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the total count of cars that have a horsepower greater than 150. This requires filtering the data based on the horsepower condition and then counting the number of records that meet this condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the average weight of cars, grouped by year. This requires calculating the average value of the `Weight` column and grouping the results by the `Year` column.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the calculation of the average weight and the average year, grouped by each year.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the names of countries in Europe that have at least three car manufacturers. This requires joining multiple tables to filter and count the car manufacturers per country.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names of European countries that have at least 3 car manufacturers. This requires filtering countries by continent, joining tables to get car manufacturer information, grouping by country, and counting the number of manufacturers per country.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the maximum horsepower of car models that have 3 cylinders, along with the make of these car models. This requires joining two tables, filtering based on the number of cylinders, and selecting the maximum horsepower.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the highest horsepower value among cars with 3 cylinders and the make of the car that has this highest horsepower. This requires filtering the data based on the number of cylinders, joining two tables to get the make, and then finding the maximum horsepower value.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the model of the car that has the highest miles per gallon (MPG). This requires joining two tables, sorting the results by MPG in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the car model that has the highest miles per gallon (mpg) rating. This requires joining two tables, sorting the results by mpg in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the average horsepower of cars that were manufactured before the year 1980. This requires filtering the data based on the year and then computing the average value of the horsepower column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _"
    },
    {
        "query_intent": "The question is asking for the average horsepower of all cars that were produced before the year 1980. To achieve this, we need to filter the data based on the year and then calculate the average of the horsepower values.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking for the average engine displacement (edispl) of cars that are of the Volvo model. To achieve this, we need to join two tables: one containing car details and the other containing car names, and then filter the results to only include cars with the model name \"volvo\".",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average engine displacement (edispl) of all cars made by Volvo. This requires joining multiple tables to filter cars by their maker and then calculating the average of the engine displacement.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to find the maximum acceleration value for each distinct number of cylinders in a dataset of car performance data. This requires grouping the data by the number of cylinders and then finding the maximum acceleration within each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the maximum acceleration value for each unique number of cylinders in the dataset. This requires grouping the data by the number of cylinders and then finding the maximum acceleration within each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the model that has the highest number of versions (makes) of cars. This requires counting the occurrences of each model and then selecting the one with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the model that has the highest number of different versions. This requires counting the occurrences of each model and then identifying the one with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the total number of cars that have more than 4 cylinders. To achieve this, we need to count the entries in the `cars_data` table where the `Cylinders` column has a value greater than 4.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the total count of cars that have more than 4 cylinders. This requires filtering the data based on the number of cylinders and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the total number of cars that were produced in the year 1980. To achieve this, we need to count the number of records in the `cars_data` table where the `Year` column is equal to 1980.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of cars produced in the year 1980. To achieve this, we need to count the number of records in the dataset that correspond to the year 1980.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of car models produced by a specific car maker, identified by their full name. This requires counting the entries in a database table that match a specific condition.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of car models produced by the American Motor Company. To achieve this, we need to count the number of entries in the `model_list` table where the car maker is identified as 'American Motor Company'.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for car makers who have designed more than 3 car models, and it requires listing their full names and IDs. This involves counting the number of car models per maker and filtering the results based on that count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the names and IDs of car makers who have more than 3 models. This requires joining two tables, grouping the results by maker ID, counting the number of models per maker, and filtering the results to include only those with more than 3 models.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for a list of unique car models that are either produced by a maker with the full name \"General Motors\" or have a weight greater than 3500. The SQL query needs to filter records based on these conditions and ensure that only distinct model names are returned.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ OR _ > _"
    },
    {
        "query_intent": "The question is looking for a list of unique car models that are either created by the car maker General Motors or have a weight greater than 3500. This requires filtering and joining data from multiple tables.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ OR _ > _"
    },
    {
        "query_intent": "The question is looking for the years in which cars were produced with weights between 3000 and 4000. This requires filtering data based on weight and selecting distinct years.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the distinct years in which cars were produced that had a weight less than 4000 and also cars that had a weight more than 3000. This requires finding the intersection of two sets of years based on the weight condition.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ < _ INTERSECT SELECT DISTINCT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the horsepower of the car that has the highest acceleration. This requires sorting the cars by their acceleration in descending order and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the horsepower of the car that has the highest acceleration. To achieve this, we need to sort the cars by their acceleration in descending order and then select the horsepower of the top car.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the number of cylinders of the car with the least acceleration for the model \"volvo\". This requires joining two tables, filtering by the model, sorting by acceleration in ascending order, and counting the relevant records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the number of cylinders in the Volvo model that has the least acceleration. This requires filtering the data for Volvo models, joining the relevant tables, and ordering the results by acceleration to find the minimum value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is asking for the count of cars that have an acceleration greater than the car with the highest horsepower. This requires comparing values and counting results based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > (SELECT _ FROM _ ORDER BY _ DESC LIMIT _)"
    },
    {
        "query_intent": "The question is asking for the count of cars that have an acceleration greater than the maximum acceleration of the car with the highest horsepower. This requires filtering and counting records based on conditions related to acceleration and horsepower.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > (SELECT _ FROM _ ORDER BY _ DESC LIMIT _)"
    },
    {
        "query_intent": "The question is looking to count the number of countries that have more than two car makers associated with them. This requires joining two tables (countries and car_makers) and then grouping the results by country to count the number of car makers per country, filtering those counts to only include those greater than two.",
        "sql_skeleton": "SELECT _ FROM (SELECT _, _ AS COUNTRYNUM FROM _ GROUP BY _) AS T WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the count of countries that have more than two car makers. This requires grouping the data by country and then filtering groups based on the count of car makers.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is asking for the total number of cars that have more than 6 cylinders. To achieve this, we need to count the entries in the database where the number of cylinders is greater than 6.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the total number of cars that have more than 6 cylinders. To achieve this, we need to filter the records based on the number of cylinders and then count the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the model of cars that have 4 cylinders and the highest horsepower. This requires filtering the data based on the number of cylinders, sorting the results by horsepower in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the model of the 4-cylinder car that has the highest horsepower. This requires filtering the data to include only 4-cylinder cars, sorting them by horsepower in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for cars that have more horsepower than the minimum horsepower among all cars, but do not have more than 3 cylinders. The output should include the car's make ID and make name. This requires filtering and joining data from two tables: `cars_data` and `car_names`.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ > (SELECT _ FROM _) AND _ > _"
    },
    {
        "query_intent": "The question is looking for the make IDs and names of cars that have less than 4 cylinders and a horsepower less than the minimum horsepower. This requires filtering and joining tables to retrieve the necessary data.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the highest miles per gallon (mpg) value from cars that have either 8 cylinders or were produced before the year 1980. This requires filtering the data based on specific conditions and then finding the maximum value from the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ < _"
    },
    {
        "query_intent": "The question is looking for the highest fuel efficiency (mpg) of cars that either have 8 cylinders or were produced before the year 1980. This requires filtering the data based on conditions and then finding the maximum value of the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ < _"
    },
    {
        "query_intent": "The question is looking for car models that have a weight less than 3500 units and are not manufactured by the 'Ford Motor Company'. This requires filtering and joining data from multiple tables.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ < _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for a list of unique car models that weigh less than 3500 units and were not manufactured by the Ford Motor Company. This requires filtering and joining data from multiple tables.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ < _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for the names of countries that do not have any car makers. This requires identifying countries that are not associated with any car makers in the dataset.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the names of countries that do not have any car manufacturers. This requires identifying countries that are not present in the list of countries with car makers.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for car makers that produce at least 2 models and are among more than 3 car makers. This requires filtering and joining tables to count the number of models per car maker and then selecting those that meet the criteria.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _ INTERSECT SELECT _, _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the IDs and makers of car manufacturers that produce at least 2 different models and have more than 3 cars in total. This requires joining two tables, grouping the results, and applying filters based on the count of models and cars.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _ INTERSECT SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the IDs and names of countries that either have more than 3 car makers or produce the 'fiat' model. This requires filtering and joining multiple tables to get the desired results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ IN (SELECT _ FROM _ WHERE _ = _ GROUP BY _ HAVING _ > _)"
    },
    {
        "query_intent": "The question is looking for the IDs and names of countries that either have more than 3 car makers or produce Fiat models. This requires filtering and joining multiple tables to get the desired results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ UNION SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking to identify the country associated with the airline \"JetBlue Airways\" from a database. This requires selecting specific data from a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the country associated with JetBlue Airways from a database. This requires querying a table that contains information about airlines to find the country corresponding to the specified airline name.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the abbreviation of a specific airline, \"JetBlue Airways\", from a database. This requires selecting a specific column from a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the abbreviation of \"JetBlue Airways\" from a database table that contains airline information. This requires selecting specific data from a table based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of airline names and their corresponding abbreviations, specifically for airlines based in the USA. To achieve this, we need to filter the data based on the country being \"USA\" and select the relevant columns.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of airline names and their abbreviations that are based in the USA. To achieve this, we need to filter the data to include only those airlines that are from the USA and then select the relevant columns.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the airport code and name for all airports located in the city of Anthony. This requires selecting specific columns from a table where a condition is met.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the airport code and airport name of airports located in the city named \"Anthony\". To achieve this, we need to filter the data based on the city name and select the relevant columns.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of airlines, which requires counting the rows in a table that lists airlines.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of airlines, which requires counting the rows in a table that lists airlines.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of airports, which requires counting the entries in the `AIRPORTS` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of airports, which requires counting the entries in the \"airports\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of flights available in the database. To achieve this, we need to count the number of records in the \"FLIGHTS\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total count of records in the \"flights\" table, which represents the number of flights. To achieve this, we need to use an aggregate function that counts the rows in the table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the name of the airline that has the abbreviation 'UAL'. To achieve this, we need to filter the records in the 'airlines' table where the 'Abbreviation' column matches 'UAL' and select the 'Airline' column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the name of an airline that has the abbreviation 'UAL'. This requires selecting specific data from a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of airlines that are based in the USA. To achieve this, we need to count the entries in the \"airlines\" table where the country is \"USA\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of airlines that are based in the USA. To achieve this, we need to count the entries in a table that contains airline information and filter the results to only include those from the USA.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the city and country where the Alton airport is located. This requires retrieving specific information from a database by matching the airport name with 'Alton'.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the city and country associated with the Alton airport. To achieve this, we need to retrieve specific columns from a database table that contains airport information.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the name of an airport that has the code 'AKO'. To achieve this, we need to retrieve data from a database table where the airport code matches 'AKO'.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the name of an airport from a database where the airport code matches 'AKO'. This requires selecting specific data from a table based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the names of airports located in the city of Aberdeen. To achieve this, we need to retrieve specific columns from a database table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of airports located in the city of Aberdeen. To achieve this, we need to filter the airport data based on the city name \"Aberdeen\" and select the airport names.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of flights that depart from the airport with the code 'APG'. To achieve this, we need to count the entries in the `FLIGHTS` table where the `SOURCEAIRPORT` column matches 'APG'.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of flights that are departing from the airport with the code 'APG'. This requires filtering the flights based on their source airport and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of flights that have \"ATO\" as their destination airport. To achieve this, we need to count the number of records in the FLIGHTS table where the destination airport matches \"ATO\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of flights that are destined for the airport with the code \"ATO\". This requires filtering the flights based on the destination airport code and then counting the resulting rows.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of flights that depart from the city of Aberdeen. This requires joining the flights table with the airports table to match the source airport codes with city names and then counting the resulting records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of flights that are departing from Aberdeen. To achieve this, we need to count the entries in the `FLIGHTS` table where the `SourceAirport` matches the airport code for Aberdeen.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of flights that are arriving in the city of Aberdeen. To achieve this, we need to count the number of records in the FLIGHTS table where the destination airport is located in Aberdeen.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of flights that are arriving in the city of Aberdeen. To achieve this, we need to count the entries in the FLIGHTS table where the destination airport is located in Aberdeen. This requires joining the FLIGHTS table with the AIRPORTS table to match the destination airport code with the city name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of flights that depart from the city of 'Aberdeen' and have the city of 'Ashley' as their destination. This requires joining two tables: one containing flight information and the other containing airport information, and then filtering the results based on specific city names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of flights that depart from Aberdeen and arrive at Ashley. To achieve this, we need to count the entries in the `FLIGHTS` table where the `SourceAirport` is 'ABZ' (Aberdeen Airport) and the `DestAirport` is 'ASH' (Ashley Airport).",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of flights operated by the airline 'JetBlue Airways'. To achieve this, we need to count the number of records in the `FLIGHTS` table that are associated with 'JetBlue Airways' in the `AIRLINES` table. This requires joining the two tables on a common key and filtering the results based on the airline name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of flights operated by JetBlue Airways. To achieve this, we need to count the number of records in the `FLIGHTS` table that are associated with JetBlue Airways in the `AIRLINES` table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of flights operated by \"United Airlines\" that have \"ASY\" as their destination airport. This requires filtering flights based on the airline name and destination airport, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of flights operated by \"United Airlines\" that are arriving at \"ASY Airport\". This requires filtering flights based on the airline name and destination airport, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the number of flights operated by 'United Airlines' that depart from a specific airport, 'AHD'. To achieve this, we need to join the airlines and flights tables, filter by the airline name and departure airport, and count the resulting records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of flights operated by United Airlines that are departing from AHD Airport. This requires joining two tables (airlines and flights) on a common key (Airline) and filtering the results based on specific conditions (Airline = 'United Airlines' and SourceAirport = 'AHD').",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of flights operated by United Airlines that have 'Aberdeen' as their destination city. This requires joining the flights and airports tables, filtering by the destination city and airline name, and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of flights operated by United Airlines that arrive at Aberdeen Airport. This requires filtering flights by the airline name, joining flight information with airport information, and counting the resulting records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the city that has the highest number of arriving flights. This requires counting the number of flights arriving at each city and then identifying the city with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the city that has the highest number of destination airports. This requires counting the occurrences of each city as a destination airport and then identifying the city with the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the city that has the highest number of departing flights. This requires counting the number of flights originating from each city and then identifying the city with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the city that has the highest number of flights originating from it. This requires counting the number of flights for each city and then identifying the city with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the airport code that has the highest number of flights. This requires counting the number of flights for each airport and then selecting the airport with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the airport code of the airport that has the highest number of flights. This requires counting the number of flights for each airport and then identifying the airport with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the airport code that has the fewest number of flights. This requires counting the number of flights for each airport and then selecting the airport with the minimum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the airport code that has the fewest flights. This requires counting the number of flights for each airport and then selecting the one with the minimum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify the airline that operates the highest number of flights. This requires counting the number of flights for each airline and then selecting the airline with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify the airline that operates the highest number of flights. This requires counting the number of flights for each airline and then selecting the airline with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the abbreviation and country of the airline that operates the fewest number of flights. This requires joining the airlines and flights tables, grouping by airline, counting the number of flights, and then ordering the results to find the airline with the minimum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the abbreviation of the airline that has the fewest flights and the country where this airline is based. This requires joining two tables (AIRLINES and FLIGHTS), grouping the results by airline abbreviation, counting the number of flights for each group, and then selecting the group with the minimum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _, _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of airlines that have flights departing from the airport with the code 'AHD'. This requires joining the airlines and flights tables based on the airline's identifier and filtering the results by the source airport code.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique airlines that have flights originating from the airport with the code \"AHD\". This requires joining the flights and airports tables, filtering by the source airport code, and selecting distinct airline names.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of airlines that have flights arriving at a specific airport, identified by the code 'AHD'. To achieve this, we need to join the airlines and flights tables based on a common identifier and filter the results by the destination airport code.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify airlines that operate flights with the destination airport code \"AHD\". This requires joining the airlines and flights tables based on airline information and filtering the results by the destination airport code.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for airlines that operate flights from both 'APG' and 'CVO' airports. This requires identifying airlines that have flights originating from each of these airports and then finding the intersection of those sets of airlines.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for airlines that have flights departing from both the APG and CVO airports. This requires identifying airlines with flights from both source airports and finding the intersection of these sets of airlines.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of airlines that operate flights from a specific airport ('CVO') but do not operate flights from another specific airport ('APG'). This requires identifying airlines that meet the criteria by filtering based on source airports.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for airlines that have flights departing from the \"CVO\" airport but do not have flights departing from the \"APG\" airport. This requires filtering and set operations.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of airlines that operate at least 10 flights. This requires joining the airlines and flights tables, grouping the results by airline, and filtering groups that have a count of flights greater than or equal to 10.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking to identify airlines that operate at least 10 flights. This requires joining the airlines and flights tables, grouping the results by airline, and filtering groups that have a count of flights greater than or equal to 10.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for a list of airlines that operate fewer than 200 flights. This requires joining the airlines and flights tables, grouping the results by airline, and filtering groups based on the count of flights.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ < _"
    },
    {
        "query_intent": "The question is looking for the names of airlines that operate fewer than 200 flights. This requires joining the airlines and flights tables, grouping the results by airline, counting the number of flights, and filtering the results based on the count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ < _"
    },
    {
        "query_intent": "The question is looking for the flight numbers associated with \"United Airlines\". To achieve this, we need to retrieve data from a database where flights are recorded, and the airline names are linked to their respective flight numbers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the flight numbers that are operated by United Airlines. To achieve this, we need to join the airlines table with the flights table based on the airline abbreviation and filter the results to include only those flights operated by United Airlines.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the flight numbers of flights that are departing from a specific airport, identified by the code \"APG\". To achieve this, we need to filter the flights based on their source airport.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the flight numbers of flights that are departing from the airport with the code \"APG\". This requires filtering the flights based on their source airport.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the flight numbers of flights that are arriving at a specific airport, identified by the code \"APG\". This requires joining the flights table with the airports table to match the destination airport code with the airport name.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the flight numbers of flights that are landing at the airport with the code \"APG\". This requires filtering the flights based on their destination airport.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the flight numbers of flights that are departing from the city of \"Aberdeen\". This requires joining the flights and airports tables to match the source airport with the city \"Aberdeen\".",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the flight numbers of flights that are departing from Aberdeen. This requires retrieving data from a database where the source airport is located in Aberdeen. The SQL query needs to filter records based on the city name 'Aberdeen' and join the necessary tables to get the flight numbers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the flight numbers of flights that are arriving at the city of \"Aberdeen\". This requires joining the airports and flights tables to match the destination airport with the city \"Aberdeen\".",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the flight numbers of flights that are arriving in the city of Aberdeen. To achieve this, we need to join the flights table with the airports table to match the destination airport with the city Aberdeen.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of flights that are landing in either the city of Aberdeen or Abilene. This requires filtering the data based on the city and then counting the filtered records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of flights that land in either Aberdeen or Abilene. To achieve this, we need to count the relevant records from the `FLIGHTS` table and join it with the `AIRPORTS` table to filter by city name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the names of airports that do not have any flights departing from or arriving at those airports. This requires identifying airports that are not present in the list of source or destination airports in the flights table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _) AND NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for a list of airports that do not appear as either the source or destination of any flights. This requires identifying airports that are not present in the flights dataset.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _ AND _ <> _"
    },
    {
        "query_intent": "The question is asking for the total number of employees in the database. To achieve this, we need to count the number of records in the \"employee\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to determine the total number of records in the \"employee\" table, which essentially counts the number of employees. This requires using an aggregate function to count the rows in the table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to sort a list of employee names based on their ages in ascending order. This requires selecting the `Name` column from the `employee` table and ordering the results by the `Age` column in ascending order.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking to retrieve the names of employees and sort the results in ascending order based on their age. This requires selecting specific columns from a table and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking for the total number of employees grouped by their city of residence. This requires counting the number of records in the `employee` table and grouping the results by the `city` column.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to count the number of employees grouped by their city. This requires aggregating the data based on the city attribute.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for cities that have more than one employee under the age of 30. This requires filtering employees by age, grouping the results by city, and then counting the number of employees in each city to find those with more than one.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for cities that have more than one employee who is under the age of 30. This requires filtering employees based on age, grouping the results by city, and then counting the number of employees in each group to find cities with more than one such employee.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is asking to determine the count of shops in each unique location. This requires grouping the data by location and counting the number of entries in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of shops in each location, which requires counting the entries and grouping the results by location.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the name and district of the shop that has the highest number of products. This requires identifying the maximum value in the \"Number_products\" column and then retrieving the corresponding \"Manager_name\" and \"District\" for that shop.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the manager's name and the district of the shop that has the highest number of products. This requires identifying the maximum value of the `number_products` column and then retrieving the corresponding `manager_name` and `district`.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to find the smallest and largest number of products available across all stores. This requires identifying the minimum and maximum values within a specific column in a database table.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the smallest and largest number of products available across all shops. This requires identifying the minimum and maximum values in a specific column of a table.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve specific details (name, location, and district) of all shops, sorted in descending order based on the number of products they have. This requires selecting specific columns from a table and ordering the results.",
        "sql_skeleton": "SELECT _, _, _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking to retrieve and sort data from a table of shops based on the number of products they have, in descending order. The required output includes the name, location, and district of each shop.",
        "sql_skeleton": "SELECT _, _, _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking for the names of stores that have a number of products greater than the average number of products across all stores. This requires filtering based on a comparison with an aggregate function.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of shops that have a number of products greater than the average number of products across all shops. This requires calculating the average and then filtering the results accordingly.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the name of the employee who has received the most awards in the evaluation process. This requires identifying the employee with the highest count of awards and retrieving their name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the employee who has received the most awards in evaluations. This requires identifying the employee with the highest count of awards and retrieving their name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the employee who received the highest one-time bonus. This requires joining two tables (`employee` and `evaluation`), filtering for one-time bonuses, sorting by bonus amount in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the employee who received the highest bonus. This requires joining two tables (employee and evaluation), sorting the results by the bonus in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of employees who have never received any awards in the evaluation process. This requires identifying employees who do not appear in the evaluation records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of employees who have never received any evaluation. This requires identifying employees who are not present in the evaluation records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the name of the shop that has the highest number of employees hired. This requires joining two tables (hiring and shop), grouping the results by shop name, counting the number of employees for each shop, and then ordering the results to find the shop with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the shop that has the highest number of employees. This requires counting the number of employees per shop and then identifying the shop with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of shops that do not have any employees hired. This requires identifying shops that are not present in the hiring records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of shops that do not have any employees. This requires identifying shops that are not associated with any employees in the hiring records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking to find the count of employees hired in each shop and to display the shop name along with this count. This requires joining two tables (one containing shop information and the other containing hiring information) and then grouping the results by shop name to count the number of employees hired in each shop.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of employees working at each shop and the name of the shop. This requires joining two tables (one containing employee information and another containing shop information) and then grouping the results by shop name to count the number of employees at each shop.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the total sum of bonuses awarded in all evaluations. To achieve this, we need to aggregate the bonus data by summing it up.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to calculate the total sum of the bonus amounts from all records in the evaluation table. This requires aggregating data using a sum function.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for all available data related to hiring, which implies retrieving all columns and rows from the \"hiring\" table. This requires selecting all columns from the specified table.",
        "sql_skeleton": "SELECT * FROM _"
    },
    {
        "query_intent": "The question is asking for all available information related to hiring, which implies that we need to retrieve all columns and rows from the \"hiring\" table.",
        "sql_skeleton": "SELECT * FROM _"
    },
    {
        "query_intent": "The question is looking for districts that have stores with less than 3000 products and stores with more than 10000 products. This requires identifying districts that meet both conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ INTERSECT SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for districts that have shops with both a low number of products (less than 3000) and a high number of products (more than 10000). This requires identifying districts that meet both conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ INTERSECT SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the number of unique store locations, which requires counting distinct values in the `LOCATION` column of the `shop` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to count the number of unique store locations in a database. This requires identifying distinct values in the `LOCATION` column of the `shop` table and then counting those distinct values.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of documents in a database. To achieve this, we need to count the rows in the \"Documents\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to determine the total number of entries in the \"Documents\" table. This requires counting all rows in the specified table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve specific columns (document IDs, names, and descriptions) from a table that stores document information. The SQL query needs to select these columns from the appropriate table.",
        "sql_skeleton": "SELECT _, _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the IDs, names, and descriptions of all documents from a database. This requires selecting specific columns from a table that stores document information.",
        "sql_skeleton": "SELECT _, _, _ FROM _"
    },
    {
        "query_intent": "The question is looking for the document name and template ID of documents that have a description containing the letter 'w'. This requires filtering the records based on a condition and selecting specific columns from the filtered results.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is asking to retrieve the names and template IDs of documents where the description includes the letter 'w'. This requires filtering the records based on a condition applied to the description field.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for specific details (document_id, template_id, and description) for a document that has the name \"Robbin CV\". This requires selecting specific columns from a table where a condition is met.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve specific columns (document_id, template_id, and document_description) from a table where the document_name matches \"Robbin CV\". This requires filtering the data based on a condition.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of unique templates that are used across all documents. This requires identifying distinct template IDs from the Documents table and then counting them.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to determine the number of unique templates that are used for documents. This requires counting distinct values in the `template_id` column of the `documents` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the count of documents that are associated with a specific template type identified by the code 'PPT'. This requires joining two tables (Documents and Templates) and filtering the results based on the template type code.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of documents that are associated with a specific template type, identified by the code 'PPT'. This requires joining two tables (Templates and Documents) based on a common key (template_id) and filtering the results based on the template type code.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of all unique template IDs along with the count of documents associated with each template. This requires grouping the documents by their template IDs and counting the number of documents in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for a count of occurrences for each unique template ID used in documents. This requires grouping the data by template ID and counting the number of entries in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the template ID and type code of the template that is used by the highest number of documents. This requires joining two tables, grouping the results by template ID, counting the number of documents per template, and then selecting the template with the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the template ID and type code of the template that is associated with the highest number of documents. This requires joining two tables (Templates and Documents), grouping the results by template ID and type code, counting the number of documents for each group, and then selecting the group with the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for template IDs that are associated with more than one document. This requires counting the number of documents per template and filtering the results to include only those with a count greater than one.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the IDs of templates that are used in more than one document. This requires counting the occurrences of each template ID in the `documents` table and filtering the results to include only those with a count greater than one.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for template IDs that are not associated with any documents. This requires identifying template IDs that do not exist in the Documents table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the IDs of templates that do not have any associated documents. This requires identifying template IDs that are not present in the list of template IDs used in documents.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of templates available in a database. To achieve this, we need to count the number of records in the \"Templates\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to determine the total number of records in the \"Templates\" table. This requires counting all rows in the specified table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve specific columns (template IDs, version numbers, and template type codes) from a table that stores template information. This requires selecting specific fields from a database table.",
        "sql_skeleton": "SELECT _, _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for specific columns (ids, version numbers, and type codes) from a table that stores template information. This requires selecting specific fields from a database table.",
        "sql_skeleton": "SELECT _, _, _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve all unique template type codes from the \"Templates\" table. This requires selecting distinct values from a specific column.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _"
    },
    {
        "query_intent": "The question is asking for a list of unique template type codes from the \"Templates\" table. This requires selecting distinct values from a specific column in the table.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the IDs of templates that have a specific type code, either 'PP' or 'PPT'. The SQL query needs to filter records based on these conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the IDs of templates that have specific codes (either 'PP' or 'PPT'). This requires filtering the records in the Templates table based on the template_type_code.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking for the count of records in the \"Templates\" table where the \"template_type_code\" is equal to \"CV\". This requires filtering the data based on a condition and then counting the number of records that meet that condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of records in the \"Templates\" table where the \"Template_Type_Code\" is equal to \"CV\". This requires filtering the records based on a condition and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the version number and template type code of templates that have a version number greater than 5. This requires filtering the records based on a condition and selecting specific columns from the filtered results.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking to retrieve specific columns (`version_number` and `template_type_code`) from a table (`Templates`) where the `version_number` is greater than 5. This requires filtering the data based on a condition.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking to display all unique template type codes along with the count of templates for each type. This requires grouping the data by template type codes and counting the number of entries in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for a count of templates grouped by their type codes. This requires identifying distinct template type codes and counting the number of templates associated with each code.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking to identify the template type code that has the highest number of templates. This requires counting the number of templates for each type code and then selecting the one with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to identify the template type code that has the highest number of templates. This requires counting the occurrences of each template type code and then selecting the one with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve all unique template type codes from the \"Templates\" table where the number of templates for each type code is less than three. This requires grouping the data by template type code and filtering the groups based on their count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ < _"
    },
    {
        "query_intent": "The question is looking for the template type codes that have fewer than 3 associated templates. This requires counting the number of templates per template type and filtering the results to include only those with a count less than 3.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ < _"
    },
    {
        "query_intent": "The question is looking for the smallest version number and its corresponding template type code from the Templates table. This requires selecting specific columns, ordering the results by version number in ascending order, and limiting the result to the first entry.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the minimum version number from the \"Templates\" table and return it along with its corresponding template type code. This requires identifying the minimum value in a specific column and selecting related data from another column.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the template type code associated with a specific document named \"Data base\". This requires joining two tables: one containing document details and the other containing template details, and then filtering the results based on the document name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the template type code associated with a document named \"Data base\". This requires joining the `Templates` and `Documents` tables based on a common key and filtering the results to find the specific document.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of document names that are associated with templates of a specific type, identified by the template type code \"BK\". This requires joining two tables: one containing template details and another containing document details, and filtering the results based on the template type code.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of documents that are associated with templates identified by a specific code ('BK'). This requires joining two tables: one containing document information and the other containing template information, and then filtering the results based on the template code.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to display all unique template type codes along with the count of documents associated with each type. This requires joining two tables, grouping the results by the template type code, and counting the number of documents for each group.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for a count of documents grouped by their associated template type codes. This requires joining two tables (Documents and Templates) on a common key (template_id), and then grouping the results by the template type code to count the number of documents for each type.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the template type code that is associated with the highest number of documents. This requires counting the occurrences of each template type code in the documents table and then identifying the one with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the template type code that appears most frequently in the documents. This requires counting occurrences of each template type code, identifying the highest count, and then retrieving the corresponding template type code.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for all unique template type codes that are not associated with any documents. This requires identifying template type codes that are not present in the list of template IDs used by documents.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the template type codes that exist in the `Templates` table but do not have any corresponding entries in the `Documents` table. This requires identifying template types that are not used for any documents.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve all the template type codes and their corresponding descriptions from a specific table. This requires selecting specific columns from a table in a database.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the type codes and descriptions of all template types from a database. This requires selecting specific columns from a table that contains this information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve the description of a template type from a table where the template type code is \"AD\". This requires selecting specific data from a table based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the description of a template type that has a specific code \"AD\". This requires selecting data from a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the template type code associated with a template type description that is \"Book\". This requires retrieving specific data from a database table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the code associated with a template type that has a description of \"Book\". This requires querying a database table to find a specific value based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the distinct descriptions of template types that are used by any document. This requires identifying the template types associated with documents and then retrieving unique descriptions of those template types.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve unique descriptions of templates that are associated with documents. This requires identifying distinct values in the `template_details` column from the `templates` table where there is a corresponding entry in the `documents` table.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of templates that have a specific type description, \"Presentation\". This requires joining two tables: one containing template details and another containing template type descriptions, and then filtering the results based on the description.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the IDs of templates that have a description of 'Presentation'. This requires filtering the data based on a specific condition and selecting the relevant column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of paragraphs in a database table. To achieve this, we need to count all the rows in the \"Paragraphs\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to count the total number of paragraphs in a text document. This requires counting the rows in a table that stores paragraph information.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of paragraphs in a document named 'Summer Show'. To achieve this, we need to count the paragraphs associated with that document by joining the relevant tables.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of paragraphs within a document named 'Summer Show'. This requires joining two tables (Paragraphs and Documents) based on a common field (document_id) and filtering the results by the document name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve specific details (other details) of paragraphs that contain the text \"Korea\". This requires filtering the paragraphs based on a condition and selecting a specific column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for specific details from a paragraph that contains the text \"Korea\". This requires filtering the data based on a condition and selecting a specific column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is asking to retrieve all paragraph IDs and their corresponding texts from a document that has the name 'Welcome to NY'. This requires joining two tables: one containing paragraph details and the other containing document details, and then filtering the results based on the document name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs and texts of paragraphs that are part of a document with the title 'Welcome to NY'. This requires joining two tables: one containing paragraph details and another containing document details, and then filtering based on the document title.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve all paragraph texts from a specific document named \"Customer reviews\". This requires joining two tables: one containing paragraph texts and another containing document details, and then filtering the results based on the document name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the text content of paragraphs within a document named 'Customer reviews'. To achieve this, we need to retrieve data from two related tables: one containing document details and the other containing paragraph details. The SQL query should join these tables based on a common identifier and filter the results by the document name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to display all unique document IDs along with the count of paragraphs in each document, sorted by the document ID. This requires grouping the data by document ID and counting the number of paragraphs within each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking to count the number of paragraphs for each document and return the document IDs along with these counts, sorted by the document IDs. This requires grouping the data by document ID and then counting the number of paragraphs in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking to retrieve all unique document IDs, their corresponding names, and the count of paragraphs associated with each document. This requires joining two tables (Paragraphs and Documents) and grouping the results by document ID and name.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the IDs and names of each document, along with the count of paragraphs in each document. This requires joining two tables (Documents and Paragraphs) and grouping the results by document ID to count the number of paragraphs per document.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of document IDs that have at least two paragraphs associated with them. This requires counting the number of paragraphs per document and filtering the results to include only those with a count of two or more.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the IDs of documents that contain two or more paragraphs. This requires counting the number of paragraphs per document and filtering the results to include only those with a count of two or more.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the document ID and name that have the highest number of paragraphs. This requires counting the number of paragraphs per document, grouping the results by document ID, and then selecting the document with the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the document ID and name of the document that contains the highest number of paragraphs. This requires joining two tables, grouping by document ID, counting the number of paragraphs, and then selecting the document with the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the document ID that has the fewest number of paragraphs. This requires counting the number of paragraphs per document and then identifying the document with the minimum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify the document that contains the smallest number of paragraphs. This requires grouping the documents by their IDs, counting the number of paragraphs in each document, and then selecting the document with the minimum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for document IDs that contain a number of paragraphs within the range of 1 to 2. This requires counting the number of paragraphs per document and filtering the results based on that count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the IDs of documents that contain between one and two paragraphs. This requires counting the number of paragraphs per document and filtering the results accordingly.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for document IDs that contain both the paragraph texts 'Brazil' and 'Ireland'. This requires identifying documents that meet both conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ INTERSECT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of documents that contain both the paragraph text 'Brazil' and 'Ireland'. This requires identifying documents that meet both conditions and finding their intersection.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ INTERSECT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of teachers in a database. To achieve this, we need to count the number of records in the \"teacher\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of teachers in the database. To achieve this, we need to count the number of records in the \"teacher\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of teacher names sorted by their age in ascending order. This requires selecting specific columns from a table and ordering the results based on a particular column.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking for a list of teacher names sorted by their age in ascending order. This requires selecting the `Name` column from the `teacher` table and ordering the results by the `Age` column.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking for the age and hometown information of teachers from a database. To retrieve this information, we need to select specific columns from a table that contains teacher data.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the age and hometown of all teachers from a database. This requires selecting specific columns from a table that contains teacher information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of teachers whose hometown is not \"Little Lever Urban District\". This requires filtering the data based on a condition and selecting specific columns from a table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the names of teachers who do not have \"Little Lever Urban District\" as their hometown. This requires filtering out specific values in a SQL query.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of teachers who are either 32 or 33 years old. This requires filtering the data based on specific age criteria.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the names of teachers who are either 32 or 33 years old. This requires filtering the data based on specific age criteria.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the hometown of the teacher who is the youngest in age. This requires identifying the minimum age from the teacher table and then selecting the corresponding hometown.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the hometown of the youngest teacher. To achieve this, we need to sort the teachers by their age in ascending order and then select the hometown of the first teacher in the sorted list.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking to display the different hometowns of teachers and the count of teachers from each hometown. This requires grouping the data by hometown and counting the number of entries in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of teachers grouped by their hometowns. This requires counting the number of records for each unique hometown in the `teacher` table.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to identify the most frequently occurring hometown among the teachers. This requires counting the occurrences of each hometown and then selecting the one with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the most common hometowns among teachers. This requires identifying the hometowns, counting the number of teachers in each hometown, and then selecting the hometown with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to identify the hometowns that are shared by at least two teachers. This requires counting the number of teachers in each hometown and filtering those counts to find the minimum threshold of two.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names of towns that have at least two teachers originating from them. This requires counting the number of teachers per town and filtering the results to include only those towns with a count of two or more.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is asking for a list of teacher names along with the courses they are assigned to teach. This requires retrieving data from multiple related tables using joins.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for a list of teacher names and the courses they teach. This requires retrieving data from two related tables: one containing teacher information and another containing course arrangements.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for a list of teacher names and the courses they are assigned to teach, sorted in ascending order by the teacher's name. This requires joining two tables (one for teachers and one for course arrangements) and selecting specific columns.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _"
    },
    {
        "query_intent": "The question is looking for a list of teacher names and the courses they teach, sorted in ascending alphabetical order by the teacher's name. This requires joining multiple tables to retrieve the necessary information and then sorting the results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking to retrieve the names of teachers who are responsible for teaching the math course. This requires joining multiple tables to match courses with their corresponding teachers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of teachers who are assigned to teach math courses. This requires joining multiple tables to match courses with their corresponding teachers and filtering the results to include only math courses.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of teacher names along with the count of courses each teacher is responsible for. This requires joining two tables (one for teachers and one for course arrangements) and grouping the results by teacher name to count the number of courses per teacher.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the names of teachers and the number of courses each teacher teaches. This requires joining two tables (teacher and course_arrange) on a common key (teacher_id), grouping the results by teacher names, and counting the number of courses per teacher.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the names of teachers who are assigned to teach at least two courses. This requires identifying teachers and their course assignments, then filtering and grouping the results to count the number of courses per teacher.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names of teachers who are assigned to teach at least two courses. This requires joining two tables, grouping the results by teacher names, and filtering groups based on the count of courses.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names of teachers who are not assigned to teach any courses. This requires identifying teachers whose IDs do not appear in the course arrangement records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of teachers who do not have any courses assigned to them. This requires identifying teachers whose IDs are not present in the course arrangement table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking for the total number of visitors who are below the age of 30. To achieve this, we need to count the entries in the `visitor` table where the `age` column is less than 30.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of visitors who have a membership level greater than 4 and to sort the results by the membership level in descending order. This requires filtering the data based on a condition and then ordering the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking to calculate the average age of visitors who have a membership level that is not higher than 4. This requires filtering the data based on a condition and then computing the average of the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <= _"
    },
    {
        "query_intent": "The question is looking for the names and membership levels of visitors who have a membership level greater than 4, and it requires the results to be sorted by age in descending order (from old to young). This involves filtering, selecting, and ordering data from a database table.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ > _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking to identify the museum with the highest number of staff members by retrieving the museum's ID and name. This requires sorting the museums by the number of staff in descending order and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the average number of staff members for museums that were opened before the year 2009. This requires filtering the data based on the opening year and then computing the average of the number of staff.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _"
    },
    {
        "query_intent": "The question is asking for specific details (opening year and staff number) of a museum that has a particular name (\"Plaza Museum\"). To achieve this, we need to filter the records in the \"museum\" table based on the museum's name.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of museums that have a staff number greater than the minimum staff number of all museums that were opened after the year 2010. This requires filtering museums based on their opening year and comparing their staff numbers to the minimum staff number of the filtered museums.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > (SELECT _ FROM _ WHERE _ > _)"
    },
    {
        "query_intent": "The question is looking for the identification, name, and age of visitors who have visited museums more than once. This requires identifying visitors based on their visit history and ensuring that each visitor is only listed once in the result.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the identification number, name, and membership level of the visitor who has spent the most money on museum tickets. This requires joining two tables, grouping the results, ordering them by the total amount spent in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the ID and name of the museum that has been visited the most times. This requires identifying the museum with the highest number of visits and retrieving its details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of museums that have not had any visitors. This requires identifying museums that are not present in the visit records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the name and age of the visitor who has purchased the highest number of tickets in a single transaction. This requires identifying the maximum number of tickets and then finding the corresponding visitor details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the average and maximum number of tickets purchased across all visits. This requires calculating aggregate values from a dataset of visit records.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is looking to calculate the total expenditure on tickets by visitors who have a membership level of 1. This requires aggregating data from two related tables: one containing visitor information and the other containing visit records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of a visitor who has visited both a museum that was opened before 2009 and a museum that was opened after 2011. This requires identifying visitors who meet both conditions and finding the intersection of these sets of visitors.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ < _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of visitors who did not visit any museum that was opened after the year 2010. This requires identifying museums opened after 2010 and then excluding visitors who visited those museums.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _ WHERE _ > _)"
    },
    {
        "query_intent": "The question is asking for the count of museums that were either opened after the year 2013 or before the year 2008. This requires filtering the records based on a condition and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ OR _ < _"
    },
    {
        "query_intent": "The question is asking to determine the total number of records in the \"players\" table, which essentially means counting all the rows in that table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of players, which requires counting the entries in the \"players\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to determine the total count of records in the \"matches\" table. This requires counting all rows in the specified table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to determine the total number of records in the \"matches\" table. This requires counting all rows in the specified table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve the first names and birth dates of players who are from the country with the code \"USA\". This requires filtering the data based on a condition.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the first names and birth dates of players who are from the USA. This requires filtering the data based on a specific condition (country code equal to 'USA').",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the average age of both the losers and the winners from all matches. This requires selecting the average values of two different columns (`winner_age` and `loser_age`) from the same table.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the average ages of both the winners and the losers from a set of matches. This requires calculating the average values of two distinct groups of data.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking to calculate the average rank of the winners from all matches recorded in the dataset. This requires aggregating the rank values and computing their average.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the average rank of the winners across all matches. This requires calculating the average value of the `winner_rank` column from the `matches` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to identify the minimum rank among all the losers in the matches. This requires selecting the minimum value from the `loser_rank` column in the `matches` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the minimum rank of the losers across all matches. This requires selecting the minimum value from the `loser_rank` column in the `matches` table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking to determine the number of unique country codes present in the list of players. This requires counting distinct values in a specific column of a table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of unique countries from which players originate. This requires counting distinct values in the `country_code` column of the `players` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to count the number of unique names of individuals who lost in the matches. This requires identifying distinct values and then counting them.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of unique loser names in the matches table. This requires counting distinct values in the `loser_name` column.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking to identify the tournament names that have more than 10 matches. This requires counting the number of matches per tournament and filtering the results to include only those with a count greater than 10.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the names of tournaments that have had more than 10 matches. This requires counting the number of matches per tournament and filtering the results to include only those with a count greater than 10.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the names of winners who participated in matches in both the years 2013 and 2016. This requires identifying common entries in the `winner_name` field for the specified years.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ INTERSECT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of players who have won matches in both the years 2013 and 2016. This requires identifying players who appear in the list of winners for both years.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ INTERSECT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of matches that took place in the years 2013 or 2016. To achieve this, we need to filter the records based on the year and then count the filtered records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of matches that were played in the years 2013 and 2016. To achieve this, we need to count the number of records in the \"matches\" table where the \"year\" column matches either 2013 or 2016.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the country code and first name of players who have won both the WTA Championships and the Australian Open. This requires identifying players who have won matches in both tournaments and then finding the common players among them.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the first names and country codes of players who have won both the WTA Championships and the Australian Open. This requires identifying players who have won these specific tournaments and then finding the intersection of these sets of players.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the first name and country code of the oldest player, which requires identifying the player with the latest birth date.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the first name and country code of the oldest player, which requires identifying the maximum birth date and then retrieving the corresponding first name and country code. This involves filtering, sorting, and limiting the results.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the first and last names of all players from a database, sorted by their birth dates in ascending order. This requires selecting specific columns and ordering the results based on a date column.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking for the full names (first and last names) of all players, sorted by their birth dates. This requires selecting specific columns from a table and ordering the results by a date column.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking for a list of the first and last names of all players who are left-handed, sorted by their birth date in ascending order. This requires filtering the data based on the 'hand' attribute and then ordering the results by the 'birth_date' attribute.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking for the full names (first and last names) of players who are left-handed, sorted by their birth date. This requires filtering the data based on the hand preference and then ordering the results by birth date.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ ORDER BY _"
    },
    {
        "query_intent": "The question is looking for the first name and country code of the player who has completed the highest number of tours. This requires identifying the player with the maximum number of tours and retrieving their details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the first name and country code of the player who has participated in the most tours. This requires joining two tables, sorting the results by the number of tours in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to identify the year that has the highest number of matches recorded in the database. This requires counting the number of matches for each year and then selecting the year with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the year that had the highest number of matches. This requires counting the number of matches for each year and then identifying the year with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name and rank points of the winner who has won the most matches. This requires identifying the winner with the highest count of wins and retrieving their details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the player who has won the most matches and the number of rank points this player has. This requires identifying the player with the highest win count and then retrieving their rank points.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the winner who has the highest rank points and participated in the Australian Open tourney. This requires filtering the data to include only those matches that are part of the Australian Open, and then sorting the results by the winner's rank points in descending order to find the highest value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the winner with the highest rank points from the Australian Open tournament. This requires filtering the matches by the tournament name, joining the matches with the players' information, sorting the results by rank points in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of the loser and the winner from the match that lasted the longest in terms of minutes. This requires identifying the match with the maximum duration and then retrieving the corresponding names of the loser and the winner.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of the winner and loser from the match that lasted the longest. This requires identifying the match with the maximum duration and then retrieving the corresponding winner and loser names.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to calculate the average ranking for each player and to include their first name in the result. This requires joining two tables (players and rankings), grouping the results by player ID, and then calculating the average ranking within each group.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the first names of all players and their average rankings. This requires joining two tables (players and rankings), grouping the results by player names, and calculating the average ranking for each group.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to calculate the total ranking points for each player and to display their first names. This requires aggregating data from two tables: one containing player information and the other containing ranking points.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking to retrieve the first names of all players and calculate the sum of their ranking points. This requires joining two tables (players and rankings), grouping the results by player first names, and aggregating the ranking points.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to determine the count of players grouped by their country of origin. This requires aggregating data based on the country code and counting the number of entries for each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of players from each country, which requires counting the players and grouping the results by country. This involves aggregating data based on a specific attribute (country) and counting the occurrences of each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the country code that has the highest number of players. This requires counting the number of players per country and then identifying the country with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the country code that has the highest number of players. This requires counting the number of players per country and then identifying the country with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify country codes that have more than 50 players. This requires counting the number of players per country and filtering the results to include only those with a count greater than 50.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is asking for the country codes of countries that have more than 50 players. This requires counting the number of players per country and filtering the results to include only those countries with a count greater than 50.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is asking to calculate the total number of tours for each distinct ranking date. This requires aggregating data by summing the tours and grouping the results by the ranking date.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the total number of tours for each unique ranking date. This requires aggregating the data by summing the tours and grouping the results by the ranking date.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the total number of matches that occurred in each year. This requires counting the number of records in the \"matches\" table and grouping the results by year.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the total number of matches played in each year, which requires counting the number of records in the \"matches\" table and grouping the results by year.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the names and ranks of the three youngest winners from all matches. This requires sorting the winners by age in ascending order and selecting the top three results.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names and ranks of the three youngest winners from all matches. This requires filtering the data to only include winners, sorting them by age in ascending order, and limiting the results to the top three.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of unique winners who participated in the WTA Championships and are left-handed. This requires filtering the data based on specific conditions and counting distinct values.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of left-handed winners who participated in the WTA Championships. This requires filtering the data to include only left-handed winners and counting the occurrences.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the first name, country code, and birth date of the winner who has the highest rank points across all matches. This requires identifying the winner with the maximum rank points and retrieving specific details about that winner.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the first name, country code, and birth date of the player who has the highest total winner rank points across all matches. This requires identifying the player with the maximum sum of winner rank points and retrieving their details.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to count the number of players grouped by their hand type. This requires aggregating the data based on the hand type and counting the occurrences of each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the count of players grouped by each hand type. This requires aggregating data based on the hand type and counting the number of players in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the count of ships that ended up being captured, which requires filtering the data based on a specific condition and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the name and tonnage of ships from a database table, sorted in descending alphabetical order by the names of the ships. This requires selecting specific columns and ordering the results.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking to retrieve specific columns (name, date, and result) from a table that contains information about battles. This requires selecting specific fields from a database table.",
        "sql_skeleton": "SELECT _, _, _ FROM _"
    },
    {
        "query_intent": "The question is looking for the highest and lowest number of deaths that occurred in each incident. This requires identifying the maximum and minimum values from a specific column in a table.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the average number of injuries that occur each time, which requires calculating the average value of the \"injured\" column from the \"death\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the death and injury situations (number of killed and injured individuals) caused by a specific ship identified by its tonnage. This requires joining two tables: one containing ship details and the other containing death and injury information, and then filtering the results based on the ship's tonnage.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names and results of battles where the Bulgarian commander is not 'Boril'. This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the unique identifiers and names of battles where any 'Brig' type ships were lost. This requires joining two tables: one containing battle information and the other containing ship information, and then filtering based on the ship type.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs and names of battles where the total number of people killed is greater than 10. This requires joining multiple tables to aggregate the number of deaths per battle and then filtering the results based on this aggregate sum.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the ship ID and name that resulted in the highest total number of injuries. This requires aggregating the injury data by ship and then identifying the ship with the maximum sum of injuries.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for a list of unique battle names where the Bulgarian commander is 'Kaloyan' and the Latin commander is 'Baldwin I'. This requires filtering the data based on conditions and selecting distinct results.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the number of unique outcomes (results) in the battles. This requires counting distinct values in the \"result\" column of the \"battle\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the count of battles where no ship with a tonnage of '225' was lost. This requires identifying battles that do not include any ships of that tonnage and then counting those battles.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the name and date of the battles in which two specific ships, 'Lettice' and 'HMS Atalanta', were lost. This requires joining two tables: one containing battle information and the other containing ship information, and filtering the results based on the ship names.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names, results, and Bulgarian commanders of battles that took place in the 'English Channel' where no ships were lost. This requires filtering battles based on a specific location and ensuring that no associated ships were lost in that location.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for specific notes from death events that contain the substring 'East'. This requires filtering the data based on a condition applied to the note field.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is asking for a list of all addresses, specifically including the first and second lines of each address. This requires selecting specific columns from a table that stores address information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the first and second lines of all addresses from a database. This requires selecting specific columns from a table that stores address information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of courses listed in the database. To achieve this, we need to count the number of records in the \"Courses\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of courses available in the database. To achieve this, we need to count the number of records in the \"Courses\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for a description of a course named \"Math\". To retrieve this information, we need to query a database table that contains course details, filtering the results to only include the course named \"Math\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the descriptions of all courses that are related to mathematics. This requires filtering the courses based on their names and then selecting the relevant descriptions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is asking to retrieve the zip code of an address located in a specific city, \"Port Chelsea\". This requires selecting data from a database table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the zip code associated with the city \"Port Chelsea\" from a database. This requires selecting specific data from a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the department that offers the highest number of degree programs. This requires counting the number of degree programs per department and then selecting the department with the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the department name and ID that offers the highest number of degree programs. This requires counting the number of degree programs per department and then identifying the department with the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the total number of unique departments that offer any degree. To achieve this, we need to count the distinct department IDs from the `Degree_Programs` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of unique departments that offer degrees. This requires counting distinct entries in the department_id column of the Degree_Programs table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of unique degree names available in the database. To achieve this, we need to count the distinct values in the `degree_summary_name` column of the `Degree_Programs` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of unique degree programs available. To achieve this, we need to count the distinct entries in the `degree_summary_name` column of the `Degree_Programs` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of degree programs offered by the Engineering department. To achieve this, we need to count the number of records in the `Degree_Programs` table that are associated with the Engineering department in the `Departments` table. This requires joining two tables and filtering the results based on the department name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of degree programs offered by the Engineering department. To achieve this, we need to count the entries in the `Degree_Programs` table that are associated with the Engineering department through a join with the `Departments` table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the names and descriptions of all sections from a database. This requires retrieving specific columns from a table that contains section information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for the names and descriptions of all sections from a database. This requires retrieving specific columns from a table that contains section information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the names and IDs of courses that have two or fewer sections. This requires joining two tables (Courses and Sections), grouping the results by course ID, and filtering groups that have a count of sections less than or equal to two.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ <= _"
    },
    {
        "query_intent": "The question is looking for the names and IDs of courses that have fewer than 2 sections. This requires joining two tables (Courses and Sections), grouping the results by course ID, and filtering groups that have a count of sections less than 2.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ < _"
    },
    {
        "query_intent": "The question is asking to retrieve the values of the `section_name` column from the `Sections` table and sort them in descending lexicographical order.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking for the names of the sections sorted in reverse alphabetical order. This requires selecting the `section_name` column from the `Sections` table and ordering the results in descending order.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking for the semester in which the most students are registered. This requires counting the number of students per semester and then identifying the semester with the highest count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name and ID of the semester that has the highest number of students registered. This requires joining two tables, grouping the results by semester, counting the number of students per semester, and then selecting the semester with the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the description of a department whose name contains the substring \"the computer\". This requires filtering the department names using a pattern matching technique and then selecting the description of the matching department.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is asking to retrieve the description of a department whose name contains the word \"computer\". This requires filtering the department names to include only those that match the specified condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for students who are enrolled in exactly 2 degree programs within one semester. The SQL query needs to join student enrollment data with degree program data, group the results by student ID, and filter groups that have exactly 2 degree programs.",
        "sql_skeleton": "SELECT _, _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ HAVING _ = _"
    },
    {
        "query_intent": "The question is looking for the first name, middle name, last name, and ID of students who have enrolled in exactly 2 degree programs within a single semester. This requires joining multiple tables to filter and aggregate the data.",
        "sql_skeleton": "SELECT _, _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ HAVING _ = _"
    },
    {
        "query_intent": "The question is looking for the first name, middle name, and last name of students who are enrolled in a Bachelor degree program. This requires joining multiple tables to match students with their enrollment details and filtering based on the degree program name.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the first, middle, and last names of all students who are enrolled in a Bachelor's program. This requires joining multiple tables to match students with their enrollment details and filtering the results based on the degree program name.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to identify the type of program that has the highest number of student enrollments. This requires counting the number of enrollments for each program and then selecting the one with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the degree summary name that has the highest number of students enrolled. This requires joining two tables, grouping by degree summary name, counting the number of students per group, and then ordering the results to find the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the degree program that has the highest number of student enrollments. This requires counting the number of enrollments per program and then selecting the program with the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the program ID and the summary of the degree that has the highest number of students enrolled. This requires joining two tables, grouping by the degree program ID, counting the number of enrollments, and then selecting the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify the student who has enrolled in the most programs. This requires counting the number of enrollments per student and then selecting the student with the highest count. The SQL query needs to join the `Student_Enrolment` and `Students` tables, group the results by student ID, count the number of enrollments, and then order the results to find the student with the most enrollments.",
        "sql_skeleton": "SELECT _, _, _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the first, middle, and last name, along with the student ID and the total number of enrollments, for the student who has enrolled the most in any program. This requires joining two tables, grouping the results by student ID, counting the enrollments, and then ordering the results to find the student with the highest count.",
        "sql_skeleton": "SELECT _, _, _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify semesters that do not have any students enrolled. This requires filtering out semesters that have enrollments and listing the names of the remaining semesters.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the name of semesters that have no students enrolled. This requires identifying semesters that are not referenced in the student enrollment records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of all courses that have had at least one student enrolled in them. This requires identifying courses with enrollments and ensuring no duplicates in the result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the names of courses that have at least one student enrolled. This requires identifying courses that appear in the student enrollment records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the course that has the highest number of enrollments. This requires counting the enrollments for each course, identifying the course with the maximum count, and retrieving its name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the course that has the highest number of students enrolled. This requires identifying the course with the maximum enrollment count and retrieving its name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the last names of students who reside in North Carolina and are not enrolled in any degree program. This requires filtering students based on their current address state and excluding those who have registered in any degree program.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the last names of students who reside in North Carolina and have not registered in any degree programs. This requires filtering students based on their address and excluding those who have enrolled in any degree programs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the date and ID of transcripts that have at least two course results. This requires counting the number of course results per transcript and filtering those with a count greater than or equal to two.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the date and ID of transcripts that have at least two courses listed. This requires joining two tables, grouping the results by transcript ID, and filtering groups based on the count of courses.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the phone number of a specific individual identified by their first and last names. To achieve this, we need to retrieve data from a database table where the first name matches \"Timmothy\" and the last name matches \"Ward\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the mobile phone number of a student named Timmothy Ward from a database. This requires retrieving specific data from a table where certain conditions are met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the first student to register, which requires identifying the earliest registration date and then retrieving the corresponding student details. The SQL query needs to sort the records by the registration date in ascending order and limit the result to the first entry.",
        "sql_skeleton": "SELECT _, _, _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the first, middle, and last name of the student who registered first. This requires sorting the students by their registration date in ascending order and selecting the top result.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the earliest graduate of the school, which requires identifying the student who registered the earliest. This involves selecting specific columns (first name, middle name, and last name) and ordering the results by the registration date in ascending order, then limiting the result to the first entry.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the first, middle, and last name of the student who graduated earliest, which requires retrieving data from a database and sorting it to find the earliest date.",
        "sql_skeleton": "SELECT _, _, _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the first names of students whose current address is different from their permanent address. This requires filtering and joining tables to match student IDs with their corresponding address IDs.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the first names of students whose permanent address is different from their current address. This requires filtering records based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking to identify the address that has the highest number of students currently residing there. This requires counting the number of students per address and then selecting the address with the maximum count.",
        "sql_skeleton": "SELECT _, _, _, _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the address details (id, line 1, and line 2) of the address that has the highest number of students. This requires joining the `Addresses` and `Students` tables, grouping by address, counting the number of students per address, and then selecting the address with the maximum count.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the average date on which the transcripts were printed. This requires calculating the average value of the `transcript_date` field from the `Transcripts` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the average value of the `transcript_date` field from the `Transcripts` table. To achieve this, we need to use an aggregate function that calculates the average of a specific column.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the earliest date when a transcript was released, along with the details of that transcript. This requires selecting the minimum date from the `transcript_date` column and retrieving the corresponding `other_details` column.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the earliest date on which a transcript was released, along with any additional details that might be available. This requires retrieving data from a database table and sorting the results to find the minimum date.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the total number of transcripts that have been released. To achieve this, we need to count the number of records in the `Transcripts` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of entries in the \"Transcripts\" table. To achieve this, we need to count the rows in the specified table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the most recent transcript release date from a database. This requires retrieving the latest date from a specific column in a table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the most recent date on which a transcript was released. This requires retrieving the latest date from the `transcript_date` column in the `Transcripts` table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the maximum number of times a course enrollment result appears across different transcripts and the corresponding course enrollment ID. This requires identifying the most frequent occurrence of a course enrollment and retrieving the associated course enrollment ID.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the course with the highest number of appearances across different transcripts and the corresponding enrollment ID. This requires counting occurrences and joining tables to match courses with their enrollment IDs.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to find the date of the transcript that has the fewest number of results and also list the ID of that transcript. This requires counting the number of results for each transcript and then selecting the one with the minimum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the date and ID of the transcript that contains the least number of results. This requires counting the number of entries in each transcript and then selecting the one with the minimum count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify the semesters in which both Master's and Bachelor's students are enrolled. This requires finding the intersection of two sets of semester IDs based on the enrollment status of each degree program.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of semesters where both Masters and Bachelors students are enrolled. This requires identifying semesters that have enrollments from both degree programs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of unique addresses where students currently reside. This requires counting distinct values in the `current_address_id` column of the `Students` table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for a list of unique addresses where students are currently living. This requires identifying distinct addresses from a table that contains student information and their corresponding addresses.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve and display all student details in a reversed lexicographical order, which means sorting the data by the student names in descending order.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC, _ DESC, _ DESC"
    },
    {
        "query_intent": "The question is asking for additional details about students, sorted in reverse alphabetical order. This requires selecting specific columns from a table and ordering the results in descending order.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking to retrieve the description of a specific section named \"h\" from a database. This requires selecting data from a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the description of a section identified by the name \"h\". This requires selecting specific data from a table based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the first names of students who either permanently reside in Haiti or have a specific cell phone number. This requires filtering the data based on conditions related to both address and phone number.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the first names of students who either live permanently in Haiti or have a specific cell phone number. This requires filtering the data based on two conditions: one related to the country and the other related to the cell phone number.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of cartoon titles sorted in alphabetical order. This requires selecting data from a table and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking for a list of cartoon titles sorted in alphabetical order. This requires selecting the title column from the Cartoon table and ordering the results by the title.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of titles of cartoons that were directed by \"Ben Jones\". This requires filtering the data based on a condition and selecting specific columns from a table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the titles of all cartoons that were directed by Ben Jones. This requires filtering the data based on the director's name.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of cartoons that were written by a specific person, \"Joseph Kuhr\". To achieve this, we need to count the entries in the \"Cartoon\" table where the \"Written_by\" column matches \"Joseph Kuhr\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of cartoons that were written by Joseph Kuhr. To achieve this, we need to count the entries in the `Cartoon` table where the `Written_by` column matches 'Joseph Kuhr'.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of cartoon titles along with their directors, sorted by the date they were originally aired. This requires selecting specific columns from a table and ordering the results based on a date column.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking for the titles and directors of all cartoons, sorted by their original air dates. This requires selecting specific columns from a table and ordering the results by a date column.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking for a list of titles of cartoons that were directed by either \"Ben Jones\" or \"Brandon Vietti\". This requires filtering the data based on specific conditions and selecting the relevant columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking for the titles of cartoons that were either directed by Ben Jones or Brandon Vietti. This requires filtering the data based on conditions applied to the `Directed_by` column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the country with the highest number of TV channels. This requires counting the number of TV channels per country and then identifying the country with the maximum count.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the country that has the highest number of TV channels and the count of those channels. This requires grouping the data by country, counting the number of TV channels in each country, and then identifying the country with the highest count.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for a count of unique series names and contents in the TV Channel table. This requires identifying distinct values and counting them.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of unique series and unique contents listed in the TV Channel table. This requires counting distinct values in two different columns.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is looking to retrieve the content of a TV channel that has a specific series name, \"Sky Radio\". This requires selecting a specific column from a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the specific content associated with the series titled \"Sky Radio\" from a database. To achieve this, we need to retrieve data from a table where the series name matches \"Sky Radio\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the \"Package Option\" from a table of TV channels where the \"series_name\" is \"Sky Radio\". This requires selecting specific data from a database table based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the package options of TV channels that have a series named \"Sky Radio\". This requires filtering the TV channels based on the series name and selecting the corresponding package options.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of TV channels that broadcast in the English language. To achieve this, we need to count the entries in the `TV_Channel` table where the `Language` column is equal to \"English\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of TV channels that broadcast in the English language. To achieve this, we need to count the entries in the \"TV_Channel\" table where the \"Language\" column is equal to \"English\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to identify the language that is used by the fewest number of TV channels. This requires counting the number of TV channels for each language and then selecting the language with the minimum count.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the language that is used by the fewest number of TV channels and the count of those channels. This requires grouping the data by language and then counting the number of channels for each language, and finally identifying the language with the minimum count.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for a list of languages used by TV channels, along with the count of TV channels for each language. This requires grouping the data by language and counting the number of entries in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for a count of TV channels grouped by each language. This requires aggregating the data by language and counting the number of entries for each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the TV channel that broadcasts a specific cartoon titled \"The Rise of the Blue Beetle!\" and wants the series name of that channel. This requires joining two tables: one containing TV channels and their series names, and the other containing cartoons and their corresponding channels.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the series name of a TV channel that broadcasts a specific cartoon titled \"The Rise of the Blue Beetle\". This requires joining two tables: one containing TV channel information and the other containing cartoon information, and then filtering the results based on the cartoon title.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the titles of cartoons that are broadcast on a TV channel with the series name \"Sky Radio\". This requires joining two tables: one containing TV channel information and the other containing cartoon information, and then filtering the results based on the series name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the titles of all cartoons that are broadcast on a TV channel with the series name \"Sky Radio\". This requires joining two tables: one containing TV channel information and the other containing cartoon information, and then filtering the results based on the series name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of episodes from TV series and sort them based on their ratings. This requires selecting specific columns and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking for a list of all episodes sorted by their ratings in ascending order. This requires selecting data from a table and ordering the results based on a specific column.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _"
    },
    {
        "query_intent": "The question is asking to retrieve the episode and rating of the top 3 TV series based on their rating. This requires selecting specific columns from a table, ordering the results by rating in descending order, and limiting the number of results to 3.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the top 3 episodes from a TV series table, along with their corresponding ratings, sorted by rating in descending order. This requires selecting specific columns, ordering the results, and limiting the number of results.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the minimum and maximum values of the \"Share\" column in the \"TV_series\" table.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the highest and lowest values of the \"Share\" column in the \"TV_series\" table. To achieve this, we need to use aggregate functions to find the maximum and minimum values.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is looking for the air date of a specific TV series episode titled \"A Love of a Lifetime\". To achieve this, we need to retrieve data from a database table where the episode matches the specified title.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the air date of a specific episode titled \"A Love of a Lifetime\" from a TV series. To achieve this, we need to retrieve data from a database table that contains information about TV series episodes.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the weekly rank of a TV series that has an episode titled \"A Love of a Lifetime\". To achieve this, we need to filter the TV series records based on the episode title and then select the corresponding weekly rank.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the weekly rank of a specific episode titled \"A Love of a Lifetime\" from a TV series. To achieve this, we need to filter the TV series episodes by the given title and select the corresponding weekly rank.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the TV channel associated with the TV series episode titled \"A Love of a Lifetime\". The query needs to join the TV series and TV channel tables based on a common identifier and filter the results to find the specific episode.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of a series that has an episode titled \"A Love of a Lifetime\". This requires joining two tables (TV_Channel and TV_series) based on a common field (id) and filtering the results to find the specific episode.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of episodes from TV series that are broadcast on a TV channel with the series name \"Sky Radio\". This requires joining two tables: one containing TV channel information and the other containing TV series information, and then filtering the results based on the series name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the episode information of a TV series named \"Sky Radio\". To achieve this, we need to retrieve data from related tables where the series name matches \"Sky Radio\". This requires joining two tables: one containing TV series information and the other containing TV channel information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of cartoons for each director. This requires grouping the data by the director's name and counting the entries in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of cartoons created by each director. This requires counting the entries in the \"Cartoon\" table and grouping the results by the \"Directed_by\" column.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the production code and channel of the most recently aired cartoon. This requires sorting the cartoons by their original air date in descending order and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the production code and channel of the most recent cartoon, which requires identifying the latest entry in the \"Original_air_date\" column and retrieving the corresponding \"Title\" and \"Channel\".",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for specific details (package choice and series name) from a TV channel that offers high-definition TV. The SQL query needs to filter records based on a condition and select specific columns from the table.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the package options and series names of TV channels that support high-definition TV. This requires filtering the data based on a specific condition and selecting specific columns.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the countries whose TV channels are broadcasting cartoons written by Todd Casey. This requires identifying the relevant TV channels and then mapping them to their respective countries. The SQL query needs to join multiple tables to achieve this.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the unique countries that have cartoons on TV written by Todd Casey. This requires joining two tables (TV_Channel and Cartoon) and filtering the results based on the writer's name.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of countries whose TV channels do not broadcast any cartoons written by Todd Casey. This requires identifying countries with TV channels that are not associated with any cartoons written by Todd Casey and excluding those that are.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of countries that do not broadcast any cartoons written by Todd Casey. This requires filtering out countries that do broadcast such cartoons.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the series name and country of TV channels that are broadcasting cartoons directed by both Ben Jones and Michael Chang. This requires identifying common channels from two separate sets of results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the series name and country of TV channels that broadcast cartoons directed by both Ben Jones and Michael Chang. This requires identifying channels that meet both conditions and finding the intersection of these sets.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the pixel aspect ratio and the country of TV channels that do not broadcast in English. This requires filtering out TV channels that have English as their language and selecting the relevant fields.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the pixel aspect ratio and country of origin for TV channels that do not broadcast in English. This requires filtering the data based on the language condition and selecting specific columns.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the IDs of TV channels that are located in countries where the number of TV channels exceeds two. This requires grouping the TV channels by country, counting the number of channels in each group, and then filtering those groups to include only those with more than two channels.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the IDs of TV channels that have more than 2 TV channels. This requires counting the number of TV channels per ID and filtering the results to include only those with a count greater than 2.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the IDs of TV channels that do not broadcast any cartoons directed by Ben Jones. This requires identifying TV channels that are not associated with any cartoons directed by Ben Jones.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of TV channels that do not broadcast any cartoons directed by Ben Jones. This requires identifying TV channels that are not associated with Ben Jones and excluding those that are.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the package options of TV channels that do not broadcast any cartoons directed by Ben Jones. This requires filtering out TV channels that have cartoons directed by Ben Jones and then selecting the package options of the remaining channels.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for the package options of TV channels that do not broadcast any cartoons directed by Ben Jones. This requires filtering out TV channels that air cartoons directed by Ben Jones and then selecting the package options of the remaining channels.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is asking for the total number of entries in the \"poker_player\" table. To achieve this, we need to count the number of rows in the table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to determine the total number of records in the \"poker_player\" table. This requires counting all rows in the specified table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve the earnings of poker players and sort them in descending order. This requires selecting the earnings column from the poker_player table and ordering the results in descending order.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking for the earnings of poker players, sorted in descending order by their earnings. This requires selecting the earnings column from the poker_player table and ordering the results in descending order.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking for a list of the final tables made and the best finishes achieved by poker players. This requires selecting specific columns from a table that contains poker player data.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for specific details (final tables made and best finishes) from a table that contains poker player data. The SQL query needs to select these columns from the appropriate table.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the average earnings of poker players, which requires calculating the mean value of the earnings column from the poker_player table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to calculate the average value of the \"Earnings\" column from the \"poker_player\" table. This requires aggregating data and computing a statistical measure.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the rank of the poker player who has the highest earnings. This requires identifying the maximum earnings and then finding the corresponding rank.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the ranking of the player who has the highest earnings. This requires identifying the maximum earnings and then finding the corresponding money rank.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to find the highest number of final tables made by poker players who have earnings less than 200,000. This requires filtering the data based on earnings and then finding the maximum value of the final tables made.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking for the highest number of final tables made by poker players whose earnings are less than 200,000. This requires filtering the data based on earnings, selecting the relevant column, and finding the maximum value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _"
    },
    {
        "query_intent": "The question is asking for the names of individuals who are involved in poker. To retrieve this information, we need to join two tables: one containing poker player details and the other containing people details, and then select the names from the joined tables.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of individuals who are involved in poker games. This requires joining two tables: one containing poker player information and the other containing people's details, and then selecting the relevant column.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the names of poker players whose earnings exceed 300,000. This requires joining two tables (`people` and `poker_player`) on a common key (`People_ID`) and filtering the results based on the earnings condition.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the names of poker players whose earnings exceed 300,000. To achieve this, we need to filter the records in the `poker_player` table based on the earnings and then join the `people` table to retrieve the names of the players.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of poker players and sort them by the number of final tables they have made in ascending order. This requires joining two tables and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is looking for the names of poker players sorted by the number of final tables they have made in ascending order. This requires joining two tables (`people` and `poker_player`) on a common key (`People_ID`), filtering for non-null values, and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is looking for the birth date of the poker player who has the lowest earnings. This requires joining two tables (`people` and `poker_player`), sorting the results by earnings in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the birth date of the poker player who has the lowest earnings. This requires joining two tables, sorting the results by earnings in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the money rank of the poker player who has the greatest height. This requires joining two tables (people and poker_player) on a common identifier (people_id), sorting the results by height in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the money rank of the poker player who has the greatest height. This requires joining two tables (`people` and `poker_player`) on a common key, sorting the results by height in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average earnings of poker players who have a height greater than 200. This requires joining two tables (`people` and `poker_player`) on a common key, filtering the results based on height, and then calculating the average earnings.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the average earnings of poker players who have a height greater than 200. This requires filtering the data based on height and then calculating the average earnings of the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the names of poker players sorted in descending order based on their earnings. This requires joining two tables (`people` and `poker_player`) on a common key and then ordering the results by the earnings in descending order.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking to retrieve the names of poker players and sort them by their earnings in descending order. This requires joining two tables (`poker_player` and `people`) on a common key and then sorting the results based on the earnings.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking for a count of people grouped by their nationality. This requires aggregating the data based on the nationality attribute and counting the occurrences of each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the count of individuals grouped by their nationality. This requires aggregating the data based on the nationality attribute.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking to identify the most frequently occurring nationality among people. This requires counting the occurrences of each nationality and then selecting the one with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to identify the most frequently occurring nationality among all people in the dataset. This requires counting the occurrences of each nationality and then selecting the one with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for nationalities that are common among at least two people. This requires identifying nationalities with a count of people greater than or equal to two.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is asking to identify the nationalities that have a minimum count of two people. This requires grouping the data by nationality and then filtering the groups to include only those with a count of two or more.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is asking to retrieve the names and birth dates of individuals from a database, sorted in ascending alphabetical order by their names. This requires selecting specific columns and ordering the results.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking for a list of names and birth dates of people, sorted in alphabetical order by their names. This requires selecting specific columns from a table and ordering the results.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking to retrieve the names of individuals whose nationality is not \"Russia\". This requires filtering the data based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the names of individuals who do not have Russian nationality. This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the names of individuals who do not participate in poker. This requires identifying people who are not associated with any poker players.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of individuals who do not participate in poker. This requires identifying people who are not present in the poker player dataset.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking for the number of unique nationalities present in a dataset. To achieve this, we need to count the distinct values in the \"Nationality\" column of the \"people\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to determine the total number of unique nationalities present in the dataset. This requires counting distinct values in the \"Nationality\" column of the \"people\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of unique states. To achieve this, we need to count the distinct entries in the \"state\" column of the relevant table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of contestant numbers and their corresponding names, sorted in descending order based on the contestant names. This requires selecting specific columns from a table and ordering the results.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking to retrieve specific columns (vote IDs, phone numbers, and states) from a table that stores votes. The SQL query needs to select these columns from the appropriate table.",
        "sql_skeleton": "SELECT _, _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the highest and lowest values of area codes from a dataset.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is looking for the most recent date when votes were created in the state of 'CA'. This requires filtering the data by the state 'CA' and then selecting the maximum date from the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of contestants who do not match the name 'Jessie Alloway'. This requires filtering out specific records from a dataset.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is asking for a list of unique states and their corresponding creation times from the votes table. This requires selecting distinct combinations of state and creation time.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _"
    },
    {
        "query_intent": "The question is looking for the contestant numbers and names of contestants who received at least two votes. This requires joining two tables (CONTESTANTS and VOTES), grouping the results by contestant number, and filtering groups that have a count of votes greater than or equal to two.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the contestant number and name of the contestant who received the least votes. This requires identifying the contestant with the minimum number of votes and retrieving their details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the total number of votes from the states 'NY' or 'CA'. To achieve this, we need to count the entries in the `votes` table where the `state` column matches either 'NY' or 'CA'.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of contestants who did not receive any votes. This requires identifying contestants who are not present in the votes table and then counting those contestants.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the area code where the highest number of voters voted. This requires counting the votes per area code and then identifying the area code with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for specific details (create dates, states, and phone numbers) of votes that were cast by a contestant named 'Tabatha Gehling'. To achieve this, we need to join two tables (`CONTESTANTS` and `VOTES`) based on a common key (`contestant_number`) and filter the results by the contestant's name.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for area codes where voters have voted for both contestants 'Tabatha Gehling' and 'Kelly Clauss'. This requires identifying common area codes from two separate sets of votes, one for each contestant.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of contestants that include the substring \"Al\" within their names. This requires filtering the data based on a pattern match.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the names of countries that gained independence after the year 1950. This requires filtering the data based on a condition and selecting specific columns from a table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the names of countries that were founded (gained independence) after the year 1950. This requires filtering the data based on a condition and selecting specific columns from a table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the number of countries that have a republic as their form of government. To achieve this, we need to count the entries in the `country` table where the `GovernmentForm` column is equal to \"Republic\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of countries that have a government form classified as a republic. To achieve this, we need to count the entries in the `country` table where the `GovernmentForm` column is equal to \"Republic\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total surface area of all countries located in the Caribbean region. To achieve this, we need to aggregate the surface area values for countries within the specified region.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total surface area of all countries located in the Caribbean region. To achieve this, you need to aggregate the surface area values of countries that belong to this region.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to determine the continent where the country Anguilla is located. To achieve this, we need to retrieve data from a database that contains country information, filtering the results to find the specific country named Anguilla.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the name of the continent to which the country Anguilla belongs. To retrieve this information, we need to query a database table that contains country information and filter the results to find the specific country named Anguilla.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the region associated with the city of Kabul. This requires joining the `city` table with the `country` table to match the city name with its corresponding country, and then filtering the results to find the specific region for Kabul.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the region associated with the city of Kabul. To achieve this, we need to join two tables: one containing city information and the other containing country information, and then filter the results to find the region of Kabul.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the most popular language spoken in Aruba. This requires identifying the language with the highest percentage of speakers in the country. The SQL query needs to filter the data for Aruba, sort the languages by their popularity in descending order, and select the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the language that is predominantly spoken in Aruba. This requires identifying the country code for Aruba, joining the relevant tables, and filtering the results to find the language with the highest percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the population and life expectancy data for Brazil from a database. To achieve this, we need to retrieve specific columns from a table where the country name matches \"Brazil\".",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the population and life expectancy of Brazil from a database. To achieve this, we need to select specific columns from a table where the country name matches \"Brazil\".",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the population and region of Angola from a database. To achieve this, we need to select specific columns from a table where the country name matches \"Angola\".",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the population and the region of Angola from a database. To achieve this, we need to retrieve specific columns from a table where a condition is met.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the average life expectancy of countries located in the region of Central Africa. To achieve this, we need to calculate the average value of the `LifeExpectancy` column for records where the `Region` column is equal to \"Central Africa\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the average life expectancy of people in Central Africa. To achieve this, we need to filter the data to include only countries located in Central Africa and then calculate the average life expectancy for those countries.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the country in Asia that has the shortest life expectancy. This requires filtering the data to only include countries in Asia, sorting the results by life expectancy in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the name of the country located in Asia that has the lowest life expectancy. This requires filtering the data to include only countries in Asia and then selecting the one with the minimum life expectancy.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the total population and the maximum Gross National Product (GNP) of countries located in Asia. This requires aggregating data by summing the population and finding the maximum GNP for countries within the specified continent.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the total population of countries in Asia and the highest Gross National Product (GNP) among those countries. This requires aggregating data by continent and selecting the maximum GNP value for Asia.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average life expectancy of countries in Africa that have a republican form of government. This requires filtering the data based on continent and government form, and then calculating the average life expectancy of the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the average life expectancy of countries in Africa that have a republican form of government. This requires filtering the data based on continent and government form, and then computing the average life expectancy.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the combined surface area of the continents Asia and Europe. This requires filtering the data based on the continent and summing up the surface area values for both continents.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking for the total surface area of all countries that are located in either Asia or Europe. This requires aggregating data from a database table where the continent is either 'Asia' or 'Europe'.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking for the total population of people living in the Gelderland district. To achieve this, we need to aggregate the population data for all cities within that district.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total population of all cities within the Gelderland district. To achieve this, we need to aggregate the population data for cities in the specified district.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average Gross National Product (GNP) and the total population of all countries that have a government form described as \"US Territory\". This requires filtering the data based on the government form and then calculating the average and sum of the GNP.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the average Gross National Product (GNP) and the total population of countries that are considered US territories. This requires filtering the data to include only those countries where the government form is 'Federal Republic' or 'Federative Republic' and then calculating the mean GNP and sum of population.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of unique languages spoken globally. To achieve this, we need to count the distinct entries in the \"Language\" column of the \"countrylanguage\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of unique languages spoken worldwide. To achieve this, we need to count the distinct entries in the \"Language\" column of the \"countrylanguage\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of different types of governments present in countries located on the continent of Africa. To achieve this, we need to count distinct government forms within the specified continent.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of unique government forms present in countries located on the continent of Africa. To achieve this, we need to count the distinct values in the `GovernmentForm` column for records where the `Continent` is \"Africa\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of languages spoken in Aruba. To achieve this, we need to count the entries in the `countrylanguage` table where the country code matches Aruba's code in the `country` table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of languages spoken in the country of Aruba. This requires joining two tables: one containing country information and the other containing language information, and then filtering the results to only include Aruba.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of official languages spoken in Afghanistan. To achieve this, we need to count the entries in the `countrylanguage` table where the country is Afghanistan and the language is marked as official.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the count of official languages spoken in Afghanistan. This requires identifying official languages and counting their occurrences.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the country that has the highest number of languages spoken within it. This requires counting the number of languages per country and then identifying the country with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the country that has the highest number of languages spoken. This requires counting the number of languages for each country and then identifying the country with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the continent with the highest number of unique languages. This requires counting languages per continent, grouping the results by continent, and then selecting the continent with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the continent that has the highest number of languages spoken. To achieve this, we need to count the number of languages spoken in each continent, group the results by continent, and then order the groups by the count of languages in descending order, selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of countries where both English and Dutch are spoken. This requires identifying countries that have both languages listed in their language data.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ INTERSECT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of countries where both English and Dutch are spoken. This requires joining two tables (`country` and `countrylanguage`) and filtering the results to include only those countries where both languages are present.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the names of countries where both English and French are spoken. This requires identifying countries that have both languages listed in their language data. The SQL query needs to join two tables (one containing country information and the other containing language information), filter for countries with both languages, and select distinct country names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of countries where both English and French are spoken. This requires identifying countries that have both languages listed in their language data. The SQL query needs to join two tables, filter based on language criteria, and use set operations to find the intersection of countries that speak both languages.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of countries where both English and French are official languages. This requires identifying countries that have both languages listed as official and ensuring that these countries are not duplicates.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of countries where both English and French are official languages. This requires filtering countries that have both languages listed as official in the `countrylanguage` table and joining the `country` table to get the country names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of unique continents where the Chinese language is spoken. This requires joining tables to match countries with their respective continents and languages, and then filtering and counting distinct continents.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the number of continents where Chinese is an official language. This requires counting distinct continents from a dataset where Chinese is listed as an official language.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the unique regions where either English or Dutch is spoken. This requires joining two tables (`country` and `countrylanguage`), filtering based on language, and selecting distinct regions.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the distinct regions where either Dutch or English is spoken. This requires joining two tables: one containing country information and another containing language information, and then filtering and selecting the relevant data.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for a list of countries where either English or Dutch is the official language. This requires filtering countries based on language and official status, and then combining the results of two conditions using the `INTERSECT` keyword.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of countries where either English or Dutch is an official language. This requires filtering the data based on language and official status, and then joining this filtered data with the country data to get the country names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the most popular language spoken on the Asian continent. This requires identifying the language with the highest percentage of speakers in Asian countries. The SQL query needs to filter data by continent, join tables to get language details, and then sort and limit the results to find the top language.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the language that is spoken in the highest number of Asian countries. This requires counting the occurrences of each language in the `countrylanguage` table, filtering for Asian countries in the `country` table, and then selecting the language with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for languages that are spoken in countries with a republican government, where each language is unique to only one country. This requires filtering the data based on government form, joining tables to get the necessary information, and using set operations to find unique languages.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ HAVING _ = _"
    },
    {
        "query_intent": "The question is looking for languages that are exclusively spoken in countries with a republic form of government. This requires filtering countries by their government form and joining tables to match countries with their languages. The result should include only distinct language names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ HAVING _ = _"
    },
    {
        "query_intent": "The question is looking for the city with the highest population where English is spoken. This requires joining two tables (city and countrylanguage), filtering by the language (English), and then sorting the results by population in descending order to find the largest one.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the city with the highest population where English is spoken. This requires joining multiple tables to filter cities that speak English and then finding the city with the maximum population.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name, population, and expected life length of the Asian country with the largest surface area. This requires filtering countries by continent, sorting them by surface area in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name, population, and life expectancy of the largest country by land area within the continent of Asia. This requires identifying the country with the highest surface area and retrieving specific details about that country.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average life expectancy of countries where English is not an official language. This requires filtering the data to exclude countries where English is official and then calculating the average life expectancy of the remaining countries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the average life expectancy of countries where English is not the official language. This requires filtering out countries where English is the official language and then calculating the mean life expectancy of the remaining countries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the total population of countries where English is not an official language. This requires filtering out countries that have English as an official language and then summing up the populations of the remaining countries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the total population of countries where English is not an official language. This requires filtering countries based on their language status and then summing up their populations.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the official languages spoken in countries where the head of state is Beatrix. This requires joining two tables: one containing country information and another containing language information, and filtering the results based on the head of state's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the official language of the country where the head of state is Beatrix. This requires joining two tables: one containing country information and the other containing language information, and filtering the results based on the head of state's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of unique official languages spoken in countries that were founded before 1930. This requires identifying countries with an independence year before 1930 and then counting the unique official languages within those countries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the total number of distinct official languages for countries that were founded before 1930. This requires filtering the countries by their independence year, joining the country and language tables, and counting distinct official languages.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of countries that have a surface area larger than the smallest country in Europe. This requires comparing values within a subquery that identifies the minimum surface area of countries in Europe.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for a list of countries whose surface area is greater than the smallest surface area of any country in Europe. This requires comparing the surface areas of countries with the minimum surface area of European countries.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for the names of African countries whose population is less than the population of the least populous country in Asia. This requires filtering countries by continent, joining tables to access population data, and using subqueries to compare populations.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ < (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for a list of African countries whose population is smaller than the smallest population of any country in Asia. This requires filtering countries by continent, comparing populations, and finding the minimum population in Asia.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ < (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for a list of Asian countries that have a population larger than the population of the largest country in Africa. This requires comparing populations between two continents and filtering based on that comparison.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ > (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for the names of Asian countries whose population is larger than the population of any country in Africa. This requires comparing populations across two continents and filtering the results based on this comparison.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ > (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking for the country codes of countries where English is not spoken. This requires identifying countries that do not have English as an official language or any language at all.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the country codes of countries where English is not spoken. This requires identifying countries that do not have English as an official language or any language at all.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the country codes of countries where languages other than English are spoken. This requires filtering out countries where English is the only language spoken.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is asking for the unique country codes of countries where people speak languages that are not English. This requires filtering out records where the language is English and selecting distinct country codes from the remaining records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the unique country codes of countries where English is not spoken and the government form is not a Republic. This requires filtering and joining two tables: one containing country information and another containing language information.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the codes of countries that do not have English as an official language and also do not have a government form of \"Republic\". This requires filtering out countries based on two conditions: one related to language and the other related to government form.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the names of cities that are located in European countries where English is not an official language. This requires filtering cities based on their country's continent and the official language status of English.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ <> _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for the names of cities located in Europe where English is not the official language. This requires filtering cities based on their continent and language status.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for a list of unique city names that are located in Asian countries where Chinese is the official language. This requires joining multiple tables to filter and retrieve the necessary data.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the distinct names of cities located in Asia where Chinese is the official language. This requires joining multiple tables to filter and retrieve the desired data.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the name, independence year, and surface area of the country that has the smallest population. This requires selecting specific columns from a table, ordering the results by population in ascending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _, _, _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the name, year of independence, and surface area of the country that has the lowest population. This requires selecting specific columns from a table, ordering the results by population in ascending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _, _, _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the population, name, and leader of the country that has the largest surface area. This requires selecting specific columns from a table, ordering the results by the surface area in descending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _, _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for specific details (name, population, and head of state) from a table of countries, but it requires sorting the countries by their area in descending order to find the one with the largest area.",
        "sql_skeleton": "SELECT _, _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the name of each country and the number of languages spoken in that country, but only for countries that speak at least 3 languages. This requires joining two tables, grouping the results by country, counting the number of languages per country, and filtering the results based on the count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names of countries that have more than two official languages and the number of languages spoken in each of those countries. This requires joining two tables, grouping the results by country name, and filtering groups based on the count of languages.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is asking to count the number of cities in each district where the population of those cities is greater than the average population of all cities. This requires filtering cities based on a condition and then grouping the results by district to count the number of cities in each district that meet the condition.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ > (SELECT _ FROM _) GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the count of cities in each district that have a population greater than the average population across all cities. This requires filtering data based on a condition and then grouping the results by district to count the number of cities that meet the condition.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ > (SELECT _ FROM _) GROUP BY _"
    },
    {
        "query_intent": "The question is asking to find the government form names and their corresponding total populations, grouped by government form, where the average life expectancy for each government form is longer than 72. This requires aggregating data, joining tables, and filtering based on a condition.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the total population of countries grouped by their government forms, but only for those government forms where the average life expectancy is greater than 72. This requires filtering, grouping, and aggregation.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is asking to calculate the average life expectancy and total population for each continent, but only for those continents where the average life expectancy is less than 72. This requires filtering the results based on a condition applied to the average life expectancy.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _ HAVING _ < _"
    },
    {
        "query_intent": "The question is asking for the total population and average life expectancy for each continent, but only for those continents where the average life expectancy is less than 72. This requires aggregating data by continent and filtering based on a condition.",
        "sql_skeleton": "SELECT _, _, _ FROM _ GROUP BY _ HAVING _ < _"
    },
    {
        "query_intent": "The question is asking for the names and surface areas of the top 5 countries by area. This requires selecting specific columns, ordering the results by surface area in descending order, and limiting the number of results to 5.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the names and surface areas of the top 5 largest countries in terms of their surface area. This requires sorting the countries by their surface area in descending order and limiting the results to the first 5 entries.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the names of the countries that have the largest population, and it requires selecting the top 3 results. This involves sorting the countries by population in descending order and limiting the results to the top 3 entries.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of the top 3 countries based on their population. This requires sorting the countries by population in descending order and limiting the results to the first 3 entries.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the names of countries that have the smallest populations, specifically the top 3 results. To achieve this, we need to sort the countries by their population in ascending order and then select the top 3 entries.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the names of the three countries that have the smallest population. This requires selecting specific columns, ordering the results by population in ascending order, and limiting the number of results to three.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the total number of countries located in the continent of Asia. To achieve this, we need to count the entries in a database table where the continent is specified as \"Asia\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of countries that are located in the continent of Asia. To achieve this, we need to filter the records in the `country` table where the `Continent` column matches \"Asia\" and then count the filtered records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of countries that are located in the continent of Europe and have a population of 80,000. To achieve this, we need to filter records based on specific conditions and select the relevant columns from a database table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the names of countries that are located in Europe and have a population of 80,000. To achieve this, we need to filter the data based on two conditions: the continent being Europe and the population being 80,000.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total population and the average area of countries in the continent of North America, but only for countries that have an area larger than 3000 square units. This requires filtering, aggregation, and joining data from two tables.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is asking to calculate the total population and average surface area of countries in North America that have a surface area greater than 3000. This requires filtering the data based on continent and surface area, and then performing aggregate calculations.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is asking for a list of city names that have a population within a specified range (between 160,000 and 900,000). To achieve this, we need to filter the records in the `city` table based on the population condition and select the city names.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of cities that have a population within a specified range (between 160,000 and 900,000). This requires filtering the data based on a condition applied to the population column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the language that is spoken in the largest number of countries. This requires counting the occurrences of each language and then selecting the one with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the language that is spoken in the highest number of countries. To achieve this, we need to count the occurrences of each language and then identify the one with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the language that is spoken by the largest percentage of people in each country. This requires identifying the maximum percentage of language speakers for each country and selecting the corresponding language.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the country codes and the languages spoken by the highest percentage of people in each country. This requires grouping the data by country and then selecting the language with the maximum percentage within each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the total number of countries where Spanish is spoken by the largest percentage of people. This requires identifying countries with the highest percentage of Spanish speakers and counting them.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is asking to count the number of countries where Spanish is the predominantly spoken language. This requires identifying countries where Spanish has the highest percentage of speakers.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the country codes where Spanish is spoken by the highest percentage of the population. This requires identifying the maximum percentage value and then retrieving the corresponding country codes.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _ ORDER BY _ DESC LIMIT _)"
    },
    {
        "query_intent": "The question is asking to retrieve the country codes for countries where Spanish is the most commonly spoken language. This requires identifying the language with the highest percentage of speakers and then selecting the corresponding country codes.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of records in the \"conductor\" table, which requires counting the rows in that table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to determine the total number of entries in the \"conductor\" table. This requires counting all rows in the specified table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of conductor names sorted by their age in ascending order. This requires selecting specific columns from a table and ordering the results based on another column.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking for a list of conductor names sorted by their age in ascending order. This requires selecting the 'Name' column from the 'conductor' table and ordering the results by the 'Age' column.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _"
    },
    {
        "query_intent": "The question is looking for the names of conductors who do not have the nationality \"USA\". This requires filtering the data based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of conductors who do not have the nationality \"USA\". This requires filtering the data based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is asking for a list of record companies associated with orchestras, sorted in descending order by the year each orchestra was founded. This requires selecting data from a database and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking to retrieve a list of record companies associated with orchestras, sorted in descending order based on the year each orchestra was founded. This requires selecting specific columns and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking for the average value of the attendance column in the show table. This requires calculating the average of a specific column in a database table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to calculate the average attendance from all records in the \"show\" table. This requires aggregating data and computing an average value.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the maximum and minimum values of the \"Share\" column from the \"performance\" table, but only for rows where the \"Type\" is not \"Live final\". This requires filtering the data and then calculating the maximum and minimum values.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the highest and lowest values of the \"SHARE\" column from the \"performance\" table, but only for rows where the \"TYPE\" column does not equal \"Live final\". This requires filtering the data and then finding the maximum and minimum values.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is asking for the number of unique nationalities among conductors. To achieve this, we need to count the distinct values in the \"Nationality\" column of the \"conductor\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to count the number of unique nationalities present in the \"conductor\" table. This requires identifying distinct values and counting them.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of conductor names sorted in descending order based on their years of work. This requires selecting specific columns from a table and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is asking for a list of conductor names, sorted in descending order based on the number of years they have worked. This requires selecting data from a table, ordering the results, and limiting the output to a single column.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking for the name of the conductor who has worked for the most years. This requires identifying the maximum value in the `Year_of_Work` column and then retrieving the corresponding `Name` from the `Conductor` table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the conductor who has the highest number of years of work experience. This requires identifying the maximum value in the \"Year_of_Work\" column and then retrieving the corresponding \"Name\" from the \"conductor\" table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for a list of conductor names and the orchestras they have conducted. This requires retrieving data from two related tables: one containing conductor information and the other containing orchestra information, and joining these tables based on a common identifier.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for the names of conductors and the names of the orchestras they have conducted. This requires retrieving data from two related tables: one containing conductor information and the other containing orchestra information. The relationship between these tables is established by a common identifier, 'Conductor_ID'.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the names of conductors who have conducted more than one orchestra. This requires identifying conductors with multiple associations and filtering those with only one association.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the names of conductors who have conducted at more than one orchestra. This requires identifying conductors with multiple associations and filtering those with only one association.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the name of the conductor who has conducted the highest number of orchestras. This requires identifying the conductor with the maximum count of associated orchestras and retrieving their name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the conductor who has conducted the highest number of orchestras. This requires identifying the conductor with the maximum count of associated orchestras and retrieving their name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of conductors who have conducted orchestras that were founded after the year 2008. This requires joining two tables: one containing conductor information and the other containing orchestra information, and then filtering the results based on the founding year of the orchestra.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the names of conductors who have conducted orchestras that were founded after the year 2008. This requires joining two tables: one containing conductor information and the other containing orchestra information, and then filtering the results based on the founding year of the orchestra.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking to display the number of orchestras associated with each record company. This requires counting the entries grouped by the record companies.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of orchestras managed by each record company. This requires counting the number of records for each record company in the \"orchestra\" table.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to display the different record formats used by orchestras, sorted by the number of occurrences of each format in ascending order. This requires counting the occurrences of each format and then ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking for a list of the major record formats of orchestras, sorted by how frequently each format appears. This requires counting occurrences of each format and then ordering the results based on these counts.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking for the record company that is associated with the highest number of orchestras. This requires counting the number of orchestras for each record company and then identifying the one with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the record company that is associated with the highest number of orchestras. This requires counting the occurrences of each record company and then identifying the one with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of orchestras that do not have any associated performances. This requires identifying orchestras that are not present in the list of orchestras with performances.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for a list of orchestras that do not have any associated performances. This requires identifying orchestras that are not present in the performance records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the record companies that are associated with orchestras founded both before 2003 and after 2003. This requires identifying the intersection of two sets of record companies based on the founding years of the orchestras.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ INTERSECT SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for record companies that are used by orchestras founded both before and after the year 2003. This requires identifying common elements from two separate sets of record companies based on the founding year of the orchestras.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ INTERSECT SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking to count the number of orchestras that have a record format of either \"CD\" or \"DVD\". This requires filtering the data based on specific conditions and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of orchestras that have either CD or DVD as their major record format. This requires filtering the records based on the specified conditions and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the founding years of orchestras that have given more than one performance. This requires identifying orchestras with multiple performances and then selecting their founding years.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the years of founding for orchestras that have had more than one performance. This requires joining the orchestra and performance tables, grouping the results by orchestra, and filtering groups that have more than one performance.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is asking for the total number of high school students. To achieve this, we need to count the entries in the table that contains information about high school students.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to count the total number of records in the \"Highschooler\" table. This requires counting all rows in the specified table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve the names and grades of all students who are in high school. This requires selecting specific columns from a table that contains high school student information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the names and grades of all high school students, which requires retrieving specific columns from a table that contains student information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve all the grades of students who are in high school. This requires selecting the `grade` column from the `Highschooler` table.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the grades of all high school students, which requires selecting the grade column from the Highschooler table. The SQL query needs to retrieve this information from the database.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the grade of a student named Kyle from a table that contains high school student information. To achieve this, we need to select the grade column from the table where the student's name matches \"Kyle\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the grade of a student named Kyle from a database. This requires selecting specific data from a table based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of students who are in the 10th grade from a database. This requires filtering the data based on the grade attribute.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the names of students who are in the 10th grade. This requires filtering the data based on the grade attribute. The SQL query needs to select specific columns and apply a condition to the data.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the ID of a high school student named Kyle from a database. This requires selecting specific data from a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the unique identifier (ID) of a person named Kyle from a database table. The SQL query needs to filter the records to find the specific person and select the ID.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of students in grades 9 and 10. To achieve this, we need to count the number of records in a table where the grade is either 9 or 10.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of students in grades 9 or 10. This requires filtering the data based on specific grade values and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking for the count of students in each grade level within a high school. This requires grouping the students by their grade and counting the number of students in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of students in each grade level within the high school. This requires counting the number of students grouped by their grade level.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to determine which grade has the highest number of students. This requires counting the number of students in each grade and then identifying the grade with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to identify the grade level that has the highest number of students in a high school. This requires counting the number of students in each grade and then selecting the grade with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve all unique grades from a table where the number of students in each grade is at least 4. This requires grouping the data by grade and filtering the groups based on the count of students.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking to identify the grades that have a minimum of 4 students enrolled in high school. This requires counting the number of students in each grade and filtering the results to include only those grades with a count of 4 or more.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is asking to display the student IDs along with the count of their friends. This requires grouping the data by student IDs and counting the number of friends for each student.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the number of friends each student has, which requires counting the entries in a table that associates students with their friends.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for a list of high school students along with the count of their friends. This requires joining two tables (Friend and Highschooler), grouping the results by student ID, and counting the number of friends for each student.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the names of high school students along with the number of friends each student has. This requires joining two tables (Highschooler and Friend) and counting the number of friends for each student.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the name of the high school student who has the highest number of friends. This requires joining two tables, grouping the results by student ID, counting the number of friends, and then ordering the results to find the student with the most friends.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the high school student who has the highest number of friends. This requires identifying the student with the maximum count of friends and retrieving their name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of high school students who have at least three friends. This requires joining two tables (Friend and Highschooler), grouping the results by student ID, and filtering groups that have a count of friends greater than or equal to three.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names of high school students who have three or more friends. This requires joining two tables (Friend and Highschooler) and then filtering the results based on the count of friends.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names of individuals who are friends with a high schooler named Kyle. This requires joining two tables: one containing friend relationships and the other containing high schooler information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of friends associated with a high school student named Kyle. This requires retrieving data from two related tables: one containing student information and another containing friendship relationships. The SQL query needs to join these tables based on a common identifier and filter the results by the student's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of friends associated with a high school student named Kyle. This requires identifying Kyle from the Highschooler table and then counting his entries in the Friend table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of friends associated with a person named Kyle. This requires identifying Kyle in the Highschooler table, joining the Friend table to find his friends, and then counting the number of these friends.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of students who do not have any friends, which means they are not present in the list of friends. This requires identifying students who are not in the Friend table.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the IDs of high school students who do not have any friends. This requires identifying students who are not present in the list of students with friends.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of high school students who do not have any friends. This requires identifying students who are not present in the list of students with friends.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of students who do not have any friends. This requires identifying students who are not present in the list of students with friends.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the IDs of high school students who have friends and are also liked by someone else. This requires identifying students who appear in both the \"Friend\" and \"Likes\" tables.",
        "sql_skeleton": "SELECT _ FROM _ INTERSECT SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the IDs of students who have friends and are also liked by others. This requires identifying students who appear in both the \"Friend\" and \"Likes\" tables.",
        "sql_skeleton": "SELECT _ FROM _ INTERSECT SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the names of students who have at least one friend and are also liked by someone else. This requires identifying students who belong to both groups and ensuring that the results are not duplicated. The `INTERSECT` operation is used to find the common results between two sets of data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ IN (SELECT _ FROM _ UNION SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of high school students who have friends and are also liked by others. This requires identifying students who appear in both the \"Friend\" and \"Likes\" tables.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of likes associated with each student ID. This requires aggregating data based on the student ID and counting the occurrences.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the count of likes associated with each student ID. This requires grouping the data by student ID and counting the occurrences.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the names of high school students who have received likes and the count of likes each student has received. This requires joining two tables, grouping the results by student ID, and counting the number of likes for each group.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the names of high school students who have received likes, along with the count of likes each student has received. This requires joining two tables, grouping the results by student ID, and counting the number of likes per student.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the name of the high school student who has received the highest number of likes. This requires joining two tables, grouping by student names, counting the number of likes per student, and then ordering the results to find the student with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the student who has received the highest number of likes. This requires identifying the student with the maximum count of likes and retrieving their name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of students who have received at least two likes. This requires joining the `Likes` table with the `Highschooler` table, grouping the results by student ID, and filtering groups that have a count of likes greater than or equal to 2.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names of students who have received 2 or more likes. This requires joining the `Likes` table with the `Highschooler` table, grouping the results by student ID, and filtering groups that have a count of likes greater than or equal to 2.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names of students who have a grade higher than 5 and have at least 2 friends. This requires filtering students based on their grade and counting their friends, then selecting those who meet both criteria.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the names of high school students who have a grade higher than 5 and have at least 2 friends. This requires filtering students based on their grade and counting their friends, then selecting those who meet both conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is asking for the total number of likes received by a student named Kyle. To achieve this, we need to count the entries in the \"Likes\" table where the student's ID matches Kyle's ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of likes received by a high school student named Kyle. This requires counting the entries in the `Likes` table where the student's ID matches the ID of Kyle in the `Highschooler` table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the average grade of students who have at least one friend. This requires identifying students with friends and then computing the average grade for those students.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the average grade of students who have at least one friend. This requires identifying students with friends and then calculating the average grade of those students.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the minimum grade of students who do not have any friends. This requires identifying students without friends and then finding the minimum grade among those students.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the minimum grade of students who do not have any friends. This requires identifying students without friends and then finding the lowest grade among them.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ NOT IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the states that have both owners and professionals residing there. This requires identifying the intersection of two sets of states: those with owners and those with professionals.",
        "sql_skeleton": "SELECT _ FROM _ INTERSECT SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the states that are common to both the owners and professionals. This requires identifying the intersection of two sets of states.",
        "sql_skeleton": "SELECT _ FROM _ INTERSECT SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the average age of dogs that have undergone any treatments. This requires filtering the dogs based on their treatment history and then calculating the average age of the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the average age of dogs that have undergone treatments. This requires identifying dogs with treatments and then computing the average age of those dogs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for a list of professionals who either live in the state of Indiana or have performed more than 2 treatments. The required output includes the professionals' ID, last name, and cell phone number. This requires filtering and joining data from two tables: one containing professional information and the other containing treatment records.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ > _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for specific information (id, last name, and cell phone) from the `Professionals` table. The criteria for selection are either professionals who live in the state of Indiana or those who have performed more than two treatments. This requires joining the `Professionals` and `Treatments` tables and applying conditional logic.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the names of dogs whose total treatment costs have not exceeded 1000. This requires filtering and joining data from two tables: one containing dog information and the other containing treatment details.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking for the names of dogs whose total treatment cost is not more than 1000. This requires filtering and joining data from multiple tables to aggregate the treatment costs and then compare the sum to a specified threshold.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ <= _"
    },
    {
        "query_intent": "The question is looking for a list of first names that are used by either professionals or owners but are not used as dog names. This requires identifying common first names and excluding those that are used as dog names.",
        "sql_skeleton": "SELECT _ FROM _ INTERSECT SELECT _ FROM _ EXCEPT SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the first names that are present in either the \"Professionals\" or \"Owners\" tables but are not present in the \"Dogs\" table. This requires identifying common first names and excluding those that are used as dog names.",
        "sql_skeleton": "SELECT _ FROM _ UNION SELECT _ FROM _ EXCEPT SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for professionals who have not performed any treatments on dogs. This requires identifying professionals who are not associated with any treatment records and then retrieving their ID, role, and email address.",
        "sql_skeleton": "SELECT _, _, _ FROM _ EXCEPT SELECT _, _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the identification, role, and email addresses of professionals who have not performed any treatments on dogs. This requires filtering out professionals who have treated dogs from the list of all professionals.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ <> ALL (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the owner who has the highest number of dogs. This requires counting the number of dogs per owner and then identifying the owner with the maximum count.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the owner who has the highest number of dogs. This requires counting the number of dogs per owner and then selecting the owner with the maximum count.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for professionals who have performed at least two treatments. The required output includes the professional's ID, role, and first name. This requires joining two tables (Professionals and Treatments), grouping the results by professional ID, and filtering groups that have a count of treatments greater than or equal to two.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the identification numbers, roles, and first names of professionals who have performed two or more treatments. This requires joining two tables (Professionals and Treatments), grouping the results by professional ID, and filtering groups that have a count of treatments greater than or equal to two.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the name of the breed that has the highest number of dogs. This requires counting the number of dogs per breed, identifying the breed with the maximum count, and retrieving its name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the most common breed of dogs, which requires counting the number of dogs per breed and then identifying the breed with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the owner who has paid for the most treatments on their dogs. This requires identifying the owner with the highest count of treatments and retrieving their owner ID and last name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the owner ID and last name of the owner who has spent the most on treatments for their dogs. This requires aggregating the cost of treatments by owner and then identifying the owner with the highest total cost.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the description of the treatment type that has the lowest total cost. This requires aggregating the costs by treatment type, identifying the minimum total cost, and then retrieving the corresponding treatment type description.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the description of the treatment type that has the lowest total cost. This requires aggregating the costs by treatment type, sorting them in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the owner who has paid the highest total amount for their dogs. This requires aggregating the payment amounts by owner and then identifying the owner with the maximum sum.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the owner ID and zip code of the owner who has spent the most money in total on treatments for their dogs. This requires aggregating the total spending by each owner and then identifying the owner with the highest total expenditure.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for professionals who have performed at least two different types of treatments. The SQL query needs to count the number of treatments per professional and filter the results to include only those with a count of at least two. The output should include the professional ID and their cell phone number.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the IDs and cell phone numbers of professionals who are involved in two or more different types of treatments. This requires joining two tables (Professionals and Treatments), grouping the results by professional ID, and filtering groups that have a count of treatments greater than or equal to two.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ >= _"
    },
    {
        "query_intent": "The question is looking for the first name and last name of professionals whose treatment costs are below the average cost of all treatments. This requires filtering based on a subquery that calculates the average cost of treatments.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ < (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the first names and last names of professionals who have conducted treatments that cost less than the average cost of all treatments. This requires joining two tables, filtering based on a condition, and calculating the average.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ < (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking to retrieve the date of each treatment and the first name of the professional who performed the treatment. This requires joining two tables: one containing treatment details and the other containing professional details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for the date of the treatment and the first name of the operating professional for each treatment. This requires retrieving data from two related tables: one containing treatment details and the other containing professional details. The SQL query needs to join these two tables based on a common key and select the required fields.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the cost of each treatment and the corresponding description of the treatment type. This requires joining two tables: one containing treatment details and the other containing treatment type descriptions, and selecting specific columns from these tables.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for the cost and description of each treatment, which requires retrieving data from two related tables: one containing treatment details and the other containing treatment type descriptions. The SQL query needs to join these tables based on a common key and select the required fields.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of owners' first names, last names, and the size of their dogs. This requires joining two tables: one containing owner information and the other containing dog information, and then selecting the relevant columns.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for the first name, last name, and the size of the dog for each owner. This requires retrieving data from two related tables: one containing owner information and the other containing dog information, and then joining these tables based on a common key (owner ID).",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve pairs of data, specifically the first names of owners and the names of their dogs. This requires joining two tables: one containing owner information and the other containing dog information, and then selecting the relevant columns.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for a list of each owner's first name along with the name of their dog. This requires retrieving data from two related tables: one containing owner information and the other containing dog information, and joining these tables based on a common identifier (owner_id).",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the names of dogs that belong to the rarest breed and the dates they received treatments. This requires identifying the breed with the fewest dogs and then retrieving the relevant information for those dogs.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names and treatment dates of dogs that belong to the rarest breed. This requires identifying the breed with the fewest dogs and then retrieving the relevant information for those dogs.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _ GROUP BY _ ORDER BY _ ASC LIMIT _)"
    },
    {
        "query_intent": "The question is looking for the names of dogs that are owned by individuals living in Virginia. This requires joining the `owners` and `dogs` tables based on the owner ID and filtering the results to only include owners from Virginia.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the first names of owners who reside in Virginia and the names of the dogs they own. This requires joining two tables (Owners and Dogs) based on a common key (owner_id) and filtering the results by the state \"VA\".",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the arrival and departure dates of dogs that have undergone a treatment. This requires filtering dogs based on the presence of associated treatment records and selecting specific columns from the dogs table.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the arrival and departure dates of dogs that have received at least one treatment. This requires identifying dogs with treatments and then retrieving their specific dates.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the last name of the owner who owns the youngest dog. This requires identifying the youngest dog and then finding the corresponding owner's last name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the last name of the owner who has the youngest dog. This requires identifying the owner with the minimum dog age and retrieving their last name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the email addresses of professionals who reside in either Hawaii or Wisconsin. This requires filtering the data based on specific state conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the email addresses of professionals who reside in either Hawaii or Wisconsin. This requires filtering the data based on the state attribute.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking for the arrival and departure dates of all dogs from the database. This requires selecting specific columns from a table that stores dog information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for a list of arrival and departure dates for all dogs in a database. This requires selecting specific columns from a table that stores dog information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of unique dogs that have undergone any treatments. To achieve this, we need to count the distinct dog IDs from the Treatments table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to count the number of unique dogs that have undergone at least one treatment. This requires identifying distinct dog IDs from the Treatments table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the number of unique professionals who have performed any treatments on dogs. This requires counting distinct professional IDs from the Treatments table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total count of unique professionals who have performed any treatments on dogs. This requires identifying distinct professionals and counting them.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for professionals who live in cities that contain the substring 'West'. The required output includes the professional's role, street, city, and state. This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _, _, _, _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is asking to retrieve specific details (role, street, city, and state) of professionals who reside in cities that have the substring 'West' in their name. This requires filtering the data based on a condition related to the city name.",
        "sql_skeleton": "SELECT _, _, _, _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the first name, last name, and email address of owners who reside in a state that has the substring 'North' in its name. This requires filtering the data based on a condition applied to the state names.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is asking to retrieve specific details (first name, last name, and email address) of owners who reside in states that have the substring 'North' in their names. This requires filtering the data based on a condition applied to the state names.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is asking for the count of dogs whose age is below the average age of all dogs. This requires calculating the average age and then counting the number of dogs with ages less than this average.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking to count the number of dogs whose age is less than the average age of all dogs. This requires calculating the average age and then counting the number of dogs that have an age below this average.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking for the cost of the most recent treatment, which requires identifying the latest record in the Treatments table and retrieving its cost. This involves using aggregate functions and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the cost of the most recently performed treatment, which requires retrieving the latest record from the \"Treatments\" table based on the date of the treatment.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of dogs that have not undergone any treatment. This requires identifying dogs without associated treatments and then counting those records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking for the count of dogs that have not received any treatment, which requires identifying dogs without associated treatment records. This involves using a `LEFT JOIN` to match dogs with their treatments and then counting the dogs that do not have a match.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the count of owners who currently do not have any dogs. This requires identifying owners who are not present in the list of dog owners and then counting those owners.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking to count the number of owners who do not currently own any dogs. This requires identifying owners who are not present in the list of dog owners and then counting those owners.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking to count the number of professionals who have not performed any treatments on dogs. This requires identifying professionals who are not associated with any treatments and then counting those professionals.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking to count the number of professionals who have not performed any treatments on dogs. This requires identifying professionals who are not associated with any treatments and then counting those professionals.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking to retrieve the names, ages, and weights of dogs that have been abandoned, based on a specific condition (abandoned status). The SQL query needs to filter the records where the abandoned status is '1'.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the names, ages, and weights of dogs that have been abandoned. This requires selecting specific columns from a table where a condition is met. The condition is that the `abandoned_yn` field is equal to '1', indicating that the dogs have been abandoned.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the calculation of the average age of all dogs from a database table. This requires selecting the average value of the age column from the Dogs table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to calculate the average age of all the dogs from the \"Dogs\" table. This requires selecting the average value of the \"age\" column from the \"Dogs\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the maximum age value from a dataset of dog ages. To achieve this, we need to use an aggregate function that finds the highest value in a specific column.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve the maximum age value from a table of dogs. This requires identifying the highest value in the age column of the Dogs table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the cost associated with each type of charge, requiring a list of both the charge type and the corresponding cost. This involves selecting specific columns from a table that contains charge information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for a list of each charge type along with its corresponding amount. This requires selecting specific columns from a table that contains charge information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is looking for the highest cost associated with a charge type. To achieve this, we need to retrieve the maximum value from the `charge_amount` column in the `Charges` table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the highest charge amount from a list of charges. This requires identifying the maximum value in a specific column of a table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve specific contact information (email, cell phone, and home phone) from a table that contains data about professionals. The SQL query needs to select these specific columns from the appropriate table.",
        "sql_skeleton": "SELECT _, _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for specific contact information (email, cell phone, and home phone) of professionals from a database. The SQL query needs to select these specific columns from the relevant table.",
        "sql_skeleton": "SELECT _, _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for all unique combinations of breed types and size types from a dataset. This requires selecting distinct pairs of breed and size codes from the relevant table.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve unique combinations of breed type and size type for dogs from a database. This requires selecting distinct pairs of breed and size codes from the Dogs table.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for a list of first names of professionals along with a description of the treatments they have performed. This requires joining two tables: one containing professional information and another containing treatment details. The result should include distinct first names and their corresponding treatment descriptions.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for the first name of each professional and a description of the treatment they have performed. This requires joining two tables: one containing treatment details and the other containing treatment type descriptions, and then selecting the relevant columns.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of singers, which requires counting the rows in the \"singer\" table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for the total number of entries in the \"singer\" table, which requires counting the rows in that table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of singer names sorted by their net worth in ascending order. This requires selecting specific columns and ordering the results based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking for a list of singer names sorted by their net worth in ascending order. This requires selecting specific columns from a table and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is asking for the birth year and citizenship details of singers from a database. To achieve this, we need to retrieve specific columns from a table that contains singer information.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking for the birth years and citizenships of individuals who are singers. This requires selecting specific columns from a table that contains information about singers.",
        "sql_skeleton": "SELECT _, _ FROM _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of singers who do not have French citizenship. This requires filtering the data based on a condition and selecting specific columns from a table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the names of singers who do not hold French citizenship. This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of singers who were born in either the year 1948 or 1949. This requires filtering the data based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the names of singers who were born in either 1948 or 1949. This requires filtering the data based on specific birth years and selecting the relevant column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the singer who has the highest net worth. This requires identifying the maximum value in the `Net_Worth_Millions` column and then retrieving the corresponding `Name` from the `singer` table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the singer who has the highest net worth. This requires identifying the maximum net worth and then finding the corresponding singer's name.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for a list of different citizenships of singers along with the count of singers for each citizenship. This requires grouping the data by citizenship and counting the number of entries in each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the count of singers grouped by their citizenship. This requires aggregating data based on the citizenship attribute and counting the number of records for each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to identify the most frequently occurring citizenship among singers. This requires counting the occurrences of each citizenship and then selecting the one with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the most frequently occurring citizenship among singers. This requires counting the occurrences of each citizenship and then identifying the one with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to display different citizenships of singers and the maximum net worth of singers belonging to each citizenship. This requires grouping the data by citizenship and then finding the maximum net worth within each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the highest net worth for each citizenship category. This requires grouping the data by citizenship and then finding the maximum net worth within each group.",
        "sql_skeleton": "SELECT _, _ FROM _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to retrieve the titles of songs and the names of the singers from two related tables: one containing song information and the other containing singer information. The tables are related by a common identifier, `Singer_ID`.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for a list of song titles along with the corresponding singer names. This requires retrieving data from two related tables: one containing singer information and the other containing song information. The relationship between these tables is established by a common identifier, 'Singer_ID'.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the unique names of singers who have songs that have sold more than 300,000 copies. This requires joining two tables (singer and song) on a common key (Singer_ID), filtering the results based on the sales condition, and selecting distinct names.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the unique names of singers whose songs have sales greater than 300,000. This requires joining two tables (singer and song) on a common key (singer_id), filtering the results based on the sales condition, and selecting distinct singer names.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the names of singers who have more than one song. This requires joining the singer and song tables, grouping the results by singer names, and filtering groups that have more than one song.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the names of singers who have more than one song. This requires identifying singers with multiple songs and retrieving their names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is asking for a list of singer names along with the total sales of their songs. This requires joining the singer and song tables, grouping the results by singer name, and summing the sales for each group.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the total sales of songs for each singer, which requires aggregating sales data by singer names. This involves joining two tables (singer and song) on a common key (Singer_ID), grouping the results by singer names, and summing the sales for each group.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the names of singers who do not have any associated songs. This requires identifying singers whose IDs are not present in the song table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the names of singers who do not have any associated songs. This requires identifying singers who are not present in the list of singers with songs.",
        "sql_skeleton": "SELECT _ FROM _ WHERE NOT _ IN (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the citizenship of singers who were born before 1945 and after 1955. This requires filtering the data based on two different conditions and then finding the intersection of the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ INTERSECT SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the common citizenships among singers who were born before 1945 and those who were born after 1955. This requires identifying the intersection of two sets of citizenships based on different birth year conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ INTERSECT SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the total number of available features, which requires counting the rows in a table that lists these features.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the name of the feature type associated with the feature named \"AirCon\". This requires retrieving data from two related tables using a join operation.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the descriptions of property types from a table where the property type descriptions are not null. This requires selecting specific columns from a table with a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of properties that are either houses or apartments and have more than 1 room. This requires filtering the data based on specific conditions and joining two tables to get the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _ AND _ > _"
    }
]