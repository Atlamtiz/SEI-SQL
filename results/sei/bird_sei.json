[
    {
        "query_intent": "The question is looking for the highest percentage of students eligible for free meals among K-12 students in Alameda County. This requires identifying the maximum value from a specific column in a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the lowest three free meal eligibility rates for students aged 5-17 in continuation schools. This requires filtering the data to include only continuation schools, calculating the free meal eligibility rate, and then selecting the lowest three rates.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is asking for the zip codes of all charter schools that are part of the Fresno County Office of Education. This requires filtering the data based on specific conditions and selecting the relevant column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the full mailing street address of the school that has the highest count of students eligible for FRPM (Free and Reduced-Price Meal) benefits for K-12 students. This requires joining two tables (`frpm` and `schools`), sorting the results by the FRPM count in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the phone numbers of schools that are directly charter-funded and have opened after January 1, 2000. This requires filtering records based on specific conditions and joining two tables to get the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of schools that have an average math score greater than 400 in the SAT test and are exclusively virtual. This requires filtering and joining datasets to match schools with their SAT scores.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of schools that have more than 500 SAT test takers and are either magnet schools or offer a magnet program. This requires filtering and joining data from two tables: one containing SAT scores and the other containing school information.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the phone number of the school that has the highest number of students who scored over 1500 on the SAT. This requires joining two tables, filtering based on the SAT score, grouping by school name, counting the number of test takers, and then ordering the results to find the school with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the number of SAT test takers from the school that has the highest FRPM (Free and Reduced Price Meal) count for K-12 students. This requires joining two tables (`frpm` and `satscores`) on a common key (`CDSCode`), filtering the results to only include schools with non-null FRPM counts, sorting the results by the FRPM count in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the count of schools that have an average Math SAT score above 560 and are directly charter-funded. This requires filtering and joining datasets based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the Free or Reduced-Price Meal (FRPM) count for the school that has the highest average score in the Reading section of the SAT test. This requires joining two tables (satscores and frpm) based on a common key (CDSCode), filtering for the highest average score, and selecting the relevant FRPM count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the codes of schools that have a total enrollment exceeding 500 students. This requires filtering and grouping data from a table that contains enrollment information for each school.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the highest rate of students aged 5-17 who are eligible for free meals among schools that have an SAT excellence rate of over 0.3. This requires filtering schools based on their SAT scores, calculating the percentage of students eligible for free meals, and then finding the maximum value of this percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the phone numbers of the top 3 schools based on their SAT excellence rate. This requires joining two tables (`satscores` and `schools`), calculating the SAT excellence rate, sorting the results in descending order, and limiting the output to the top 3 entries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the top five schools, sorted by their enrollment numbers in descending order, and specifically requires the NCES school identification number. This involves joining two tables, filtering, sorting, and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the district that has the highest average reading score among its schools. This requires filtering active districts, joining relevant tables, sorting by average reading scores in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of schools in Alameda County that have a merged status and a number of test takers less than 100. This requires filtering and joining data from two tables: one containing SAT scores and the other containing school information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is asking to rank schools based on their average writing scores, but only include those with scores greater than 499, and to display their charter numbers. This requires filtering, joining tables, and ordering results.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ > _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking for the count of schools in Fresno that are directly funded and have a number of test takers not exceeding 250. This requires filtering based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the phone number of the school that has the highest average score in Math. This requires joining two tables, sorting the results by the average Math score in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of schools in Amador County where the Low Grade is 9 and the High Grade is 12. This requires filtering records based on specific conditions and counting the matching results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of schools in Los Angeles that have a free meals count for K-12 students between 500 and 700. This requires filtering data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ > _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the name of the school in Contra Costa County that has the highest number of test takers. This requires joining two tables (satscores and schools), filtering by county, sorting by the number of test takers in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for a list of school names where the difference in enrollments between K-12 and ages 5-17 is more than 30. Additionally, it requires the full street address of these schools. This involves joining two tables (`satscores` and `schools`), calculating the difference in enrollments, and filtering the results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ - _ > _"
    },
    {
        "query_intent": "The question is looking for the names of schools where the percentage of students eligible for free meals in K-12 is greater than 10% and the number of test takers who scored 1500 or more is greater than 0. This requires filtering and joining data from two tables: one containing free meal information and the other containing test scores.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the funding type of schools in Riverside where the average math score for SAT is greater than 400. This requires joining two tables (schools and SAT scores), filtering based on conditions, and grouping the results.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the names and full communication addresses of high schools in Monterey that have more than 800 free or reduced-price meals for students aged 15-17. This requires filtering and joining data from two tables: one containing school information and the other containing meal data.",
        "sql_skeleton": "SELECT _, _, _, _, _, _, _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the average writing score of schools that were opened after 1991 or closed before 2000. It also requires listing the school names along with their scores and the communication numbers of these schools. This involves filtering based on the opening and closing dates, joining tables to get the necessary data, and calculating the average score.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ > _ OR _ < _"
    },
    {
        "query_intent": "The question is looking for the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, and then it needs to list the names and DOC type of schools that have a difference above this average. This involves calculating an average and then filtering based on that average.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _, _ HAVING _ > (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the opening date of the first-through-twelfth-grade school that has the largest enrollment. This requires identifying the school with the maximum enrollment and then retrieving its opening date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the top 5 cities that have the lowest enrollment numbers for students in grades 1 through 12. This requires sorting the cities by their enrollment numbers in ascending order and limiting the results to the top 5 entries.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the eligible free rate of the 10th and 11th schools with the highest enrollment for students in grades 1 through 12. This requires filtering, joining tables, sorting, and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 that have the highest free or reduced price meal count, specifically for schools with an ownership code of 66. This requires filtering, sorting, and limiting the results.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the websites and names of schools that have a free meal count for students aged 5-17 within the range of 1,900 to 2,000. This requires joining two tables: one containing school information and the other containing free meal counts, and then filtering the results based on the specified range.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the percentage of students aged 5-17 who are eligible for free meals at a school managed by Kacey Gibson. This requires filtering the data by the school's administrator and calculating the relevant percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the email address of the administrator of the chartered school that has the fewest students enrolled in grades 1 through 12. This requires identifying the school with the lowest enrollment and then retrieving the corresponding administrator's email address.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the full names of the administrators (first and last names) of the school that has the highest number of students scoring 1500 or more on the SAT. This requires identifying the school with the highest count of such students and then retrieving the relevant administrative information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the complete address (Street, City, Zip, and State) of the school that has the lowest excellence rate, which is calculated as the percentage of students who scored 1500 or more in a specific test. This requires joining two tables, calculating the excellence rate, and then sorting the results to find the school with the lowest rate.",
        "sql_skeleton": "SELECT _, _, _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the website URLs of schools located in Los Angeles County that have test takers in the range of 2,000 to 3,000. This requires filtering and joining data from two tables: one containing school information and the other containing test taker data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the average number of test takers from schools located in Fresno that opened between January 1, 1980, and December 31, 1980. This requires filtering schools by their opening date and location, and then calculating the average number of test takers for those schools.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ >= _ AND _ <= _"
    },
    {
        "query_intent": "The question is looking for the telephone number of the school that has the lowest average reading score within the Fresno Unified district. This requires filtering the data by district name, joining two tables to get the necessary information, and sorting the results to find the minimum average reading score.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of virtual schools that have the highest average reading scores within each county. This requires identifying the top-performing virtual schools and ensuring that each county has only one such school listed.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the type of education offered by the school that has the highest average Math score. This requires joining two tables (one containing SAT scores and the other containing school information), filtering for non-null values, sorting by the average Math score in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average math score of the school that has the lowest average score across all subjects and the county in which it is located. This requires identifying the school with the minimum average math score and then retrieving the average math score and the corresponding county.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average writing score of the school with the highest number of test takers whose total SAT scores are greater than or equal to 1500, along with the city where this school is located. This requires identifying the school with the maximum number of test takers and then calculating the average writing score for that school.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average writing scores of schools managed by an individual named Ricci Ulrich. This requires joining two tables (one containing SAT scores and the other containing school information), filtering the results to include only those managed by Ricci Ulrich, and then calculating the average writing score for each school.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the state special school (SOCType = 'S') that has the highest number of enrollees from grades 1 through 12. This requires identifying the school with the maximum enrollment and filtering by the specific type of school.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the monthly average number of schools that opened in Alameda County under the jurisdiction of the Elementary School District in the year 1980. This requires filtering and grouping data from a database table to calculate the average number of schools that meet these criteria.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the ratio of the number of merged Unified School District (USD) schools to the number of merged Elementary School District (ESD) schools in Orange County. This requires filtering the data by county and district type, counting the occurrences, and then calculating the ratio.",
        "sql_skeleton": "SELECT _ AS per FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the county with the highest number of closed schools, along with the name and closure date of each school in that county. This requires grouping the data by county, counting the number of closed schools in each county, and then selecting the county with the maximum count.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the postal street address and the name of the school that has the 7th highest average Math score. This requires joining two tables (`schools` and `satscores`), sorting the results by the average Math score in descending order, and selecting the 7th result.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _ OFFSET _"
    },
    {
        "query_intent": "The question is looking for the mailing street address and the name of the school that has the lowest average reading score. This requires joining two tables (`schools` and `satscores`), filtering, sorting, and limiting the results to the top entry.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of schools where the total SAT scores (reading, math, and writing) are greater than or equal to 1500 and the mailing city is Lakeport. This requires joining two tables (`satscores` and `schools`), filtering based on conditions, and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ >= _"
    },
    {
        "query_intent": "The question is asking for the total number of test takers at schools located in the city of Fresno. This requires aggregating data from two tables: one containing SAT scores and the other containing mailing addresses of schools. The SQL query needs to join these tables on a common key and then sum the test takers for schools in Fresno.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of schools and their corresponding mailing zip codes that are administered by a person named Avetik Atoian. This requires filtering the data based on the administrators' first and last names.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the ratio of the number of schools in Colusa County to the number of schools in Humboldt County, specifically for schools with mailing addresses in California. This requires filtering and counting data from two different conditions within a single SQL query.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of active schools in the city of San Joaquin, California, that have a mailing address in California. This requires filtering the data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the phone number and extension number of the school that has the 333rd highest average writing score. This requires joining two tables, sorting the results by the average writing score in descending order, and selecting the relevant columns.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _ OFFSET _"
    },
    {
        "query_intent": "The question is looking for the phone number, extension number, and name of the school that corresponds to a specific zip code. This requires filtering the data based on the zip code and selecting the relevant columns.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the website URLs of schools that are administered by either Mike Larson or Dante Alvarez. This requires filtering the data based on the administrators' first and last names and selecting the relevant website fields.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the websites of schools that are partially virtual, chartered, and located in San Joaquin. This requires filtering the data based on specific conditions and selecting the relevant columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of chartered schools in the city of Hickman that are owned by the Elementary School District. This requires filtering the data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of non-chartered schools in Los Angeles County where the percentage of students eligible for free meals for grades 1 through 12 is less than 0.18%. This requires filtering and joining data from two tables: one containing free meal counts and another containing school information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the names of all administrators and the school city for chartered schools with a specific charter number. This requires filtering the data based on the charter number and selecting specific columns.",
        "sql_skeleton": "SELECT _, _, _, _, _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of schools that have a mailing city of \"Hickman\" and are part of the charter number \"00D4\". The SQL query needs to count the number of records that meet these criteria.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage ratio of Santa Clara County schools that are locally funded compared to all other types of charter school funding. This requires filtering the data by county, counting the locally funded schools, and calculating the percentage of locally funded schools out of the total charter schools in Santa Clara County.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of directly funded schools that opened in the county of Stanislaus between the years 2000 and 2005. This requires filtering records based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of Community College District closures in the city of San Francisco for the year 1989. This requires filtering the data by specific conditions and counting the relevant entries.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the county that reported the highest number of school closures in the 1980s, specifically within Youth Authority Facilities (CEA) schools. This requires identifying and counting closures, filtering by the specified time frame and ownership code, and then sorting and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ LIKE _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the National Center for Educational Statistics (NCES) school district identification number for all schools that have a specific School Ownership Code and are part of the State Special Schools. This requires filtering and joining tables to retrieve the desired information.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of active and closed District Community Day Schools in the county of Alpine. This requires filtering the data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the district code of schools that do not offer a magnet program and are located in the city of Fresno. This requires filtering out schools that offer a magnet program and then selecting the district codes of the remaining schools.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of students aged 5 to 17 enrolled at a specific school (State Special School) in a particular city (Fremont) for the 2014-2015 academic year. To achieve this, you need to filter the data based on the school name, city, and academic year, and then sum the enrollment numbers for students aged 5 to 17.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of students aged 5 to 17 who are eligible for free or reduced-price meals in a specific Youth Authority School located at a mailing street address of \"PO Box 1040\". This requires joining two tables (`frpm` and `schools`) on a common key (`CDSCode`), filtering by specific conditions, and summing up the relevant count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the lowest grade offered by a specific type of school (District Special Education Consortia) within a particular National Center for Educational Statistics (NCES) district identification number (0613360). This requires filtering the data based on specific conditions and selecting the minimum value from the relevant column.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the educational level name and the name of the school for schools that have a Breakfast Provision of 2 in county code 37. This requires joining two tables: one containing school information and the other containing FRPM (Free and Reduced Meal Program) information, and filtering the results based on specific conditions.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the city location of high school-level schools in Merced County that have Lunch Provision 2, a specific grade range (9-12), and a specific district type. The SQL query needs to filter and join tables to retrieve this information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for schools in Los Angeles County that serve a grade span from Kindergarten to 9th grade, and it requires the percentage of students eligible for free meals (FRPM) aged 5-17. This involves filtering data based on specific conditions and joining two tables to retrieve the necessary information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the most frequently served grade span in the city of Adelanto. This requires counting occurrences of grade spans for schools in Adelanto and then identifying the one with the highest count.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the county between San Diego and Santa Barbara that has the highest number of schools without a physical building. This requires identifying counties within the specified range, filtering out those with a physical building, and then counting the number of schools in each county to find the maximum.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ BETWEEN _ AND _ AND _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the type of school, the name, and the latitude coordinates of the school that has the highest latitude. This requires selecting specific columns from a table, ordering the results by latitude in descending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the city, school name, and lowest grade of the school in California that has the lowest latitude coordinates. This requires filtering by state, sorting by latitude in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the grade span offered by the school that has the highest longitude. This requires selecting the grade span from a table of schools and ordering the results by longitude in descending order, then limiting the result to the top entry.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the number of schools that offer a magnet program serving Kindergarten to 8th grade and have multiple provision types. Additionally, it requires listing the cities that offer this grade span and indicating how many schools are serving such a grade span for each city. This involves filtering, joining tables, and grouping results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ GROUP BY _ HAVING _ > _ UNION ALL SELECT _, _ FROM _ WHERE _ = _ AND _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the two most common first names among school administrators and the districts they administer. This requires counting the occurrences of each first name and then selecting the top two counts along with the corresponding districts.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the percentage of students eligible for free meals (K-12) in schools administered by an administrator with the first name \"Alusine\". It requires joining two tables: one containing free meal counts and the other containing school administration details. The SQL query needs to filter the results based on the administrator's first name and calculate the percentage of eligible students.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the administrator's last name and additional details (district, county, and school name) for a school that is identified by a specific Charter number. This requires retrieving data from a database by joining two tables and filtering the results based on a condition.",
        "sql_skeleton": "SELECT _, _, _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the email addresses of administrators of public intermediate/middle schools and unified schools located in San Bernardino County, specifically within the San Bernardino City Unified district, that opened between January 1, 2009, and December 31, 2010. The SQL query needs to filter records based on these conditions and select the relevant email addresses.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ BETWEEN _ AND _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the email address and name of the administrator of the school that has the highest number of students who received SAT scores of at least 1500. This requires joining two tables, filtering, sorting, and limiting the results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of accounts that have chosen issuance after a transaction and are located in the East Bohemia region. This requires filtering accounts based on their issuance preference and location, and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of accounts that are located in the Prague region and are eligible for loans. This requires filtering accounts based on their district and joining relevant tables to determine eligibility.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to compare the average unemployment ratios for the years 1995 and 1996, and to determine which year has a higher percentage. This requires calculating the average values for both years and then comparing them.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the number of districts where the average salary of females is between 6000 and 10000. This requires filtering data based on gender, calculating the average salary, and counting the districts that meet the specified conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking to count the number of male customers who reside in North Bohemia and have an average salary greater than 8000. This requires filtering data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the account numbers of the oldest female clients who have the lowest average salary, and it also requires calculating the gap between this lowest average salary and the highest average salary. This involves joining tables, filtering, sorting, and calculating differences.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of account numbers for the youngest clients who have the highest average salary. This requires joining tables to access client and district information, filtering for the youngest clients, calculating the average salary, and then selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of customers who have chosen a weekly statement issuance frequency and are classified as \"Owner\". This requires filtering and joining tables based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the client IDs of clients who have chosen the statement of issuance after transactions to be \"Disponent\". This requires filtering clients based on their preference for statement issuance type.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for accounts that had an approved loan in the year 1997, have the lowest approved amount, and issue a weekly statement. This requires filtering accounts by date and frequency, joining tables to get loan details, and sorting results to find the account with the minimum loan amount.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for accounts that have a loan validity greater than 12 months, the highest approved amount, and were opened in 1993. This requires filtering, joining tables, sorting, and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of female customers who were born before 1950 and reside in the district of Sokolov. This requires filtering based on gender, birth year, and district, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the account IDs of the accounts that had the earliest trading date in the year 1995. This requires filtering the data for the year 1995, sorting the results by date, and selecting the first entry.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for unique account IDs of accounts that were opened before 1997 and have a balance greater than 3000 USD. This requires filtering and joining tables based on specific conditions.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the client ID of the client who had their card issued on a specific date (1994-03-03). This requires joining two tables (`disp` and `card`) based on a common key (`disp_id`) and filtering the results by the issue date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the date when an account was opened, given a specific transaction that occurred on a specific date and amount. To achieve this, we need to join the `account` and `trans` tables based on the `account_id` and filter the results by the transaction date and amount.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the district ID of the branch where an account was opened for a loan that was approved on a specific date. This requires joining two tables: one containing loan information and the other containing account information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the largest transaction amount made by a client whose card was opened on a specific date (1996/10/21). This requires joining multiple tables to link clients, accounts, and transactions, and then filtering and sorting the results to find the maximum transaction amount.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the gender of the oldest client who has an account in the branch with the highest average salary. This requires identifying the highest average salary branch, finding the oldest client in that branch, and then retrieving their gender.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _) ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the first transaction amount of the client who applied for the largest loan. This requires identifying the client with the maximum loan amount and then finding their first transaction.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of female clients who opened their accounts in the Jesenik branch. This requires filtering the data based on gender and branch location, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the unique identifier of the disposition associated with a client who made a specific transaction amount on a specific date. This requires joining multiple tables to link transactions to clients and their dispositions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of accounts that were opened in the district of Litomerice during the year 1996. This requires joining two tables (district and account) based on a common key (district_id), filtering the results by the district name and the year, and then counting the number of matching records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the district ID of the district where a specific female client, born on January 29, 1976, opened her account. This requires joining the `client` and `account` tables based on a common identifier and filtering the results by the client's birth date and gender.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the birthday of the client who applied for a loan of 98832 USD on January 3, 1996. This requires joining multiple tables to match the loan application date with the client's birthday.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the account ID of the first client who opened their account in Prague. This requires filtering accounts by the 'Prague' district, sorting the accounts by the date they were opened, and selecting the first one.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the percentage of male clients in the branch located in the south Bohemia region with the largest number of inhabitants. This requires filtering clients by their district, counting the number of male clients, and calculating the percentage of male clients within that district.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the percentage increase in account balance for a specific client over a given period. This involves calculating the difference in balance and dividing it by the initial balance, then converting this result into a percentage. The SQL query needs to filter the data based on the loan approval date and the specified dates for the balance calculation.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of loan amounts that have been fully paid without any issues. This requires filtering the loans that are fully paid and then calculating the percentage of the total loan amount.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of accounts with loan amounts less than USD 100,000 that are still running with no issues. This requires filtering accounts based on the loan amount, counting the number of accounts that are still running, and calculating the percentage relative to the total number of accounts with loan amounts less than USD 100,000.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking for a list of account IDs, district names, and district regions for accounts that had transactions in 1993 and their statements were issued after those transactions. This requires joining multiple tables to filter and retrieve the necessary data.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the account IDs and the frequency of statement issuance for account holders from 'east Bohemia' between the years 1995 and 2000. This requires filtering data based on a specific district and date range, and joining tables to retrieve the necessary information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the account ID and the account opening date for accounts that are located in the district of 'Prachatice'. This requires joining two tables (`account` and `district`) based on a common key (`district_id`) and filtering the results to include only those where the district name matches 'Prachatice'.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the district and region information for a specific loan identified by the loan ID '4990'. This requires joining multiple tables to get the necessary data.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve specific information (account ID, district, and region) for accounts that have a loan amount greater than USD 300,000. This requires joining multiple tables to access the necessary data and filtering based on the loan amount.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking to list the loan ID, district, and average salary for loans that have a duration of 60 months. This requires joining multiple tables to retrieve the necessary information and calculating the average salary.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the districts of clients who have loans that are still running and are in debt, along with the percentage increase in the unemployment rate from 1995 to 1996. This requires joining multiple tables to filter the data and calculate the percentage change.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of accounts that are located in the 'Decin' district and were opened in the year 1993. This requires filtering accounts by year, joining with the district table to get the district name, and then calculating the percentage of these accounts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of account IDs where statements are issued monthly. This requires filtering accounts based on their frequency of statement issuance.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to list the top nine districts, in descending order, based on the number of female account holders. This requires counting the number of female clients in each district and then sorting the results in descending order.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the top ten non-credit card withdrawals by district names for the month of January 1996. This requires filtering transactions by type, joining relevant tables, grouping by district, and ordering the results to get the top ten.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the number of account holders in South Bohemia who do not own credit cards. This requires counting the clients in a specific district who are not linked to any credit cards.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the district with the highest number of active loans. This requires joining multiple tables to filter and count the loans, and then sorting the results to find the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average loan amount borrowed by male clients. To achieve this, we need to join multiple tables to link clients with their loans and then filter the results to include only male clients.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the districts with the highest unemployment rate in 1996, along with their branch location and district name. This requires filtering data for the year 1996, calculating the unemployment rate, and then identifying the district with the highest rate.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the number of accounts opened in the branch where the highest number of crimes were committed in 1996. This requires identifying the branch with the most crimes, counting the accounts in that branch, and ensuring that the crime data is from the year 1996.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of accounts that have a monthly issuance frequency and a negative balance after a credit card withdrawal. This requires filtering accounts based on their issuance frequency and balance, and then counting the number of matching records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of loans, in the specified date range, that have an amount of at least 250,000 and are approved, specifically for accounts that have chosen monthly statement issuance. This requires filtering and joining tables based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ >= _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of accounts that have running contracts specifically in Branch location 1. This requires filtering accounts based on their district location and checking the status of their contracts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of male clients in the branch where the second-highest number of crimes were committed in 1995. This requires joining multiple tables to filter and count the relevant data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of high-level credit cards that have a specific type of disposition, which is \"OWNER\". This requires filtering the data based on the type and then counting the relevant records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the number of accounts located in the district of \"Pisek\". This requires counting records in a table where the district name matches \"Pisek\".",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for districts that have had transactions exceeding $10,000 in the year 1997. This requires identifying districts with transactions above the specified amount within a specific date range and ensuring that transactions from the same district are not counted multiple times.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for account IDs of clients who have placed orders for household payments (indicated by 'HH') in the district of Pisek. This requires joining multiple tables to filter and retrieve the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the account IDs of clients who possess gold credit cards. This requires joining two tables: one containing account information and the other containing card information, and then filtering the results to include only those with gold credit cards.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average amount of credit card transactions made by account holders in a month for the year 2021. This requires filtering transactions by the year 2021, summing the amounts, and then calculating the average.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for account holder identification numbers (client IDs) whose transactions in 1998 have amounts less than the average transaction amount for that year. This requires filtering transactions by date, calculating the average transaction amount, and comparing individual transaction amounts to this average.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < (SELECT _ FROM _ WHERE _ = _ AND _ = _)"
    },
    {
        "query_intent": "The question is looking for the unique IDs of female account holders who possess credit cards and also have loans. This requires identifying clients who meet both conditions and ensuring that the results are distinct.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of female clients who have accounts in the region of South Bohemia. This requires filtering clients by gender and district, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of account IDs from districts in Tabor that are eligible for loans. This requires joining the account and district tables, filtering by district name, and ensuring the account frequency is'monthly'.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for account types that are not eligible for loans, and the average income of residents in the district where the account is located falls within a specific range ($8000 to $9000). This requires filtering account types, joining tables to access district income data, and applying conditions on average income.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking to count the number of accounts in the North Bohemia district that have made transactions with a partner's bank identified as 'AB'. This requires filtering accounts based on district and transaction type, and joining relevant tables to get the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of districts where accounts have made withdrawal transactions. This requires joining multiple tables to filter and retrieve the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average number of crimes committed in 1995 in specific regions that have a crime rate exceeding 4000 and have accounts opened starting from the year 1997. This requires filtering and joining multiple tables to get the necessary data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _ AND _ >= _"
    },
    {
        "query_intent": "The question is looking to count the number of 'classic' cards that are eligible for a loan. This requires filtering the cards by type and ensuring they have a corresponding loan.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of male clients who are registered in the 'Hl.m. Praha' district. This requires filtering the data based on gender and district name, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of 'Gold' cards that were issued before the year 1998. This requires filtering the data based on the issue date, counting the number of 'Gold' cards, and calculating the percentage relative to the total number of cards issued before 1998.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the client ID of the account owner who has the highest loan amount. This requires joining multiple tables to link clients with their accounts and loans, sorting the results by loan amount in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the count of committed crimes in the year 1995 within the district associated with a specific account (account_id = 532). This requires joining two tables: one containing account information and the other containing crime data, and then filtering based on the account ID and year.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the district ID of the account that is associated with a specific order identified by the order ID '33333'. This requires joining two tables: one containing account information and the other containing order information, and then filtering the results based on the order ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of withdrawal transactions made in cash by a specific client identified by their ID. This requires filtering transactions based on the client's ID and the operation type, and then selecting the withdrawal transactions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of accounts that are issued weekly and have a loan amount of under 200,000. This requires filtering accounts based on their issuance frequency and loan amount, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking to identify the type of credit card associated with a specific client identified by their client ID. This requires joining multiple tables to link clients with their cards and filtering the results based on the client's ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to determine the region (A2 field) associated with a specific client (client_id = 3541) by joining the client and district tables.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the district with the highest number of accounts that have loan contracts completed without any issues. This requires identifying districts, counting the number of accounts per district, filtering accounts with successful loan completion, and then grouping and ordering the results to find the district with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify the client who placed a specific order by its order ID. This requires joining multiple tables to link clients with their orders and filtering based on the order ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of transactions associated with accounts that belong to district 5. This requires joining the `account` and `trans` tables based on the `account_id` and filtering the results where the `district_id` is 5.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of accounts that are associated with the Jesenik district. This requires joining the account and district tables based on a common key and filtering the results to include only those from the Jesenik district.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of clients who have junior credit cards that were issued after the year 1996. This requires filtering based on card type and issue date, and joining tables to match clients with their cards.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of female clients who opened their accounts in districts where the average salary is over 10000. This requires filtering clients based on their district's average salary and then calculating the percentage of women among those clients.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the growth rate of the total amount of loans for male clients between the years 1996 and 1997. This requires calculating the difference in loan amounts between the two years and then computing the growth rate. The SQL query needs to filter the data by gender, join relevant tables, group by gender, and perform conditional aggregation.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of credit card transactions (withdrawals) that occurred after the year 1995. This requires filtering transactions by date and type, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the difference in the number of crimes committed between two specific districts (East and North Bohemia) in the year 1996. This requires counting the number of crimes in each district and then calculating the difference between these counts.",
        "sql_skeleton": "SELECT _ AS diff FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking to count the number of dispositions (owner and disponent) for account numbers ranging from 1 to 10. This requires filtering accounts within the specified range and counting the dispositions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _ AND _ IN ( _, _)"
    },
    {
        "query_intent": "The question is looking to retrieve the frequency with which account number 3 requests an account statement to be released and the total amount debited. This requires joining tables to link account IDs with their corresponding request frequencies and debit transactions.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to find the birth year of the account owner identified by the account ID 130. This requires retrieving data from two related tables: `client` and `disp`, and filtering the results based on the account ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of accounts that have an owner disposition and request for a statement to be generated upon a transaction. This requires filtering records based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total debt amount and payment status of a specific client identified by their client ID (992). This requires retrieving data from multiple related tables using joins and filtering the results based on the client's ID.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the balance in the account of a specific client (client number 4) after a particular transaction (transaction 851) and also wants to determine the gender of the account owner. This requires joining multiple tables to access the necessary information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to identify the type of credit card possessed by a specific client (client number 9). This requires joining two tables: one containing client information and another containing card information, and then filtering the results based on the client's ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total amount paid by a specific client (client number 617) in all transactions that occurred in the year 1998. This requires aggregating transaction amounts for the specified client and date range.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of client IDs who were born between 1983 and 1987 and whose account branch is located in East Bohemia. This requires filtering data based on specific conditions and joining tables to match client information with district information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of the top 3 female clients who have the largest loans. This requires joining two tables (client and loan), filtering by gender, sorting by loan amount in descending order, and limiting the results to the top 3.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of male customers born between 1974 and 1976 who have made payments exceeding $4000. This requires filtering data based on gender, birth year, and payment amount, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of accounts that were opened in the district of Beroun after the year 1996. This requires filtering accounts based on their district and date, and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of female customers who possess a junior credit card. This requires joining multiple tables to filter and count the relevant records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of female customers who have accounts at the Prague branch. This requires filtering the data to include only those customers from the Prague district, counting the total number of customers, and then calculating the proportion of female customers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of male clients who request weekly statements. This requires filtering clients by gender and frequency, counting the total number of clients, and calculating the percentage of male clients.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of clients who have chosen a weekly statement issuance and are classified as 'Owner'. This requires filtering and joining tables based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for accounts that have loan validity exceeding 24 months, have the lowest approved amount, and were opened before 1997. This requires filtering, joining tables, sorting, and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ < _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the account numbers of the oldest female clients who have the lowest average salary. This requires filtering clients by gender and age, joining tables to access salary information, and sorting results to find the minimum average salary.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of clients who were born in the year 1920 and reside in the east Bohemia region. This requires filtering clients by birth year and district, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking to count the number of loan accounts that have a pre-payment duration of 24 months and a weekly statement issuance frequency. This requires filtering and joining data from two tables: `account` and `loan`.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the average amount of loans that are still active (not fully paid) and have statements issued after each transaction. This requires filtering the loans based on their status and the account's statement issuance frequency.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique client IDs and their corresponding district IDs for clients who have the right to issue permanent orders or apply for loans. This requires identifying clients with specific permissions and joining relevant tables to retrieve the necessary information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs and ages of clients who have a high-level credit card and are eligible for loans. This requires filtering clients based on their gender, age, and credit card type, and joining tables to get the necessary information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is asking for the most frequently occurring bond type in a dataset. This requires counting the occurrences of each bond type and then identifying the one with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of non-carcinogenic molecules that contain at least one chlorine atom. This requires filtering molecules based on their label, joining tables to access atom information, and counting distinct molecule IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is asking to calculate the average count of oxygen atoms in molecules that are single-bonded. This requires counting the oxygen atoms in molecules with single bonds and then dividing that count by the total number of such molecules. The SQL query needs to filter molecules based on bond type, join tables to access atom data, and use conditional aggregation to count oxygen atoms.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the average number of single bonds in carcinogenic molecules. This requires counting the number of single bonds and dividing it by the count of carcinogenic molecules.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of sodium atoms in molecules that are labeled as non-carcinogenic. This requires filtering molecules based on their label, joining the molecule and atom tables, and counting the sodium atoms.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of molecules that have triple bonds and are labeled as carcinogenic. This requires filtering and joining data from two tables: one containing bond information and the other containing molecule labels.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of carbon atoms in molecules that have at least one double bond. This requires counting the total number of carbon atoms and the number of carbon atoms involved in double bonds, then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of bonds that are of a specific type, which is a triple bond. To achieve this, we need to filter the bonds by their type and then count the number of matching records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of atoms that do not contain the element bromine. This requires counting the rows in a table where the `element` column is not equal to \"Br\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking to count the number of carcinogenic molecules among the first 100 molecules in number order. This requires filtering the molecules based on their carcinogenic label and limiting the result to the first 100 entries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ <= _"
    },
    {
        "query_intent": "The question is looking to identify the unique IDs of molecules that contain at least one carbon atom. This requires joining two tables (molecule and atom) and filtering based on the element being carbon.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the unique elements that are part of atoms involved in a specific bond (TR004_8_9). This requires identifying the atoms connected by that bond and then extracting their elements.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the elements that are part of double bonds. This requires identifying atoms involved in double bonds and then retrieving their elements. The SQL query needs to join tables that contain information about bonds and atoms, filter for double bonds, and select the relevant elements.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the most common label among molecules that contain hydrogen atoms. This requires identifying molecules with hydrogen atoms, grouping them by label, and then counting the occurrences of each label to find the most frequent one.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the type of bonds that include chlorine atoms. To achieve this, we need to join tables that contain information about atoms, their bonds, and the type of those bonds.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of atoms that are connected by single bonds. This requires identifying atoms that are involved in single bonds and then finding their connections. The SQL query needs to join tables that contain bond information and atom connections, and filter based on the bond type.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify unique atoms that are part of molecules labeled as non-carcinogenic. This requires joining tables to filter molecules based on their label and then selecting distinct atom IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the least frequent element in molecules that are labeled as non-carcinogenic. This requires identifying non-carcinogenic molecules, counting the occurrences of each element in these molecules, and then selecting the element with the minimum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the type of bond that exists between two specific atoms, identified by their IDs 'TR004_8' and 'TR004_20'. To achieve this, we need to join two tables: one containing bond information and another containing connections between atoms.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the types of labels that exist in molecules that do not contain tin atoms. This requires filtering out molecules that have tin atoms and then identifying the labels of the remaining molecules.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of atoms of iodine (I) and sulfur (S) that are part of molecules with single bonds. This requires filtering the data based on bond type and element type, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to identify all pairs of atoms that are connected by a triple bond. This requires joining tables that contain information about bonds and their types, as well as the connections between atoms.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify all the atoms that are connected to the atoms of a specific molecule identified by 'TR181'. This requires joining two tables: one that contains connections between atoms and another that contains information about the atoms themselves. The SQL query needs to filter the results based on the molecule ID 'TR181'.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of carcinogenic molecules that do not contain fluorine. This involves filtering molecules based on their carcinogenic label, checking if they contain fluorine, and then calculating the percentage of those that do not contain fluorine.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of molecules that are carcinogenic and have triple bonds. This requires counting the total number of molecules with triple bonds and calculating the percentage of those that are labeled as carcinogenic.",
        "sql_skeleton": "SELECT _ AS percentage FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of the top three elements associated with the molecule 'TR000', sorted alphabetically. This requires filtering, sorting, and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the IDs of atoms that are bonded together within a specific molecule (TR001) and a specific bond (TR001_2_6). This requires joining two tables: one containing bond information and another containing connected atom information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the difference between the counts of molecules that are labeled as carcinogenic and those that are not. This requires filtering the data based on the label and then counting the results, followed by calculating the difference between these two counts.",
        "sql_skeleton": "SELECT _ AS diff FROM _"
    },
    {
        "query_intent": "The question is asking for the atom IDs that are associated with a specific bond ID. This requires joining two tables: one that contains bond information and another that contains atom information, and then filtering the results based on the bond ID.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the bond IDs associated with the atom ID 'TR000_2'. This requires joining two tables: one containing bond information and another containing connections between atoms.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of the top five unique molecules that contain double bonds, sorted in alphabetical order. This requires filtering, joining tables, grouping, counting, and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the percentage of double bonds in a specific molecule (TR008). This requires counting the number of double bonds and dividing it by the total number of bonds, then multiplying by 100 to get the percentage. The SQL query needs to filter the bonds by the molecule ID 'TR008' and count the occurrences of each bond type.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the percentage of molecules that are labeled as carcinogenic. This requires counting the total number of molecules and the number of carcinogenic molecules, then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of hydrogen atoms in a specific molecule (TR206) relative to the total number of atoms in that molecule. This requires counting hydrogen atoms and dividing by the total number of atoms, then converting the result to a percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the type of bond associated with a specific molecule (TR000) when it is involved in any bonds. This requires joining two tables: one containing bond information and the other containing bond details, and filtering the results based on the molecule ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the elements associated with a specific molecule (TR060) and its corresponding label. This requires retrieving data from related tables using joins.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the most common bond type in a specific molecule (TR010) and determine whether that molecule is carcinogenic. This requires counting bond occurrences, identifying the majority bond type, and retrieving the carcinogenic label of the molecule.",
        "sql_skeleton": "SELECT _, CASE WHEN _ = _ THEN _ ELSE _ END AS is_carcinogenic FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the top three unique molecules that have single bonds between two atoms and are not carcinogenic, sorted in alphabetical order. This requires filtering, joining tables, grouping, counting, and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for a list of the top two bonds that occurred with the molecule identified as 'TR006', sorted in alphabetical order. This requires filtering bonds by a specific molecule ID, ordering them, and limiting the results to the top two entries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of bonds that involve a specific atom (atom 12) within a particular molecule (molecule TR009). This requires joining tables that contain bond information and atom connections, and then filtering the results based on the molecule ID and atom ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of unique molecules that are labeled as carcinogenic and contain the bromine element. This requires filtering and joining tables to match molecules with their atomic composition and labeling.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the bond type and the atoms associated with a specific bond ID, which requires retrieving data from multiple related tables. The SQL query needs to join the `bond` and `connected` tables based on the `bond_id` and filter the results by the specified `bond_id`.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the ID of the molecule that contains the atom 'TR001_10' and whether this molecule is carcinogenic or not. This requires joining two tables: one containing atom information and the other containing molecule information, and then filtering the results based on the atom ID.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of unique molecules that have a triple bond type. This requires identifying distinct molecule IDs with the specified bond type and counting them.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of connections (bonds) associated with a specific atom identified by the ID '19'. To achieve this, we need to count the entries in a table that links atoms to their connections.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of unique elements associated with a specific molecule identified by \"TR004\". This requires retrieving data from two related tables: one containing atom information and the other containing molecule information.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of molecules that are labeled as non-carcinogenic. This requires filtering the molecules based on their label and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique molecules that contain at least one atom with an ID between 21 and 25 and are labeled as carcinogenic. This requires filtering, joining tables, and ensuring distinct results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the unique identifiers of bonds that involve atoms of phosphorus and nitrogen. This requires identifying bonds connected to atoms of both elements and ensuring no duplicate bond IDs are returned.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to determine whether the molecule with the highest number of double bonds is carcinogenic. This requires identifying the molecule with the most double bonds and then checking its label to see if it's carcinogenic.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average number of bonds that atoms of the element iodine are involved in. This requires counting the bonds for each iodine atom and then calculating the average of these counts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the bond type and bond ID associated with a specific atom (atom 45). This requires joining two tables: one containing bond information and another containing connected atoms, and then filtering the results based on the atom ID.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique elements of atoms that do not have any bonds with other atoms. This requires identifying elements that are not present in any bond connections.",
        "sql_skeleton": "SELECT _ FROM _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of atoms that are part of a triple bond within a specific molecule identified by \"TR041\". This requires joining tables that contain bond information and molecule information, and filtering based on bond type and molecule ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the elements of the atoms that are part of a specific molecule identified by 'TR144_8_19'. This requires retrieving data from a database table where the molecule ID matches the given string.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the molecule with the highest number of double bonds that is also labeled as carcinogenic. This requires counting the double bonds for each molecule and then identifying the molecule with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the least common element among carcinogenic molecules. This requires identifying unique elements, counting their occurrences, and then selecting the one with the minimum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the IDs of atoms that can form bonds with atoms of the element lead. This requires identifying atoms of other elements that are connected to lead atoms through bonds.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique elements that are part of triple bonds. This requires identifying bonds of type 'triple' and then retrieving the associated elements.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of bonds that have the most common combination of atoms' elements. This requires counting the occurrences of each bond type and then calculating the percentage of the most common bond type.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of single bonds that are carcinogenic. This requires counting the number of single bonds, counting the number of carcinogenic single bonds, and then calculating the proportion. The SQL query needs to filter and join tables to achieve this.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the total number of atoms that consist of the elements carbon and hydrogen. This requires counting the entries in a database table where the `element` column is either 'C' (carbon) or 'H' (hydrogen).",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the `atom_id2` values from a database where the corresponding atoms have the element sulfur. This requires joining two tables (`atom` and `connected`) based on a common key (`atom_id`) and filtering the results to include only those where the `element` is 'S'.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the bond type associated with atoms that have the element Tin (Sn). This requires joining tables that contain information about atoms, their bonds, and their elements, and filtering the results to only include those with the element Tin.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of unique elements that are part of molecules with single bonds. This requires filtering the data based on bond type and counting distinct elements.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the total number of atoms in molecules that contain triple bonds and have either phosphorus or bromine as an element. This requires filtering and joining tables to match the conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the bond IDs for molecules that are labeled as carcinogenic. This requires joining two tables: one containing bond information and the other containing molecule information, and then filtering the results based on the molecule's label.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of molecules that have only single bonds and are not carcinogenic. This requires filtering molecules based on bond type and label, and then selecting distinct molecule IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for the percentage composition of the element chlorine in molecules that contain single bonds. This requires calculating the ratio of chlorine atoms to the total number of atoms in single-bonded molecules and expressing it as a percentage. The SQL query needs to join tables, filter based on bond type, count atoms, and calculate the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve specific labels from a database table where the molecule IDs match 'TR000', 'TR001', and 'TR002'. The SQL query needs to filter the records based on these IDs and select the corresponding labels.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ IN ( _, _, _)"
    },
    {
        "query_intent": "The question is asking to retrieve the IDs of molecules that are labeled as non-carcinogenic. This requires filtering the data based on a specific condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of molecules labeled as carcinogenic within a specific range of molecule IDs (from TR000 to TR030). This requires filtering the data based on the molecule ID range and the carcinogenic label, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the bond type for molecules that have IDs ranging from 'TR000' to 'TR050'. This requires filtering the data based on a range of molecule IDs and selecting the relevant bond type.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking for the elements associated with a specific bond ID by joining two tables: one containing atom information and the other containing bond information. The SQL query needs to filter the results based on the bond ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of unique bond IDs that are associated with the element iodine. This requires joining two tables: one containing atom information and the other containing bond information, and then filtering based on the element type.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to determine whether molecules containing the element Calcium are predominantly carcinogenic or non-carcinogenic. This requires counting the occurrences of each label (carcinogenic or non-carcinogenic) and comparing these counts to determine the majority.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking to determine if a specific bond ID (`TR001_1_8`) exists in a database and involves atoms of both chlorine and carbon. This requires joining tables to match bonds with their respective atoms and checking for the presence of both elements.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique molecule IDs that contain a triple bond and are non-carcinogenic, specifically involving the element carbon. This requires filtering and joining data from multiple tables.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of chlorine atoms in molecules that are labeled as carcinogenic. This requires filtering molecules based on their label, counting the chlorine atoms, and calculating the percentage relative to the total number of atoms.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of toxicology elements that are associated with a specific molecule identified by 'TR001'. This requires joining two tables: one containing molecule information and the other containing atom information, and then filtering the results based on the molecule ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the unique molecule IDs that are associated with bonds of the 'double' type. This requires filtering the bonds by type and selecting distinct molecule IDs.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the IDs of the first and second atoms that are part of molecules with a triple bond type. This requires joining multiple tables to filter and sort the data correctly.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the elements that are associated with a specific bond ID. This requires joining two tables: one containing atom information and the other containing bond information, and then filtering the results based on the bond ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of unique molecules that have single bonds and are labeled as non-carcinogenic. This requires filtering, joining tables, and counting distinct values.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the label associated with a specific bond ID. This requires joining two tables (`bond` and `molecule`) based on a common key (`molecule_id`) and filtering the results to find the specific bond ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to identify the bond IDs of molecules that have a triple bond type and to determine if these molecules are carcinogenic or not. This requires joining tables to match bond types with their corresponding molecule labels and bond IDs.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the toxicology element of the 4th atom in each molecule that has been labeled as carcinogenic. This requires filtering molecules based on their carcinogenic label, joining tables to access atom information, sorting atoms within each molecule, and selecting the 4th atom's element.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the ratio of Hydrogen elements to the total number of elements in the molecule with ID 'TR006', along with the label of the molecule. This requires filtering the data, counting the Hydrogen elements, counting the total elements, and calculating the ratio.",
        "sql_skeleton": "SELECT _ AS per FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify whether a chemical compound that contains Calcium is carcinogenic. This requires joining tables that contain information about atoms, molecules, and their properties. The SQL query needs to filter records based on the presence of Calcium and check the carcinogenic label.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the type of bonds present in molecules that contain the element Carbon. This requires joining tables that contain information about atoms, bonds, and molecules, and filtering the results to only include those that feature Carbon atoms.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the chemical elements that are involved in a specific bond, identified by the bond ID \"TR001_10_11\". This requires joining tables that contain information about atoms and their connections through bonds.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of chemical compounds in the database that form a triple bond. This requires counting the total number of compounds and the number of compounds with a triple bond, then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of double bonds out of all bonds in a specific molecule (TR047). This involves counting the number of double bonds and dividing it by the total number of bonds, then multiplying by 100 to get the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify whether a specific molecule, which contains a particular atom (TR001_1), is carcinogenic. This requires joining two tables: one containing atom information and another containing molecule information, and then filtering the results based on the atom ID.",
        "sql_skeleton": "SELECT CASE WHEN _ = _ THEN _ ELSE _ END AS result FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking whether a specific molecule, identified by the ID \"TR151\", is carcinogenic. This requires retrieving a label associated with this molecule from a database.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the toxic elements (specifically, those that are radioactive or have a specific label) that are part of the molecule identified as 'TR151'. The SQL query needs to join two tables (`atom` and `molecule`), filter based on the molecule ID, and check for specific conditions on the element's label.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the count of unique chemical compounds in the database that are identified as carcinogenic. This requires filtering the data based on a specific label and counting the distinct entries.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify atoms that belong to molecules with IDs ranging from TR010 to TR050 and contain the element carbon. This requires filtering based on molecule ID and element type.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ >= _ AND _ <= _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of atoms that are part of molecules labeled as carcinogenic compounds. This requires joining two tables (one containing atom information and the other containing molecule labels) and filtering based on the label.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for bond IDs that are associated with double bonds and are part of carcinogenic compounds. This requires joining tables that contain bond information and molecule labels, and filtering based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of hydrogen atoms that are part of molecules labeled as carcinogenic. This requires filtering atoms by their element type and joining tables to match molecules with their labels.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the molecule ID associated with a specific bond (TR000_1_2) that involves the first atom named TR000_1. This requires joining tables that contain bond and atom information and filtering based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to identify atoms that contain carbon but are not part of any molecule labeled as carcinogenic. This requires filtering based on the element type and molecule label, and ensuring the molecule ID is not null.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ EXCEPT SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of molecules that contain carcinogenic compounds and have hydrogen as an element. This requires filtering the data based on specific conditions and then performing an aggregate calculation to determine the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking whether a specific molecule, identified by the ID 'TR124', is carcinogenic. This requires retrieving a label or classification associated with this molecule from a database. The SQL query needs to filter the results based on the molecule ID.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of atoms that belong to a specific molecule identified by 'TR186'. This requires retrieving data from two related tables: one containing atom information and the other containing molecule information.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the type of bond associated with a specific bond ID. To retrieve this information, we need to query a database table that contains bond information.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the unique elements that are part of the atoms connected by a specific bond, identified by the bond ID 'TR001_2_4'. This requires joining two tables: one containing atom information and the other containing bond connections, and then filtering based on the bond ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of double bonds in the molecule with ID 'TR006' and determine if this molecule is carcinogenic. This requires joining tables to access bond and molecule information and filtering based on specific conditions.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique molecules that are carcinogenic along with the elements associated with these molecules. This requires joining two tables (`molecule` and `atom`) and filtering based on a specific condition.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the identification of bonds that are single bonds and the atoms that are connected by these bonds. This requires filtering bonds by their type and joining tables to get the connected atoms.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for molecules that contain triple bonds and requires listing all the elements present in those molecules. This involves joining tables to match molecules with their bonds and atoms, and filtering based on the bond type.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the elements of atoms that are involved in a specific bond, identified by the bond ID 'TR000_2_3'. This requires joining tables that contain information about atoms, their connections, and the bonds between them.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of bonds that involve atoms of the chlorine element. This requires identifying bonds connected to chlorine atoms and then counting those bonds.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the atom IDs that belong to the molecule with the ID 'TR346' and to count the number of unique bond types associated with this molecule. This requires joining tables to match atoms with their corresponding bonds and molecule IDs.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of unique molecules that have a double bond type and are labeled as carcinogenic compounds. This requires filtering, joining tables, and counting distinct values.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of molecules that do not contain the sulfur element and do not have any double bonds. This requires filtering out molecules based on the presence of sulfur and double bonds, and then counting the remaining molecules.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ <> _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for the carcinogenic label associated with a specific bond identified by the bond ID 'TR001_2_4'. This requires joining tables to match bonds with their corresponding molecule labels.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of atoms that are associated with a specific molecule identified by the ID \"TR001\". To achieve this, we need to count the number of records in the `atom` table where the `molecule_id` matches \"TR001\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of single bonds in a list. This requires counting the entries in a table where the bond type is identified as a single bond.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify molecules that contain the element \"cl\" and are labeled as carcinogenic. This requires filtering and joining tables to match atoms with their respective molecules and labels.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ INTERSECT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for molecules that contain the element \"c\" and are not carcinogenic. This requires filtering and joining tables to match molecules with their corresponding atom data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of molecules labeled as carcinogenic that contain the Chlorine element. This involves filtering molecules based on their carcinogenic label, counting the number of atoms containing Chlorine within these molecules, and then calculating the percentage of these atoms relative to the total number of atoms in carcinogenic molecules.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the molecule ID associated with a specific bond ID. This requires joining two tables: one containing bond information and the other containing connected atom information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of unique elements that are part of a specific bond identified by 'TR001_3_4'. This requires joining two tables (atom and connected) and filtering based on the bond ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the type of bond that connects two specific atoms identified by their IDs 'TR000_1' and 'TR000_2'. This requires joining two tables: one that contains bond information and another that contains connection information between atoms.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the molecule ID that is associated with two specific atom IDs, \"TR000_2\" and \"TR000_4\". This requires joining two tables: one containing atom connections and the other containing atom details.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the element associated with a specific atom identified by the ID 'TR000_1'. To achieve this, we need to retrieve data from a database table where the atom ID matches the given value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to determine whether the molecule identified as 'TR000' is carcinogenic or not. This requires retrieving a specific label associated with the molecule from a database.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of atoms that are involved in single bonds. This requires counting the total number of atoms and the number of atoms involved in single bonds, then computing the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the count of unique molecules that are labeled as carcinogenic and contain nitrogen atoms. This requires joining two tables (molecule and atom) and filtering based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the unique identifiers of molecules that contain sulfur atoms with double bonds. This requires joining tables that contain information about atoms, their connections, and bond types, and then filtering based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of non-carcinogenic molecules that contain more than 5 atoms. This requires filtering molecules based on their label, counting the number of atoms per molecule, and then selecting those with a count greater than 5.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for a list of unique elements that are part of a molecule identified as 'TR024' and are involved in a double bond. This requires joining multiple tables to filter and retrieve the necessary data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the carcinogenic molecule that contains the highest number of atoms. This requires identifying molecules labeled as carcinogenic, counting the number of atoms in each, and then selecting the one with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of molecules that are carcinogenic and contain triple bonded hydrogen atoms. This requires filtering molecules based on their carcinogenic label and the presence of specific bonds between hydrogen and other elements.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of molecules that are labeled as carcinogenic. This requires filtering the molecules based on their label and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of molecules within a specific range (TR004 to TR010) that contain single bonds. This requires filtering molecules based on their IDs, joining tables to access bond information, and counting the occurrences of single bonds.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the count of carbon atoms within a specific molecule identified by 'TR008'. This requires joining two tables: one containing atom information and the other containing molecule information, and then filtering the results based on the molecule ID and the element type.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the element associated with a specific atom ID (TR004_7) within molecules that are not carcinogenic. This requires filtering the molecules based on their label and joining the relevant tables to retrieve the element information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of unique molecules that contain at least one double-bonded oxygen atom. This requires joining tables to match atoms with their respective molecules and bonds, and then filtering and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of molecules that contain triple bonds and are not carcinogenic. This requires joining tables to match molecules with their bond types and labels, filtering based on bond type and label, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique elements and bond types that are part of a molecule identified by the molecule ID \"TR002\". This requires joining multiple tables to filter and retrieve the necessary data.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the atom ID of a carbon atom that is involved in a double bond within a specific molecule identified by the ID 'TR012'. This requires joining tables that contain atom information and bond information, filtering based on the molecule ID and bond type, and ensuring that the atom is a carbon.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the atom IDs of atoms that are part of a carcinogenic molecule and contain oxygen. This requires filtering molecules based on their carcinogenic label and checking if they contain oxygen.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for cards that have a specific attribute related to their foil versions. The SQL query needs to filter records based on a condition and select specific columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of borderless cards that are available without powerful foils. This requires filtering the cards based on specific conditions and ensuring that the results are distinct.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of unique card names where the face's converted mana cost is greater than the card's converted mana cost. This requires filtering and joining tables to get the necessary data.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the names of cards that have a frame style ranking below 100 on EDHRec in the year 2015. This requires filtering the data based on specific conditions and joining two tables to get the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique card names that are of mythic rarity, have a print, and are banned in the gladiator format. This requires filtering and joining data from two tables: one containing card details and another containing legality information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the legality status of artifact cards that do not have multiple faces on the same card, specifically for the \"vintage\" play format. This requires filtering the cards based on their type and face count, and then retrieving the corresponding legality status.",
        "sql_skeleton": "SELECT DISTINCT CASE WHEN _ = _ AND _ IS NULL THEN _ WHEN _ = _ AND _ IS NULL THEN _ END FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of card IDs and artists where the power of the card is unknown and the card is legal for the commander play format. This requires filtering based on the power being null, checking the legalities, and joining two tables: one for card details and one for legalities.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for all cards illustrated by Stephen Daniel and their corresponding ruling text. Additionally, it needs to check if these cards have any missing or degraded properties and values. This requires joining two tables: one containing card details and another containing ruling details, and then filtering based on the artist's name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for information about the rulings of a specific card named 'Sublime Epiphany' with the number '74s'. This requires joining two tables: one containing card details and the other containing rulings, and filtering the results based on the card's name and number.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the card name and artist that have the most ruling information, along with an indication of whether the card is a promotional printing. This requires joining two tables, grouping by the card ID, counting the number of rulings per card, and then selecting the top result.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the alternative languages available for a specific card named \"Annul\" with the number 29. This requires retrieving data from two related tables: one containing card details and another containing foreign language data. The SQL query needs to filter the results based on the card's name and number, and then join the two tables to get the corresponding foreign language data.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of cards that have alternative language versions in Japanese. This requires filtering records based on specific conditions and joining two tables to retrieve the necessary information.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of cards that are available in Chinese Simplified. This involves counting the total number of cards and the number of cards available in Chinese Simplified, then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for a list of sets that are available in Italian translation, along with the total number of cards per set. This requires joining two tables and filtering based on the language.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of unique card types illustrated by the artist Aaron Boyd. This requires filtering the data based on the artist's name and then counting distinct card types.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the keywords associated with a specific card named 'Angel of Mercy' from a database. The SQL query needs to filter records based on the card name and select the keywords.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of cards that have an infinite power value, which is represented by a special value like '\u221e' or 'X'. The SQL query needs to filter records based on this condition and then count the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the type of promotion associated with the card named 'Duress'. This requires joining two tables (`cards` and `legalities`) and filtering the results based on the card name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the border color of a specific card named \"Ancestor's Chosen\" from a database. This requires retrieving data from a table where the card name matches the specified value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the original type of the card named \"Ancestor's Chosen\". This requires filtering the data to find the specific card by its name and then selecting the original type.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the languages available for the set that includes the card named 'Angel of Mercy'. This requires joining two tables: one containing card information and the other containing set translations. The SQL query needs to filter the results to only include the card with the specified name and then extract the distinct languages from the related sets.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of unique cards that have a specific legal status (restricted) and also have text boxes. This requires filtering and joining two tables: one for card details and another for legal status.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the description of the ruling associated with the card named \"Condemn\". This requires joining two tables: one containing card information and the other containing rulings, and then filtering the results based on the card's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of cards that are both in a starter deck and have a restricted status. This requires filtering the data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the status of a specific card named \"Cloudchaser Eagle\" from a database. This requires joining two tables (`cards` and `legalities`) based on a common identifier (`uuid`) and filtering the results by the card's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the type of a specific card named \"Benalish Knight\" from a database. This requires joining two tables (`cards` and `foreign_data`) on a common identifier (`uuid`) and filtering the results to find the specific card by name.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the specific rules or text associated with the card named \"Benalish Knight\". This requires querying a database to find the text that matches the card's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of artists who have illustrated cards with the flavor text in the \"Phyrexian\" language. This requires joining two tables and filtering based on the language of the flavor text.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of cards that are borderless. This requires counting the total number of cards and the number of borderless cards, then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the count of unique cards that are illustrated in German and have been reprinted. This requires filtering the data based on specific conditions and joining two tables to get the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of unique borderless cards that are illustrated in Russian. This requires filtering the data based on specific conditions and counting distinct entries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of cards whose language is French among the Story Spotlight cards. This requires filtering the cards by the `isStorySpotlight` flag, counting the total number of such cards, and then calculating the percentage of those that have a language of French.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of cards that have a toughness of 99. This requires counting the rows in a table where the toughness column matches the value 99.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of cards that were illustrated by a specific artist, Aaron Boyd. This requires filtering the data based on the artist's name and selecting the distinct names of the cards.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of cards that have a black border and are only available on MTGO. This requires filtering the data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of unique card IDs from a database where the converted mana cost is equal to 0. This requires filtering the data based on a condition and selecting distinct values.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the layout of cards that have the keyword \"flying\". This requires filtering the records based on the keyword and selecting the layout field.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of cards that have the original type \"Summon - Angel\" but have subtypes other than \"Angel\". This requires filtering and joining tables to match the conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for the IDs of cards that are foiled and have a unique interaction when paired with non-foiled cards. This requires identifying cards that are both foiled and have an alternative deck limit.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of card IDs that belong to a specific duel deck, identified as 'a'. The SQL query needs to filter the records in the 'cards' table based on the 'duelDeck' column and select the 'id' column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the `edhrecRank` values from a table named `cards` where the `frameVersion` is equal to 2015. This requires filtering the records based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of artists associated with cards that have their text in Chinese Simplified. This requires joining two tables (`cards` and `foreign_data`) on a common identifier (`uuid`), and filtering the results based on the language being 'chiSimp'.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for cards that are available only in paper format and have their text translated into Japanese. This requires filtering based on specific conditions related to availability and language.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of unique cards that are both banned and have a white border. This requires filtering and joining tables to match the criteria.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of unique identifiers (UUIDs) and their corresponding foreign language names for cards that are considered legacy. This requires filtering the data based on specific conditions and joining two tables to retrieve the necessary information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the text of a specific card's ruling from a database. This requires joining two tables (one containing card information and another containing rulings) and filtering the results based on the card's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of cards that have a future frame version and the legality status of these cards. This requires filtering the cards based on their frame version and then retrieving the corresponding legality status.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names and colors of cards that belong to a specific set, identified by the code \"OGW\". This requires filtering the data based on the set code and selecting specific columns from the table.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names and languages of cards from the set '10E' that have a converted mana cost of 5. This requires joining two tables: one containing card details and another containing set translations. The SQL query needs to filter based on the set code, converted mana cost, and language.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of cards that have an original type of \"Creature - Elf\" and the dates associated with their rulings. This requires joining two tables: one containing card details and the other containing ruling details, and filtering based on the original type.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the colors and formats of cards within a specific range of IDs (1-20). This requires retrieving data from two related tables: one containing card details and the other containing their legalities. The SQL query needs to join these tables based on a common identifier and filter the results by the specified ID range.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the names of Artifact cards that are black in color and have foreign language translations. This requires filtering and joining data from two tables: one containing card details and another containing foreign language translations.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to select the names of 3 cards with a rarity of \"uncommon\", sorted by their ruling dates in ascending order. This requires joining two tables: one containing card details and another containing ruling dates, and then filtering and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of cards designed by John Avon where the foil version does not have power. This requires filtering the data based on the artist's name and the absence of power in the foil version, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the count of cards that have a white border and are considered powerful. This requires filtering the data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for the count of cards that meet specific criteria: designed by UDON, available in the mtgo print type, and have a starting maximum hand size of -1. The SQL query needs to filter and count records based on these conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = -_"
    },
    {
        "query_intent": "The question is looking for the count of cards that have a specific frame version (1993), are available on paper, and have a sensitive content warning. This requires filtering and counting records based on these conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the mana cost of cards that meet specific criteria: they should have a normal layout, a 2003 frame version, a black border color, and be available in both paper and MTGO formats. The SQL query needs to filter records based on these conditions and retrieve the corresponding mana costs.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total unconverted mana cost of all cards created by the artist Rob Alexander. This requires aggregating the `convertedManaCost` field for records where the `artist` field matches 'Rob Alexander'.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique types of cards that are available in the arena. This requires filtering the data to only include cards that are available in the arena and then selecting distinct types.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of unique set codes from a database where the translations are in Spanish. This requires filtering the data based on the language and selecting distinct set codes.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of cards with a legendary frame effect that are only available in online game variations. This requires filtering the cards based on their frame effects and availability, counting the relevant cards, and then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the percentage of cards that are marked as Story Spotlight and do not have a text box, listed by their ID. This requires filtering the data, counting the relevant records, calculating the percentage, and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of cards that are in Spanish and to list their names. This involves counting the total number of cards and the number of cards in Spanish, then calculating the percentage. The SQL query needs to join two tables (`cards` and `foreign_data`) and use conditional counting with a `CASE` statement.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of all languages into which the set that contains 309 cards is translated. This requires joining two tables: one containing set information and another containing translation information, and filtering based on the set size.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of sets within the \"Commander\" block that have been translated into Brazilian Portuguese. This requires filtering sets by their block and language, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of all cards that are of the 'Creature' type and have a legal status. This requires filtering and joining data from two tables: one containing card details and another containing legal status information.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of unique card types that are available in the German language. This requires joining two tables (`cards` and `foreign_data`) on a common identifier (`uuid`) and filtering the results to include only those where the language is German.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of cards that have unknown power and contain information about a triggered ability. This requires filtering the cards based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the count of unique cards that meet specific conditions: they must be in the \"pre-modern\" format, have a specific ruling text, and not have multiple faces. The SQL query needs to filter and join tables to find these records and then count them.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the ID of any card that is created by the artist Erica Yang and is available in paper format in the Pauper format. The SQL query needs to filter records based on these conditions and return the relevant IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the artist associated with a specific card by its flavor text. This requires joining two tables (`cards` and `foreign_data`) based on a common identifier (`uuid`) and filtering the results by the flavor text.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the foreign name of a card that matches specific criteria: it must be of type \"Creature\" with a normal layout, have a black border color, and be illustrated by Matthew D. Wilson. The SQL query needs to filter records based on these conditions and retrieve the foreign name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of cards that have a print rarity and have a ruling text printed on a specific date. This requires filtering and joining data from two tables: one containing card details and another containing ruling texts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the translation language of a set that has 180 cards and belongs to the Ravnica block. This requires joining two tables: one containing set information and the other containing set translations, and then filtering the results based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of cards that have the format \"Commander\" and are legally available, and do not have a content warning. This requires filtering, counting, and calculating a percentage based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of cards without power that are in French. This requires filtering the data based on conditions related to power and language, and then performing a calculation to determine the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of sets that are translated into Japanese and are also expansion sets. This requires filtering and counting the relevant data, then performing a calculation to determine the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the type of printing associated with cards created by the artist Daren Bader. This requires filtering the records based on the artist's name and selecting the distinct printing types.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of color cards that have no borders and have been ranked higher than 12000 on EDHRec. This requires filtering the dataset based on specific conditions and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the count of cards that are oversized, have been reprinted, and are specifically printed for promotions. This requires filtering and joining two tables to match the conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the top three cards with unknown power that have promotional types for arena league, sorted in alphabetical order. This requires filtering, ordering, and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the language of a card identified by a specific multiverse number. This requires querying a database table that contains card data and filtering the results based on the multiverse ID.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the IDs of the top three most powerful pairs of Kingdom Foil and Kingdom Cards, sorted by the Kingdom Foil ID in alphabetical order. This requires filtering, joining tables, sorting, and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the percentage of cards that do not have a text box and have a normal layout. This requires filtering the data based on specific conditions and then calculating the proportion of the filtered results to the total number of records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the unique card numbers of cards that have the subtypes \"Angel\" and \"Wizard\" and do not have multiple faces. This requires filtering and joining tables to match the conditions specified.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ <> _ AND _ LIKE _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the names of the top three sets that do not appear in Magic: The Gathering Online, sorted in alphabetical order. This requires filtering out sets that are available online, ordering the results, and limiting the output to the top three entries.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ AND _ <> _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the languages available for the set named \"Archenemy\" with the code \"ARC\" on the Magic: The Gathering card market. This requires joining two tables: one containing set details and another containing set translations, and filtering the results based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name and translation of the set identified by the number 5. This requires retrieving data from two related tables: one containing set information and the other containing translations for the set names.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the language and expansion type of a specific set identified by its number (206). To retrieve this information, we need to join two tables: one containing set information and another containing translations of set names.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the top two sets of cards that have Italian-language cards and are located in the Shadowmoor block, sorted in alphabetical order. This requires joining multiple tables to filter and retrieve the necessary data.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the ID of a set that is not available outside the United States and has foil cards with Japanese writing. This requires filtering sets based on their availability and language, and then selecting the relevant set ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the Russian name of the set that contains the most cards overall. This requires joining two tables, filtering by language, sorting by the number of cards in descending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the percentage of cards that have Chinese Simplified as the language and are only available for online games. This requires filtering the data based on specific conditions and calculating a percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the count of sets that are available exclusively in Japanese and not in Magic: The Gathering Online. This requires filtering sets based on their language and online availability.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the count of cards that have a black border and the IDs of those cards. This requires filtering the records based on the border color and then selecting the IDs of the filtered records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the number of cards that have a specific frame effect (\"extendedart\") and wants to list the IDs of those cards. This requires filtering the data based on a condition and counting the results, while also selecting the IDs of the filtered records.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of cards that have a black border and feature full artwork. This requires filtering the data based on specific conditions and selecting distinct results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the language associated with a specific set identified by '174'. This requires joining two tables (`sets` and `set_translations`) and filtering the results based on the set ID.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the name of a set from a database where the set code is \"ALL\". This requires selecting data from a table based on a specific condition.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the language associated with the card named \"A Pedra Fellwar\" from a foreign data source. This requires filtering the data based on the card name and selecting the language.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the set code of a set that was released on a specific date (07/13/2007). This requires querying a database to find the set code associated with the given release date.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the base set size and set code of sets that belong to both the \"Masques\" and \"Mirage\" blocks. This requires filtering and intersecting data from two different conditions.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ INTERSECT SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the codes of sets that have an expansion type of \"expansion\". This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the foreign name and type of cards that have a 'boros' watermark. This requires joining two tables (`cards` and `foreign_data`) based on a common identifier (`uuid`) and filtering the results to include only those with the specified watermark.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the language and flavor text of cards that have a specific watermark, as well as the type of these cards. This requires joining two tables (`cards` and `foreign_data`) based on a common identifier (`uuid`) and filtering the results based on a condition applied to the `watermark` column.",
        "sql_skeleton": "SELECT DISTINCT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of cards in the \"Abyssal Horror\" set that have a converted Mana Cost of 10. This requires filtering the cards by their set and then calculating the proportion of those cards that meet the specified Mana Cost condition.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the codes of sets that belong to the 'commander' type. This requires filtering the data based on a specific condition and selecting the relevant column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the foreign name and type of cards that have an \"abzan\" watermark. This requires joining two tables (`cards` and `foreign_data`) on a common identifier (`uuid`), filtering based on the watermark, and selecting distinct results for the foreign name and type.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the language and type of cards that have an Azorius watermark. This requires joining two tables (`cards` and `foreign_data`) on a common identifier (`uuid`) and filtering the results based on the watermark value.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of cards designed by Aaron Miller that are considered incredibly powerful, as indicated by their converted mana cost being greater than 10. The SQL query needs to filter records based on the artist's name and a condition on the converted mana cost, and then count the filtered records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of cards that are available in paper and have a positive starting maximum hand size. This requires filtering the data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is asking for a list of unique card names that have a text box. This requires filtering the cards based on a condition and selecting distinct names.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the unconverted mana cost of a specific card named \"Ancestor's Chosen\" from a database. This requires filtering the data based on the card's name and selecting the relevant field.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of cards that have a white border color and an unknown power. This requires filtering the dataset based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of cards that are promotional paintings and have multiple faces on the same card. This requires filtering cards based on their promotional status and checking if they have multiple faces.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for a list of types associated with the card named \"Molimo, Maro-Sorcerer\" from a database. This requires filtering the data based on the card's name and selecting the relevant type field.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of URLs where cards with a promotional type of \"bundle\" can be purchased. This requires filtering the data based on the promotional type and selecting the purchase URLs.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ IS NOT NULL"
    },
    {
        "query_intent": "The question is looking for the count of unique artists who have designed cards with a black border color and are available in both \"arena\" and \"mtgo\" printing types. This requires filtering and joining tables to match the criteria.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to compare the converted mana costs of two specific cards, \"Serra Angel\" and \"Shrine Keeper\", and determine which one has the higher cost. This requires filtering the data to match the card names, calculating the converted mana cost, and then comparing these costs to find the maximum value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the artist who designed a specific card with the promotional name \"Battra, Dark Destroyer\". This requires querying a database to find the artist associated with the card's name.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of the top 3 cards that have the highest converted mana cost and also have a specific frame style (2003). This requires filtering and sorting the data based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the Italian name of the set that includes the card named \"Ancestor's Chosen\". This requires joining two tables: one containing card information and another containing set translations, and filtering the results based on the card name and the Italian language.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the number of unique translations available for the set of cards that include \"Angel of Mercy\". This requires identifying the set that contains \"Angel of Mercy\" and then counting the number of translations for that set.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the names of cards that belong to a specific set, \"Hauptset Zehnte Edition\". This requires filtering records based on the set name and joining two tables to get the card names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to determine if there exists a Korean version of the card named \"Ancestor's Chosen\" within a specific set of cards. This requires checking for the presence of a specific card name and its translation in Korean.",
        "sql_skeleton": "SELECT CASE WHEN _ THEN _ ELSE _ END FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of cards in the set \"Hauptset Zehnte Edition\" that were designed by Adam Rex. This requires filtering cards by their set and designer, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the number of cards in the base set of a specific set named \"Hauptset Zehnte Edition\". To achieve this, we need to join the `sets` and `set_translations` tables to match the set name with its code, and then count the cards in the base set.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the Simplified Chinese translation of the name of a specific set, \"Eighth Edition\". This requires querying a database to find the translation for the given set name in the specified language.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to determine whether a specific card, \"Angel of Mercy,\" was available in a particular format, specifically on Magic: The Gathering Online. This requires checking the card's presence in the database and its associated set's online availability.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the release date of a specific set of cards that includes the card named \"Ancestor's Chosen\". This requires retrieving data from multiple tables and filtering based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the type of expansion associated with the set named \"Hauptset Zehnte Edition\". To retrieve this information, we need to query a database table that contains set information and filter the results based on the set name.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of sets within the \"Ice Age\" block that have an Italian translation. This requires filtering sets by their block, joining tables to get translations, and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to determine if the set containing the card \"Adarkar Valkyrie\" is exclusively available outside the United States. This requires checking the availability status of the set and filtering by the card's name.",
        "sql_skeleton": "SELECT DISTINCT CASE WHEN _ = _ THEN _ ELSE _ END FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of sets that have an Italian translation and a base set size of under 100. This requires filtering the sets based on language and base set size, and then counting the matching records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the count of cards from the set \"Coldsnap\" that have a black border color. This requires filtering the cards by set name and border color, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the names of cards from the \"Coldsnap\" set that have the highest converted mana cost. This requires filtering cards by set, sorting them by converted mana cost in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for artists who have designed cards in the specified sets. This requires filtering the artists based on their involvement in the sets \"Coldsnap\", \"Jeremy Jarvis\", \"Aaron Miller\", or \"Chippy\".",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ IN ( _, _, _)"
    },
    {
        "query_intent": "The question is looking for the specific card number within the \"Coldsnap\" set. This requires joining two tables: one containing card details and the other containing set details, and then filtering the results based on the set name and the card number.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of cards in the \"Coldsnap\" set that have a converted mana cost greater than 5 and an unknown power. This requires filtering the data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the Italian flavor text of a specific card named \"Ancestor's Chosen\". This requires querying a database to find the relevant text based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of unique foreign languages in which the card \"Ancestor's Chosen\" has a flavor text. This requires filtering records based on the card's name and the language, and then selecting distinct values of the language field.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the type of the card \"Ancestor's Chosen\" in German. This requires querying a database to find the `type` attribute of the card with the name \"Ancestor's Chosen\" from the `foreign_data` table, filtering the results to only include entries where the language is German.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of Italian text rulings for all cards in the \"Coldsnap\" set. This requires filtering and joining data from multiple tables to match the specific criteria.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the Italian names of the cards in the \"Coldsnap\" set that have the highest converted mana cost. This requires filtering the data by set name, converting the names to Italian, and then sorting and limiting the results to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the date when a specific card named 'Reminisce' had its ruling created. This requires joining two tables: one containing card information and the other containing ruling information, and then filtering the results to find the specific card.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of cards in the \"Coldsnap\" set that have a converted mana cost of 7. This requires filtering the cards by the set name, counting the total number of cards, and counting the cards with a converted mana cost of 7, then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of cards in the \"Coldsnap\" set that have a loyalty power greater than 5. This involves filtering the cards by set, counting the total number of cards, and counting the number of cards with loyalty power greater than 5, then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the unique identifier (code) of a set that was released on a specific date (2017-07-14). This requires filtering records based on a date condition and selecting the distinct code.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the `keyruneCode` from the `sets` table where the `code` matches 'PKHC'. This requires selecting specific data from a table based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the magic card market ID (mcmId) of a set that has a specific code ('SS2'). This requires joining two tables: one containing set information and the other containing translations of set codes.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of a set that was released on a specific date (2017-06-09). To achieve this, you need to join two tables: one containing set information and another containing set translations, and then filter the results based on the release date.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the type of the set \"From the Vault: Lore\". This requires retrieving data from a database where the set name is matched with its corresponding type.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the parent code for a specific set named \"Commander 2014 Oversized\" from a database. This requires joining two tables to match the set name with its corresponding parent code.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the text of the ruling for all cards illustrated by Jim Pavelec and whether these cards have missing or degraded properties and values. This requires joining two tables (`cards` and `rulings`) based on a common identifier (`uuid`) and filtering the results based on the artist's name.",
        "sql_skeleton": "SELECT DISTINCT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the release date of the set that includes a specific card named \"Evacuation\". This requires joining two tables: one containing card information and the other containing set information, and then filtering the results based on the card's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of cards in a specific set, identified by the set name \"Rinascita di Alara\". This requires joining two tables: one containing set information and the other containing card information, and then filtering based on the set name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the type of a specific set named \"Huiti\u00e8me \u00e9dition\" from a database. This requires joining two tables and filtering the results based on the set name.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the French name of the set that includes the card named \"Tendo Ice Bridge\". This requires joining two tables: one containing card information and another containing set translations. The SQL query needs to filter based on the card's name and the language being French.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of translations for the name of the set \"Tenth Edition\". This requires filtering the data by the set name and counting the number of matching records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the Japanese name of the set that includes the card \"Fellwar Stone\". This requires joining multiple tables to match the card name with its set and translation details.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the card in the set \"Journey into Nyx Hero's Path\" that has the highest converted mana cost. This requires filtering the cards by set name, sorting them by converted mana cost in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the release date of a specific set named \"Ola de fr\u00edo\". To achieve this, we need to retrieve data from a database by joining two tables: one containing set details and another containing set translations. The SQL query will filter the results to find the release date for the specified set name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the type of expansion (e.g., booster, set, etc.) that includes the card named \"Samite Pilgrim\". This requires identifying the set that contains the specified card and then determining the type of that set.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of cards in a specific set, 'World Championship Decks 2004', that have a converted mana cost of 3. This requires filtering the data based on the set name and the converted mana cost, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the Simplified Chinese translation of the name of the set \"Mirrodin\" from a database. This requires querying a database table that contains set translations and filtering the results based on the set name and language.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of card sets that have a Japanese translation and are only available in non-foil. This requires filtering the sets based on their translations, counting the relevant sets, and calculating the percentage of those sets that are non-foil only.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of sets that have a Brazil Portuguese translation and are only available online. This requires filtering sets based on their translation language and checking their availability status. The SQL query needs to calculate the percentage of sets that meet both conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the unique printing types of cards that do not have a text box created by the artist Aleksi Briclot. This requires filtering out cards with a specific artist and then selecting the distinct printing types of the remaining cards.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for the unique identifier of the set that contains the highest number of cards. This requires identifying the set with the maximum base set size and retrieving its ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the illustrator of the card with the highest converted mana cost that does not have multiple faces on the same card. This requires filtering out cards with multiple faces and then finding the one with the maximum converted mana cost.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ <> _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the most frequently occurring visual frame effects among cards that are considered incredibly powerful foils. This requires identifying the top frame effects based on their count.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of unique cards that have unknown power, cannot be found in foil, and are part of duel deck A. This requires filtering and joining tables to match the criteria.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the set ID of the Commander set that has the highest total number of cards, including promotional and related supplemental products, but excluding Alchemy modifications. This requires filtering the sets by type, summing the card counts, and then selecting the maximum value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the top 10 cards with the highest converted mana cost in the context of duels. This requires filtering the cards by their duel deck status and then sorting them by their converted mana cost in descending order, limiting the results to the top 10.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the release date of the oldest mythic card and the legal play formats for that card. This requires identifying the earliest release date of a mythic card and ensuring that the card is still legal in at least one format.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ GROUP BY _, _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of cards that were illustrated by Volkan Baga and have a French translation. This requires joining two tables: one containing card data and another containing foreign translations, and then filtering based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of rare enchantment cards named \"Abundance\" that are legal in all formats. This requires filtering based on card type, rarity, and name, and then checking their legal status in various formats.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the play format with the highest number of banned cards and the names of all cards that meet this condition. This requires joining two tables (cards and legalities), filtering for banned cards, grouping by format, counting the number of banned cards per format, and then identifying the format with the highest count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the language associated with the \"Battlebond\" set. This requires querying a database to find the language translation for the set with the code \"Battlebond\".",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the illustrator who has illustrated the fewest number of cards and the formats of play for those cards. This requires identifying the illustrator with the minimum count of associated cards and then retrieving the corresponding formats of play.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the status of cards that meet specific criteria: they were illustrated by D. Alexander Gregory in the year 1997, are in legacy play format, have sensitive content, or are associated with Wizards of the Coast. The SQL query needs to filter and join tables to retrieve this information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of cards that are ranked 1st on EDHRec and are banned in the Commander play format. This requires filtering and joining data from two tables: one containing card details and another containing legalities.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the average annual number of sets released between January 1, 2012, and December 31, 2015, and it requires identifying the most common language of the cards in those sets. This involves calculating the count of sets per year and then finding the language with the highest count.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique artists who illustrated cards with black borders that are available exclusively in the arena. This requires filtering based on specific conditions and ensuring the results are distinct.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the unique identifiers (UUIDs) of cards that are restricted or banned in the old school format. This requires filtering the data based on specific conditions and joining two tables to get the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of cards designed by Matthew D. Wilson that are available only in paper format. This requires filtering the data based on the artist's name and the availability status, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the rulings associated with cards designed by the artist Kev Walker, sorted in descending order by date. This requires joining two tables: one containing card information and the other containing rulings, and then filtering and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking for the names of all cards from the \"Hour of Devastation\" set and the formats in which these cards are legal. This requires retrieving data from two related tables: one containing card information and the other containing legalities for each card.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of sets that have a Korean translation but do not have a Japanese translation. This requires filtering and joining tables to match the conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to list all the unique frame styles and cards that Allen Williams has worked on, and to identify any banned cards among those. This requires filtering and joining data from two tables: one containing card information and another containing legalities.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ UNION SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to compare the reputation scores of two users, Harlan and Jarrod Dixon, to determine which one has a higher reputation. This requires filtering the users by their display names and then comparing their reputation scores.",
        "sql_skeleton": "SELECT CASE WHEN _ > _ THEN _ ELSE _ END AS UserWithHigherReputation FROM _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking for a list of display names of users whose accounts were created in the year 2011. This requires filtering records based on a specific condition and selecting a specific column from the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the number of unique users who last accessed the website after September 1, 2014. This requires filtering the records based on a date condition and counting the distinct user IDs.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who has the highest number of views. This requires identifying the maximum value in the \"Views\" column and then retrieving the corresponding \"DisplayName\" from the \"users\" table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of users who have more than 100 upvotes and more than 1 downvote. This requires filtering the users based on these conditions and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the count of users who have more than 10 views and created their account after the year 2013. This requires filtering users based on their view count and creation date, and then counting the number of users that meet these criteria.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ AND _ > _"
    },
    {
        "query_intent": "The question is asking for the total number of posts owned by a specific user, identified by their display name \"csgillespie\". To achieve this, we need to count the number of posts where the owner's display name matches \"csgillespie\".",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of titles of posts that are owned by a specific user, identified by the display name \"csgillespie\". To achieve this, we need to join the `posts` and `users` tables on the user ID and filter the results based on the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who owns a post with the title \"Eliciting priors from experts\". This requires joining the `posts` and `users` tables based on the owner user ID and filtering by the post title.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the title of the post that is owned by the user \"csgillespie\" and has the highest popularity, which is determined by the `FavoriteCount` column in the `posts` table. The SQL query needs to filter posts by the owner's display name and then sort them by their popularity in descending order to find the most popular one.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who owns the post with the highest number of favorites. This requires identifying the post with the maximum favorite count and then retrieving the display name of its owner.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the total number of comments associated with all posts owned by a user named \"csgillespie\". This requires joining the `comments` and `posts` tables, filtering by the owner's display name, and counting the comments.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the post with the highest number of answers owned by the user \"csgillespie\" and the count of those answers. This requires identifying the post and then counting the answers associated with it.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who last edited a specific post. This requires joining the `users` and `posts` tables on the user ID, filtering by the post title, and selecting the display name of the user who made the last edit.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of posts owned by a user named \"csgillespie\" that are considered \"root posts\". This requires filtering posts based on the owner's display name and checking their type.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the display names of users who have posts that are considered well-finished, which is indicated by a non-null `ClosedDate` in the `posts` table. This requires filtering and joining tables to match users with their respective posts.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of posts owned by users who are older than 65 years and have a score greater than 19. This requires filtering posts based on their owners' age and their own score, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the location of the user who owns the post titled \"Eliciting priors from experts\". To achieve this, we need to join the `posts` and `users` tables based on the user ID and filter the results by the post title.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the body of a post from which the tag \"bayesian\" is excerpted. This requires joining two tables: one containing post information and the other containing tag information, and filtering the results based on the tag name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the body of the post that is associated with the most popular tag, as determined by the count of occurrences of that tag. This requires joining two tables, sorting by the count of the tag in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the total number of badges obtained by a specific user, identified by their display name. This requires counting the entries in the `badges` table that are associated with the user `csgillespie`.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of badge names that have been obtained by a user with the display name \"csgillespie\". This requires joining two tables: one containing user information and the other containing badge information, and filtering the results based on the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of badges obtained by a user named \"csgillespie\" in the year 2011. This requires filtering the badges based on the user's display name and the year they were obtained, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who has obtained the most number of badges. This requires joining the `badges` and `users` tables, grouping by user ID, counting the number of badges per user, and then selecting the user with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _, _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the average score of posts that are owned by a specific user, \"csgillespie\". This requires joining the `posts` and `users` tables on the user ID and filtering the results based on the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the average number of badges (distinct entries in the `badges` table) obtained by users who have more than 200 views. This requires joining the `badges` and `users` tables, filtering users based on their view count, and then counting the distinct badge IDs for those users.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of posts with a score greater than 5 that are owned by users aged 65 or older. This requires filtering posts based on their score, counting the number of such posts, and then determining the proportion of these posts that are owned by elder users.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the total number of votes cast by a specific user (user ID 58) on a specific date (2010-07-19). This requires counting the votes associated with the user and the date.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to find the date on which the highest number of votes were created. This requires counting the votes for each creation date and then identifying the date with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the count of badges that have the name \"Revival\". This requires filtering the badges by name and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the title of the post that has the highest score among its comments. This requires identifying the post with the highest comment count and then retrieving its title.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the number of comments associated with a post that has a specific view count of 1910. This requires joining the `posts` and `comments` tables based on the post ID and filtering the results by the view count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the number of favorite counts a post received, where the post was commented on by a specific user at a specific time. This requires joining the posts and comments tables, filtering based on the user ID, comment text, and creation date, and then counting the favorite counts of the associated post.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the text of a comment associated with a post that has a specific parent ID. This requires joining the comments and posts tables based on the post ID and filtering the results by the parent ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to determine if a post made by a user at a specific time was well-finished, based on the post's score. This requires joining the comments and posts tables to match the user ID and post ID, filtering by the comment creation date, and then evaluating the post score.",
        "sql_skeleton": "SELECT CASE WHEN _ > _ THEN _ ELSE _ END AS result FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the reputation points of the user who owns a specific post (post No. 65041). To achieve this, we need to join the `posts` and `users` tables based on the user ID and filter the results to find the specific post.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of posts owned by a user with the display name \"Tiago Pasqualini\". This requires joining the `posts` and `users` tables based on the user ID and filtering the results by the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the display name of the user who cast a specific vote, identified by vote number 6347. To achieve this, we need to retrieve data from two related tables: one containing user information and another containing vote information. The SQL query will need to join these tables based on a common user ID and filter the results to find the specific vote.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of votes associated with a post that has the title \"data visualization\". To achieve this, we need to count the votes linked to that specific post.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the name of the badge associated with a user who has a specific display name. This requires joining two tables: one containing user information and the other containing badge information, and then filtering the results based on the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the ratio of the number of posts made by user No. 24 to the number of votes cast by the same user. This requires counting the posts and votes for the specified user and then calculating their ratio.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of views a specific post titled 'Integration of Weka and/or RapidMiner into Informatica PowerCenter/Developer' received. To achieve this, we need to retrieve data from the posts table and filter it based on the post title.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the text content of comments that have a specific score of 17. This requires filtering the comments based on their score and selecting the relevant text field.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the user whose website URL is specifically 'http://stackoverflow.com'. This requires filtering the users based on a condition and selecting the relevant user details.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the badge that a specific user, 'SilentGhost', has obtained. This requires joining the `users` and `badges` tables based on the user ID and filtering the results by the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who made a specific comment. This requires joining the `comments` and `users` tables based on the user ID and filtering the results to find the comment that matches the given text.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve all comments made by a specific user identified by their display name, 'A Lion'. This requires filtering the comments based on the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the user ID and reputation of the user who made a post with a specific title. This requires joining two tables (`posts` and `users`) based on the user ID and filtering the results by the post title.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve all comments associated with a specific post titled 'How does gentle boosting differ from AdaBoost?'. This requires joining the comments table with the posts table based on the post ID and filtering the results by the post title.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the display names of the top 10 users who have been awarded the 'Necromancer' badge. This requires joining two tables (users and badges) and filtering based on the badge name, then ordering the results by the user ID and limiting the output to the top 10 entries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who last edited a post with the title 'Open source tools for visualizing multi-dimensional data?'. This requires joining the `posts` and `users` tables based on the `LastEditorUserId` and filtering by the post title.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the titles of posts that were edited by a user named Vebjorn Ljosa. This requires joining the posts and users tables based on the user ID and filtering the results by the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the total score of posts edited by a user named Yevgeny, along with the user's website URL. This requires joining the `posts` and `users` tables, filtering by the user's display name, and summing the scores of the posts.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for all comments left by users who have edited a specific post titled 'Why square the difference instead of taking the absolute value in standard deviation?'. This requires joining multiple tables to filter comments based on the user who edited the specified post.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the total bounty amount associated with posts that have a title containing the word \"data\". This requires aggregating the bounty amounts of relevant posts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who added a bounty amount of 50 to a post that includes the word \"variance\" in its title. This requires joining two tables (posts and votes) and filtering based on specific conditions.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the average view count of posts that are tagged with the keyword 'humor' and to list the title and comment of each such post. This requires joining the posts and tags tables, filtering by the tag name, and performing aggregate calculations.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of comments made by a specific user identified by user ID 13. To achieve this, we need to count the entries in the comments table where the user ID matches 13.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the user ID of the user who has the highest reputation. This requires identifying the maximum value in the Reputation column and then retrieving the corresponding user ID.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the user ID that has the minimum number of views. This requires identifying the user with the lowest value in the \"Views\" column.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking to count the number of unique users who received the \"Supporter\" badge in the year 2011. This requires filtering the data by the badge name and the year, and then counting the distinct user IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking to count the number of users who have been awarded more than 5 badges. This requires joining the `users` and `badges` tables, grouping the results by user ID, and filtering groups that have a count of badges greater than 5.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of users from New York who have both a \"Teacher\" and a \"Supporter\" badge. This requires joining the users and badges tables, filtering by badge names, and counting distinct user IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the user ID and reputation of the user who created a specific post (post ID 1). This requires joining the `users` and `posts` tables based on the user ID and filtering the results to find the user associated with the specified post.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for users who have only one post history per post and whose posts have at least 1000 views. This requires filtering and joining tables to match user IDs with their post history and view counts.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _ GROUP BY _ HAVING _ = _"
    },
    {
        "query_intent": "The question is looking for the users who have posted the most comments and wants to list out the badges associated with those users. This requires identifying the top comment posters and then retrieving their badge information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of users from India who have been awarded the \"Teacher\" badge. This requires filtering users by their location, joining the users and badges tables, and counting the relevant records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the percentage difference in the number of student badges awarded in the years 2010 and 2011. This requires calculating the ratio of the number of student badges awarded in 2011 to the number awarded in 2010, and then converting this ratio into a percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ IN ( _, _)"
    },
    {
        "query_intent": "The question is asking for the post history type IDs associated with a specific post ID (3720) and the count of unique users who have commented on that post. This requires retrieving data from two related tables: `postHistory` and `comments`.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for a list of posts that are related to a specific post (with ID 61217) and the popularity of that specific post. This requires retrieving related posts and their respective view counts.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the score and the link type ID associated with a specific post ID (395). This requires retrieving data from two related tables: one containing post scores and another containing link type IDs. The SQL query needs to join these tables based on the post ID and filter the results to find the specific post with ID 395.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve all post IDs that have a score greater than 60 and the corresponding user IDs who created these posts. This requires joining two tables (`posts` and `comments`) and filtering based on the score condition.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the total sum of the \"FavoriteCount\" attribute for posts made by a specific user (user ID 686) within the year 2011. This requires filtering the data based on the user ID and the year, and then summing the relevant values.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the average number of up votes and the average age of users who have created more than 10 posts. This requires filtering users based on their post count and then calculating the averages of up votes and age for those filtered users.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the number of unique users who have obtained the \"Announcer\" badge. To achieve this, we need to count the distinct user IDs associated with the \"Announcer\" badge in the badges table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of badges that were obtained at a specific date and time (7/19/2010 7:39:08 PM). This requires filtering the records in the \"badges\" table based on the \"Date\" field.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of comments that have a positive score, which implies counting the number of rows where the score is greater than zero.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the detailed content of a comment that was created at a specific date and time. To achieve this, we need to retrieve data from a database table where the creation date matches the given value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of posts that have a score of 10. To achieve this, we need to filter the posts based on their score and then count the number of records that meet this condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of badges that are associated with users who have the highest reputation. This requires identifying the maximum reputation and then retrieving the corresponding badge names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the reputation of users who received a badge at a specific date and time. This requires joining the `badges` and `users` tables based on the user ID and filtering the results by the badge date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the badge obtained by a user with the display name \"Pierre\". This requires joining the `badges` and `users` tables based on the user ID and filtering the results by the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the dates on which users from Rochester, NY obtained their badges. This requires joining the `badges` and `users` tables, filtering by location, and selecting the distinct badge dates.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of users who have obtained the \"Teacher\" badge. This requires counting the number of users with the \"Teacher\" badge and dividing it by the total number of users.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of users who obtained the \"Organizer\" badge and are teenagers (between 13 and 19 years old). This requires filtering users based on their age and the badge they received, and then calculating the percentage of these users.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the rating score of a comment associated with a post that was created at a specific date and time. This requires joining the `comments` and `posts` tables based on the post ID and filtering the results by the creation date of the post.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the detailed content of a comment associated with a post that was created at a specific date and time. This requires joining the `posts` and `comments` tables based on the post ID and filtering the results by the creation date of the post.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the ages of users who are located in Vienna, Austria, and have obtained a badge. This requires joining the `users` and `badges` tables, filtering based on the location and badge name, and selecting the distinct user ages.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of adult users who have obtained the \"Supporter\" badge. This requires filtering users by age and badge name, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is asking to find the number of views for users who received a badge at a specific date and time. This requires joining the `badges` and `users` tables, filtering by the badge date, and counting the distinct user IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of badges that are associated with users who have the lowest reputation. This requires joining the badges and users tables, filtering for the minimum reputation, and selecting the corresponding badge names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the name of a badge associated with a user who has the display name \"Sharpie\". This requires joining two tables: one containing user information and the other containing badge information, and filtering the results based on the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of users who are 65 years or older and have obtained the \"Supporter\" badge. This requires filtering users based on age and badge name, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the display name of a user whose ID is 30 from a database table named \"users\". The SQL query needs to select the display name where the user ID matches 30.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of users who are located in New York. To achieve this, we need to count the entries in the `users` table where the `Location` column matches \"New York\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of votes cast in the year 2010. To achieve this, we need to count the number of records in the `votes` table where the `CreationDate` falls within the year 2010.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking for the count of users who are considered adults, which implies filtering users based on their age. The SQL query needs to count the number of records in the `users` table where the `Age` column is greater than 18.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the users who have the highest number of views. This requires identifying the maximum value of views and then selecting all users who have that maximum value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking to calculate the ratio of the number of votes cast in the year 2010 to the number of votes cast in the year 2011. This requires filtering votes by year and then performing a division operation to get the ratio.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the names of tags associated with posts made by a user named \"John Salvatier\". To achieve this, we need to join the users and tags tables, filter by the user's display name, and select the tag names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of posts created by a specific user, Daniel Vassallo. To achieve this, we need to count the posts associated with this user by joining the `posts` and `users` tables based on the user ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of votes cast by a user named Harlan. To achieve this, we need to count the votes associated with the user identified by their display name. This requires joining the `votes` and `users` tables based on the user ID and filtering the results by the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the post ID of the post made by the user \"slashnick\" that has the highest number of answers. This requires joining the `posts` and `users` tables, filtering by the user's display name, sorting by the number of answers in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to compare the popularity (view count) of posts made by two users, Harvey Motulsky and Noah Snyder, and determine which one has the higher view count. This requires joining the posts and users tables, filtering by user display names, sorting by view count in descending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of posts made by a user named \"Matt Parker\" that have received more than 4 votes. This requires filtering posts based on the user's display name and the vote count, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the total number of negative comments received by a user named Neil McGuigan on their posts. This requires counting the comments with a negative score and filtering by the user's display name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the tags used by a user named \"Mark Meckes\" in their posts that do not have any comments. This requires joining multiple tables to filter posts by the user, checking if the posts have comments, and then retrieving the relevant tags.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the display names of users who have obtained the \"Organizer\" badge. This requires joining the `users` and `badges` tables based on the user ID and filtering the results to include only those with the \"Organizer\" badge.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of posts made by a user named \"Community\" that include the tag \"R language\". This requires filtering posts by the user, counting posts with the \"R language\" tag, and calculating the percentage relative to the total number of posts made by that user.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the difference in view counts between posts made by users named \"Mornington\" and \"Amos\". This requires joining the `posts` table with the `users` table, filtering based on user display names, and then calculating the difference in view counts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of unique users who received the \"Commentator\" badge in the year 2014. This requires filtering records by date and counting distinct user IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of posts created on a specific date, which requires counting the entries in the \"posts\" table where the \"CreationDate\" matches \"21st July, 2010\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the display names and ages of users who have the highest number of views. This requires identifying the maximum value of views and then selecting users who have that value.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the last edit date and the user ID of the last editor for a specific post titled \"Detecting a given face in a database of facial images\". This requires retrieving data from a database table that stores post information.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of negative comments given by a specific user (user ID 13). This requires filtering comments by the user ID and the score, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the title of a post that received positive comments and the display names of the users who posted those comments. This requires filtering comments by their score and joining the comments table with the users table to get the display names.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the names of badges received by a user located in the North Pole specifically in the year 2011. This requires filtering data based on user location and date, and joining two tables: badges and users.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the display names and website URLs of users who have posted a question with a favorite count greater than 150. This requires joining the `posts` and `users` tables, filtering based on the favorite count, and selecting specific columns.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the post history counts and the last edit date of a specific post titled \"What is the best introductory Bayesian statistics textbook?\". This requires retrieving data from two related tables: `postHistory` and `posts`, and filtering the results based on the post title.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the last accessed date and location of users who have received a specific badge named \"outliers\". This requires joining the `users` and `badges` tables on the user ID and filtering based on the badge name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the title of a related post associated with the title \"How to tell if something happened in a data set which monitors a value over time\". This requires joining the `posts` and `postLinks` tables to find the related post's title.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ OR _ = _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for a list of post IDs and badge names associated with the user \"Samuel\" specifically for the year 2013. This requires filtering the data based on the user's display name and the year of the badge creation date.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who owns the post that has the highest number of favorites. This requires identifying the post with the maximum favorite count and then retrieving the display name of its owner.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the display name and location of the user who is associated with the post that has the highest count of the \"hypothesis-testing\" tag. This requires joining tables, filtering by tag name, grouping by user ID, and ordering by the count of the tag in descending order to find the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the titles of related posts and their respective link type IDs for a specific post titled \"What are principal component scores?\". This requires joining the `posts` table with the `postLinks` table and filtering based on the post title.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who owns the child post with the highest score. This requires joining the `posts` and `users` tables, filtering for child posts (those with a parent ID), and ordering the results by score in descending order to find the top-scoring child post.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the display names and website URLs of the user who received the highest bounty amount when their vote type is 8. This requires joining two tables (`users` and `votes`), filtering based on the vote type, sorting by bounty amount in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the titles of the top 5 posts that have the highest popularity, which is typically measured by the number of views. This requires sorting the posts by their view count in descending order and limiting the results to the top 5 entries.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the number of tags that have a post count within the range of 5,000 to 7,000. To achieve this, we need to filter records based on a condition and then count the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the user ID of the owner of the post that has the highest number of favorites. This requires identifying the post with the maximum favorite count and then retrieving the owner user ID of that post.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the age of the user who has the highest number of upvotes. This requires joining the `users` and `votes` tables, grouping by user IDs, counting the votes, and then ordering the results to find the top user.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the count of posts that were created in the year 2011 and have a bounty amount of 50. This requires filtering records based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the ID of the user who has the most recent creation date. This requires identifying the maximum value in the `CreationDate` column of the `users` table.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking for the total score of a post that was created on a specific date (2010-07-19). To achieve this, we need to aggregate the scores of posts based on their creation date.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average monthly number of links created in the year 2010 for posts that have no more than 2 answers. This requires filtering posts based on their answer count, counting the links created within a specific timeframe, and then calculating the average monthly link creation.",
        "sql_skeleton": "SELECT _ AS avg_links FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the ID of the post that received the highest number of votes from a specific user (1465). This requires identifying the post with the maximum vote count for that user.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the title of the post that is associated with the oldest post link. This requires identifying the post with the earliest creation date from the `postLinks` table and then retrieving its title from the `posts` table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the display name of the user who has acquired the highest number of badges. This requires joining the `badges` and `users` tables, counting the number of badges per user, and then selecting the user with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the earliest date on which a user with the display name 'chl' cast a vote in a post. This requires joining the users and votes tables, filtering by the user's display name, and finding the minimum creation date of the votes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the earliest date on which the youngest user (the user with the minimum age) made their first post. This requires identifying the youngest user and then finding the earliest post date associated with that user.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the display name of the user who first earned the \"Autobiographer\" badge. This requires identifying the user associated with the earliest badge acquisition date for that specific badge.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of users from the United Kingdom who have at least one post with a total favorite count of 4 or more. This requires filtering users by location and joining their posts to count the favorites, then summing those counts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the average number of posts voted by users who are the oldest. This requires identifying the oldest user, counting the posts they voted on, and then calculating the average of these counts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the user with the highest reputation and requires the display name of that user. This involves identifying the maximum reputation and then retrieving the corresponding display name.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of users who have a reputation higher than 2000 and have viewed their profiles more than 1000 times. This requires filtering and joining data from two tables: `users` and `votes`.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ AND _ > _"
    },
    {
        "query_intent": "The question is asking to retrieve the display names of users who are considered adults, which implies filtering users based on their age. The SQL query needs to select specific columns and apply a condition to filter the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of posts made by a user named \"Jay Stevens\" in the year 2010. This requires joining the `posts` and `users` tables, filtering by the user's display name and the year of post creation, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the post by Harvey Motulsky that has the most views, and it requires retrieving the ID and title of this post. This involves filtering posts by the user's display name, ordering them by view count in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the post with the highest score, specifically requiring the post ID and title. This involves sorting the posts by their score in descending order and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking to calculate the average score of posts made by a user named Stephen Turner. This requires joining the users and posts tables, filtering by the user's display name, and then calculating the average score of the filtered posts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the display names of users whose posts had more than 20,000 views in the year 2011. This requires filtering posts based on their view count and the year they were created, and then retrieving the corresponding user display names.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the most valuable post in the year 2010, which involves identifying the post with the highest view count from posts created in that year. The SQL query needs to filter posts by creation date, sort them by view count in descending order, and limit the result to the top entry.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ LIKE _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the percentage of posts made by users who had a reputation over 1000 in the year 2011. This requires calculating the ratio of posts created by such users to the total number of posts created in that year.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of users who are teenagers (aged between 13 and 19). This requires filtering the users based on their age and then calculating the percentage of those users out of the total number of users.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the total number of views on a specific post titled 'Computer Game Datasets' and the user ID of the user who last edited this post. This requires aggregating view counts and retrieving the most recent edit information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of posts that have a view count greater than the average view count of all posts. This requires calculating the average view count and then filtering the posts based on this average.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the count of comments associated with the post that has the highest score. This requires identifying the post with the maximum score and then counting the comments related to that post.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _ ORDER BY _ DESC LIMIT _)"
    },
    {
        "query_intent": "The question is looking to count the number of posts that have been viewed more than 35,000 times and have received no comments from other users. This requires filtering based on view counts and comment counts, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the display name and location of the user who last edited a post with a specific ID (183). This requires retrieving data from two related tables: one containing user information and the other containing post information, and then filtering the results based on the post ID and the user's last edit date.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the most recent badge awarded to a user with the display name \"Emmett\". This requires retrieving data from two related tables (`badges` and `users`) and filtering based on the user's display name, then sorting the results by the badge award date in descending order and limiting the result to the latest one.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of adult users who have cast more than 5000 upvotes. This requires filtering users by their age and counting the votes they have cast.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the duration in days between the user's account creation date and the date they received a specific badge. This requires calculating the difference between two dates and filtering the results based on the user's display name.",
        "sql_skeleton": "SELECT _ AS days FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the number of posts and comments made by the user who has the most recent account creation date. This requires joining the users and posts tables, filtering for the latest user account, and counting the posts and comments associated with that user.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the text of the latest 10 comments and the display name of the user who left those comments for a specific post with the title 'Analysing wind data with R'. This requires joining the comments and posts tables, filtering by the post title, ordering by creation date in descending order, and limiting the results to the top 10.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the count of unique users who have been awarded the 'Citizen Patrol' badge. To achieve this, we need to count distinct user IDs from the badges table where the badge name matches 'Citizen Patrol'.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of posts that have a specific tag, which is 'careers'. This requires joining two tables (posts and tags) and filtering the results based on the tag name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the reputation and view count of a user identified by their display name 'Jarrod Dixon'. This requires retrieving specific data from two related tables: one containing user information and the other containing post information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of comments and answers left by users on a specific post identified by the title 'Clustering 1D data'. This requires retrieving data from two related tables: `comments` and `posts`.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the creation date of the account of a user with the display name 'IrishStat' from a database. To achieve this, we need to retrieve data from a table where the user's display name matches 'IrishStat' and then select the creation date.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of posts that have a bounty amount greater than 30. This requires filtering the data based on a condition and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of posts by the most influential user that have a score above 50. This involves identifying the most influential user, filtering their posts, and then calculating the percentage of those posts that have a score greater than 50.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the total number of posts that have a score less than 20. This requires counting the rows in the \"posts\" table where the \"Score\" column is less than 20.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking to count the number of tags that have a tag ID less than 15 and a post count of 20 or less. This requires filtering the tags based on these conditions and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ AND _ < _"
    },
    {
        "query_intent": "The question is asking to retrieve specific IDs (excerptPostId and wikiPostId) from a table named \"tags\" where the tag name matches \"sample\". The SQL query needs to filter the results based on a condition.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the reputation and the number of upvotes of the user who made a specific comment. This requires joining the `users` and `comments` tables based on the user ID and filtering the comments to find the one with the specified text.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the texts of comments associated with posts that have the title \"Linear Regression\". This requires joining the comments and posts tables based on the post ID and filtering the results by the post title.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the comment with the highest score from posts that have views between 100 and 150. This requires joining the `comments` and `posts` tables, filtering based on the view count, sorting by comment score in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the creation date and age of users who have commented with a specific website URL. This requires filtering the comments based on the website URL and then joining the users table to get the age and creation date of those users.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE NOT _ IS NULL"
    },
    {
        "query_intent": "The question is looking for the count of unique posts where the view count is less than 5 and the corresponding comments have a score of 0. This requires joining the comments and posts tables, filtering based on the conditions, and counting distinct post IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking to count the number of comments in posts that have exactly 1 comment and where the score of those comments is 0. This requires filtering and joining tables to match comments with their respective posts and then counting the relevant entries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of users who are 40 years old and have made comments with a score of 0. This requires joining the users and comments tables, filtering based on age and comment score, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the post ID and the comments associated with a specific post titled \"Group differences on a five point Likert item\". This requires joining the `posts` and `comments` tables based on the post ID and filtering by the post title.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to find the up-vote count of a user who made a specific comment. This requires joining the `comments` and `users` tables based on the user ID and filtering by the comment text.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of comments made by a specific user identified by their username, \"Harvey Motulsky\". To achieve this, we need to retrieve data from two related tables: `comments` and `users`. The SQL query should filter the results based on the user's username.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the display names of users who have commented on posts with scores between 1 and 5 and have a reputation of 0. This requires joining two tables: one containing user information and the other containing comment information, and filtering based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of users who have 0 up votes among the comments that have scores between 5 and 10. This requires filtering comments based on their scores, joining the comments with the users table to get up votes, and then calculating the percentage of users with 0 up votes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking for a list of superpowers associated with the superhero named \"3-D Man\". To achieve this, we need to join tables that contain superhero information and their corresponding superpowers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of superheroes who possess the superpower of \"Super Strength\". This requires joining two tables: one containing superhero information and the other containing superpower information, and then filtering the results based on the superpower name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of superheroes who possess the superpower \"Super Strength\" and have a height of over 200cm. This requires joining multiple tables to filter and aggregate the data correctly.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the full names of superheroes who possess more than 15 superpowers. This requires joining multiple tables to link superheroes with their powers and then filtering the results based on the count of these powers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of superheroes who have blue eyes. This requires joining two tables: one containing superhero information and the other containing eye color information, and then filtering the results to only include those with blue eyes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the specific color of the skin of a superhero named \"Apocalypse\". To achieve this, we need to retrieve data from two related tables: one containing superhero details and the other containing color details. The SQL query will need to join these tables based on a common key and filter the results to find the specific superhero's skin color.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of superheroes who have blue eyes and possess the superpower of \"Agility\". This requires filtering superheroes based on their eye color and their superpowers, and then counting the number of matching entries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of superheroes who have blue eyes and blond hair. This requires filtering data based on specific eye and hair colors.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the count of superheroes that are published by Marvel Comics. To achieve this, we need to join two tables: one containing superhero information and the other containing publisher information, and then filter the results based on the publisher's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve a list of heroes published by Marvel Comics, sorted by their height in descending order. This requires joining the `superhero` and `publisher` tables, filtering by the publisher name, and ordering the results by height.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking for the name of the publisher associated with a superhero named \"Sauron\". This requires retrieving data from two related tables: one containing superhero information and the other containing publisher information. The SQL query needs to join these tables based on a common key and filter the results to find the specific publisher.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to rank superheroes from Marvel Comics by the popularity of their eye colors, starting with the most common color. This requires joining tables to get the eye colors and their corresponding counts, and then sorting and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking for the average height of superheroes published by Marvel Comics. To achieve this, we need to filter the superheroes by their publisher and then calculate the average height. This requires joining two tables: one for superheroes and one for publishers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of superheroes from Marvel Comics who possess the superpower of 'Super Strength'. This requires filtering superheroes based on their publisher and their associated superpowers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of superheroes published by DC Comics. To achieve this, we need to count the number of records in the `superhero` table that are associated with DC Comics in the `publisher` table. This requires joining the two tables on their respective IDs and filtering the results based on the publisher's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the publisher of the superhero who has the lowest height in centimeters. This requires identifying the superhero with the minimum height and then retrieving the corresponding publisher.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of superheroes who have gold eyes and were published by Marvel Comics. This requires filtering based on eye color and publisher, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the name of the publisher associated with the superhero named \"Blue Beetle II\". To retrieve this information, we need to join two tables: one containing superhero details and the other containing publisher details.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of superheroes who have blonde hair. To achieve this, we need to join the superhero table with the colour table to match hair colour and then count the relevant records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the superhero with the lowest intelligence attribute value. This requires joining tables to match superheroes with their attributes, filtering for the 'Intelligence' attribute, sorting the results by the attribute value in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking to retrieve the race of a superhero named \"Copycat\" from a database. This requires joining two tables: one containing superhero information and another containing race information, and then filtering the results based on the superhero's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of superheroes who have a durability attribute value of less than 50. This requires joining multiple tables to filter and retrieve the necessary data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the names of superheroes who possess the power of \"death touch.\" To achieve this, we need to join tables that contain superhero information and their associated powers, and filter the results based on the specific power name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of female superheroes who have a strength value of 100. This requires filtering superheroes based on gender and strength attribute, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the superhero who possesses the highest number of powers. This requires joining two tables, grouping the results by superhero names, counting the number of powers for each superhero, and then selecting the superhero with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the count of superheroes who have a specific alignment, which is 'vampire'. This requires joining two tables: one containing superhero information and the other containing alignment details, and then filtering the results based on the alignment.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of superheroes who have an alignment of \"Neutral Good\" or \"Lawful Good\" and are published by Marvel Comics. This requires filtering, joining tables, counting, and calculating percentages.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to compare the number of superheroes published by DC Comics and Marvel Comics and find the difference between these counts. This requires counting the number of superheroes from each publisher and then calculating the difference between these counts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for the ID of the publisher associated with the publisher named \"Star Trek\". To achieve this, we need to retrieve data from a database table where the publisher's name matches \"Star Trek\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to compute the average value of a specific attribute (attribute_value) from a table that contains data about superheroes. This requires aggregating the data to find the mean value.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking to count the number of superheroes who do not have a full name. This requires filtering the data to include only those records where the full name is null or empty.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the eye color of a superhero identified by a specific ID (75). This requires joining two tables: one containing superhero details and the other containing color details, and then filtering the results based on the superhero ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the specific superpowers associated with the superhero named \"Deathlok.\" To achieve this, we need to join tables that contain superhero information and their respective superpowers, and then filter the results based on the superhero's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the average weight of female superheroes. This requires filtering the data to include only female superheroes and then computing the average weight of this filtered dataset.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of at least five unique superpowers associated with male superheroes. This requires joining multiple tables to filter and retrieve the necessary data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of superheroes who are classified as aliens. This requires joining two tables: one containing superhero information and another containing race information, and then filtering the results to include only those with the race 'Alien'.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of superheroes who have a height between 170 and 190 cm and either have no eye color or their eye color is not specified. This requires filtering based on height, joining tables to get eye color information, and handling cases where eye color is missing or null.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ IS NULL"
    },
    {
        "query_intent": "The question is asking for the name of the superpower associated with a specific hero identified by the ID '56'. To retrieve this information, you need to join two tables: one that links heroes to their powers and another that contains the details of the powers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the full names of at least five superheroes who are classified as Demi-Gods. This requires filtering the data based on the race attribute and joining tables to access the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ LIMIT _"
    },
    {
        "query_intent": "The question is asking for the count of superheroes who have a \"bad\" alignment. To achieve this, we need to join the `superhero` table with the `alignment` table and filter the results based on the alignment being \"bad\". The final step is to count the number of records that meet this condition.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the race of a superhero based on their weight. This requires joining two tables: one containing superhero information and the other containing race information, and filtering the results based on the weight.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the hair color of a superhero who is 185 cm tall and is of the human race. This requires joining multiple tables to filter and retrieve the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the eye color of the superhero who has the highest weight. This requires joining two tables (superhero and color), filtering, sorting, and limiting the results to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of superheroes whose height falls between 150 to 180 cm and who are published by Marvel Comics. This requires filtering the superheroes by height, counting those published by Marvel, and then calculating the percentage relative to the total number of superheroes within the specified height range.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the names of male superheroes whose weight is greater than 79% of the average weight of all superheroes. This requires filtering based on gender, calculating the average weight, and comparing individual weights to this average.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > (SELECT _ FROM _) * _"
    },
    {
        "query_intent": "The question is looking for the most common power among superheroes, which requires counting occurrences of each power and then selecting the one with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the attribute value associated with the superhero named \"Abomination\" from a database. This requires joining two tables: one containing superhero information and the other containing hero attributes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the names of superpowers associated with a hero who has a specific ID (1). To achieve this, we need to join two tables: one that links heroes to their powers and another that contains the names of the powers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of heroes who possess the \"Stealth\" power. This requires joining two tables: one containing hero information and the other containing power information, and then filtering the results to only include those with the \"Stealth\" power.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the full name of the superhero who has the highest attribute value in the strength attribute. This requires joining tables to match superheroes with their attributes, filtering for the strength attribute, sorting by the attribute value in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the average number of superheroes who do not have a specified skin color. This involves filtering the data to include only those superheroes without a skin color and then calculating the average count of such superheroes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of superheroes that were published by a specific publisher, \"Dark Horse Comics\". To achieve this, we need to count the superheroes associated with that publisher.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the superhero with the highest durability (attribute) that is published by Dark Horse Comics. This requires joining tables to filter by publisher, sorting by durability in descending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the eye color of a specific superhero named \"Abraham Sapien\". To achieve this, we need to retrieve data from two related tables: one containing superhero information and the other containing eye color details. The SQL query will involve joining these tables based on a common key and filtering the results to find the specific superhero's eye color.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of superheroes who possess the power of flight. This requires joining tables that contain superhero information and their associated powers, and filtering the results to only include those with the 'Flight' power.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the eye, hair, and skin colors of all female superheroes who are published by Dark Horse Comics. This requires joining multiple tables to filter and retrieve the necessary information.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for superheroes whose eye, hair, and skin colors are the same, and it requires the publisher of these superheroes. This involves filtering and joining tables to match the specified conditions.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to identify the group (or alignment) to which the superhero A-Bomb belongs. This requires retrieving data from two related tables: one containing superhero details and the other containing alignment details. The SQL query needs to join these tables based on a common key and filter the results to find the specific superhero.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of female superheroes who have blue eyes. This requires filtering the data to include only female superheroes, counting those with blue eyes, and calculating the percentage relative to the total number of female superheroes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the name and race of a superhero named Charles Chandler. This requires retrieving data from two related tables: one containing superhero details and the other containing race details. The SQL query needs to filter the results based on the superhero's name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the gender of a superhero named \"Agent 13\" from a database. This requires joining two tables: one containing superhero information and another containing gender information, and then filtering the results based on the superhero's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of superheroes who possess the adaptation power. This requires joining multiple tables to match superheroes with their powers and filtering the results to include only those with the specified power.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of powers associated with the superhero named \"Amazo\". To achieve this, we need to count the entries in the `hero_power` table that are linked to the superhero named \"Amazo\" through a join with the `superhero` table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of the powers associated with the superhero named Hunter Zolomon. This requires joining multiple tables to link superheroes with their powers and filtering the results based on the superhero's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the heights of superheroes whose eye colors are amber. This requires filtering data based on a condition related to eye color and then selecting the height attribute.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of superheroes whose eye and hair colors are both black. This requires filtering data based on specific conditions and joining tables to access the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the distinct eye colours of heroes who have gold skin. This requires joining two tables: one containing superhero information and the other containing colour information, and then filtering the results based on the skin colour.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the full names of superheroes who belong to the 'Vampire' race. This requires joining two tables: one containing superhero information and the other containing race information, and then filtering the results based on the 'Vampire' race.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the names of superheroes who have a neutral alignment. This requires joining two tables (one containing superhero names and another containing alignment information) and filtering the results based on the alignment being 'Neutral'.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of heroes who have the highest attribute value in strength. This requires identifying the maximum attribute value for strength and then counting how many heroes have that value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the race and alignment of a superhero named Cameron Hicks. To retrieve this information, we need to join multiple tables that contain data about superheroes, their races, and their alignments.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of female superheroes published by Marvel Comics. This requires filtering the data to include only female heroes and those published by Marvel, then calculating the proportion of these heroes to the total number of heroes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the average weight of superheroes who are classified as aliens. This requires filtering the data based on the race and then performing an aggregate function to find the average weight.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the difference in weight between two individuals, Emil Blonsky and Charles Chandler, from a dataset. This requires selecting their weights and then computing the difference.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ IN ( _, _)"
    },
    {
        "query_intent": "The question is asking to compute the average height of all superheroes from a database table. This requires calculating the sum of heights and then dividing by the count of superheroes.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the specific superpower associated with the superhero named \"Abomination.\" To achieve this, we need to join multiple tables to link superheroes with their powers and filter the results based on the superhero's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of superheroes who have the race 'god/eternal' and are male. This requires filtering based on race and gender, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the superhero with the highest speed attribute. This requires joining tables to access the relevant data and sorting the results to find the top value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the count of superheroes who have a neutral alignment. This requires joining the superhero and alignment tables, filtering for neutral alignment, and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the attributes and their corresponding values of a superhero named '3-D Man'. To achieve this, we need to retrieve data from two related tables: one containing superhero information and the other containing their attributes. The SQL query will need to join these tables based on a common key and filter the results by the superhero's name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of superheroes who have blue eyes and brown hair. This requires filtering based on specific eye and hair colors by joining the `superhero` table with the `colour` table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the publisher names associated with the superheroes \"Hawkman\", \"Karate Kid\", and \"Speedy\". To achieve this, we need to join the `superhero` and `publisher` tables based on a common key and filter the results to include only the specified superhero names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ IN ( _, _, _)"
    },
    {
        "query_intent": "The question is looking for the count of superheroes that do not have any associated publishers. This requires filtering out superheroes with a publisher and then counting the remaining ones.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of superheroes who have blue eyes. This requires counting the total number of superheroes and the number of those with blue eyes, then computing the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the ratio of male superheroes to female superheroes. This requires counting the number of male and female superheroes and then computing the ratio.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the superhero who has the maximum height. This requires identifying the tallest individual from a dataset of superheroes, which involves sorting the data by height in descending order and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the unique identifier (ID) of a specific superpower named \"cryokinesis\". To achieve this, we need to retrieve data from a database table where the power name matches \"cryokinesis\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the name of a superhero from a database where the superhero's ID is 294. This requires selecting data from a table where a specific condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of full names of superheroes whose weight information is missing or null. This requires filtering the data to include only those records where the weight is null.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the eye color of a superhero whose full name is Karen Beecher-Duncan. This requires joining two tables: one containing superhero details and another containing color details, and then filtering the results based on the full name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the superpowers associated with the superhero whose full name is Helen Parr. This requires joining multiple tables to match superheroes with their powers and filtering the results based on the superhero's full name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the race of a superhero based on their weight and height. This requires joining two tables: one containing superhero information and the other containing race information, and filtering the results based on the specified weight and height.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the publisher name associated with a specific superhero identified by ID 38. This requires joining two tables: one containing superhero information and the other containing publisher information, and then filtering the results based on the superhero ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the race of the superhero who has the maximum attribute value. This requires joining multiple tables to link superheroes with their attributes and races, and then sorting the results to find the highest attribute value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking for the alignment and superpowers of a superhero named \"Atom IV\". To achieve this, we need to retrieve data from multiple related tables using joins and filter the results based on the superhero's name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the full names of at least five superheroes who have blue eyes. This requires filtering the data based on eye color and selecting the full names of the superheroes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ LIMIT _"
    },
    {
        "query_intent": "The question is asking to calculate the average attribute value for superheroes who have a neutral alignment. This requires filtering the data based on the alignment and then calculating the average attribute value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the distinct skin colors of superheroes who have an attribute value of 100. This requires joining multiple tables to match superheroes with their corresponding skin colors and attribute values.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to count the number of female superheroes who are classified as \"good.\" This requires filtering the data based on gender and alignment, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the names of superheroes whose attribute values fall within a specific range (between 75 and 80). This requires filtering data based on a condition and selecting specific columns from a table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the race of male superheroes who have blue hair. This requires joining multiple tables to filter and retrieve the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of female superheroes among those who are classified as bad. This requires filtering the data to include only bad superheroes, counting the total number of such superheroes, and then calculating the percentage of female superheroes out of this count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the difference between the number of superheroes with blue eyes and those without eye color, specifically for superheroes with missing weight data. This requires filtering superheroes based on their weight, joining tables to get eye color information, and then counting the occurrences of blue-eyed and non-blue-eyed superheroes.",
        "sql_skeleton": "SELECT _ AS diff FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ IS NULL"
    },
    {
        "query_intent": "The question is asking for the strength attribute value of the superhero named \"Hulk\". To retrieve this information, we need to join tables that contain superhero names, their attributes, and the values of those attributes. The SQL query will need to filter the results to only include the Hulk's attribute values.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of superpowers associated with the superhero named \"Ajax\". To achieve this, we need to join tables that contain superhero information, their powers, and the names of those powers. The SQL query should filter the results to only include the superhero named \"Ajax\".",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of villains who have green skin within the superhero universe. This requires filtering the data based on specific conditions (green skin and villain alignment) and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of female superheroes who are published by Marvel Comics. This requires filtering superheroes by gender and publisher, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to identify superheroes who possess the ability to control the wind and then list their names in alphabetical order. This requires joining tables that contain superhero information, their powers, and the names of those powers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _"
    },
    {
        "query_intent": "The question is looking to identify the gender of a superhero who possesses the ability known as \"Phoenix Force.\" This requires joining multiple tables to match superheroes with their powers and genders.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the superhero from DC Comics who has the highest weight. This requires joining two tables (superhero and publisher) to filter by the publisher name, sorting the results by weight in descending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the average height of superheroes who are not human and are published by Dark Horse Comics. This requires filtering data based on specific conditions and performing an aggregate calculation.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking to count the number of superheroes who have the highest speed attribute. This requires identifying the maximum speed attribute and then counting the superheroes who have this value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking to determine which publisher (DC or Marvel Comics) created more superheroes and to find the difference in the number of superheroes between these two publishers. This requires counting the number of superheroes for each publisher and then calculating the difference.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking to identify the weakest attribute (i.e., the attribute with the lowest value) of the superhero named \"Black Panther\". This requires joining multiple tables to filter and sort the data correctly.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking to retrieve the eye color of a superhero named \"Abomination\" from a database. This requires joining two tables: one containing superhero information and the other containing eye color details.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the name of the superhero who has the maximum height. To achieve this, we need to retrieve data from a table, sort it by height in descending order, and then select the top result.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the name of a superhero whose full name is Charles Chandler. To achieve this, we need to retrieve data from a database table where the full name matches the specified value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of female superheroes among all superheroes created by George Lucas. This requires filtering the superheroes by their publisher, counting the total number of superheroes, counting the number of female superheroes, and then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of superheroes from Marvel Comics who are classified as 'good'. This requires filtering superheroes by their publisher, counting the total number of superheroes, counting the number of 'good' superheroes, and then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of superheroes whose first name is 'John'. This requires filtering the data based on a condition and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the ID of the superhero who has the lowest attribute value. This requires identifying the minimum value in the `attribute_value` column and then finding the corresponding `hero_id`.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the full name of a superhero whose name is \"Alien\" from a database. This requires selecting specific data from a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the full names of superheroes who weigh less than 100 kilograms and have brown eyes. This requires filtering the data based on weight and eye color, and then selecting the relevant column.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the attribute value of a superhero named \"Aquababy\" from a database. This requires joining two tables: one containing superhero information and the other containing attribute information, and then filtering the results based on the superhero's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the weight and race of a superhero identified by a specific ID (40). This requires joining two tables: one containing superhero details and the other containing race details, and then filtering the results based on the superhero ID.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the average height of superheroes who have a neutral alignment. This requires filtering the data based on alignment and then calculating the average height of the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of superheroes who possess the power of intelligence. This requires joining two tables: one that links heroes to their powers and another that lists the names of powers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the eye color of a superhero named \"Blackwulf.\" To retrieve this information, we need to join two tables: one containing superhero details and another containing eye color details. The SQL query will need to filter the results to match the superhero's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of powers associated with superheroes whose height is greater than 80% of the average height of all superheroes. This requires filtering and joining tables to match superheroes with their powers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the reference names of drivers who are eliminated in the first period (i.e., have the fastest lap time) in a specific race (race number 20). This requires joining two tables: one containing race results and another containing lap times, and filtering the results based on the race ID and the fastest lap time condition.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the surname of the driver who achieved the best lap time in the second qualifying period (Q2) of race number 19. This requires filtering the data based on specific conditions and sorting the results to find the minimum lap time.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the years in which races are held at circuits located in Shanghai. This requires joining the circuits and races tables based on the circuit ID and filtering the results to include only those circuits located in Shanghai.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the URLs of races that are held at the Circuit de Barcelona-Catalunya. This requires joining the circuits and races tables based on the circuit ID and filtering by the circuit name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the names of races that are held on circuits located in Germany. This requires joining the circuits and races tables based on the circuit ID and filtering the results to include only those circuits in Germany.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of positions (rounds) where the constructor Renault has participated in races. This requires joining tables that contain race information and constructor information, filtering by the constructor name, and grouping the results by race position.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the number of races held in the year 2010 that are part of the Asian or Pacific Grand Prix series. This requires filtering races based on their year and name, and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ <> _ AND _ <> _"
    },
    {
        "query_intent": "The question is asking for the names of races that are held on circuits located in Spain. This requires joining two tables: one containing circuit information and the other containing race information, and then filtering the results based on the country being Spain.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the latitude and longitude coordinates of circuits where the race name includes \"Australian Grand Prix\". To achieve this, you need to join the `circuits` and `races` tables on the `circuitId` and filter the results based on the race name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the URL of the races held at the Sepang International Circuit. To achieve this, we need to join the circuits and races tables based on the circuit ID and filter the results to include only those where the circuit name matches \"Sepang International Circuit\".",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of race times that were held at the Sepang International Circuit. This requires joining the circuits and races tables based on the circuit ID and filtering the results by the circuit's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the latitude and longitude coordinates of the Abu Dhabi Grand Prix. This requires retrieving specific data from a database by joining two tables and filtering the results based on the race name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the country of the constructor that scored 1 point in a specific race (Race No. 24). This requires joining the constructors and their results, filtering by the race ID and the points scored, and selecting the country.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the Q1 result of a driver named Bruno Senna in a specific qualifying race (race No. 354). This requires joining the drivers and qualifying tables based on driver ID and filtering the results by the driver's name and the race number.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the nationality of a driver who had a specific Q2 time (1:40 minutes) in a qualifying race with the number 355. This requires joining the `drivers` and `qualifying` tables based on the driver ID and filtering the results based on the Q2 time and race ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the driver number who completed the Q3 qualifying session in 0:01:54 for race number 903. This requires joining the qualifying and results tables based on the raceId and driverId, and filtering the results to match the given time and race number.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the number of drivers who did not finish the Bahrain Grand Prix in 2007. This requires filtering the data to include only the race year 2007 and the specific race name \"Bahrain Grand Prix\", and then counting the drivers whose finish time is null.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the URL of the season page for the year in which a specific race (identified by race ID 901) took place. This requires joining the `races` and `seasons` tables based on the year and filtering the results to find the specific race.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of drivers who completed the race on a specific date. To achieve this, we need to filter the records by the race date and then count the non-null values in the `time` column, which indicates that the driver finished the race.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the oldest driver who finished the game in a specific race (race No. 592). This requires filtering drivers by their finish time and then sorting them by their date of birth to find the oldest one.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the full name and URL of the driver who achieved a lap time of 1 minute and 27 seconds in race number 161. This requires joining the lap times and drivers tables, filtering by race ID and lap time, and selecting the driver's name and URL.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the nationality of the driver who achieved the fastest lap speed in a specific race (race No. 933). This requires joining two tables: one containing race results and the other containing driver information, and then filtering the results to find the fastest lap speed and the corresponding driver's nationality.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _ WHERE _ = _) AND _ = _"
    },
    {
        "query_intent": "The question is looking for the location coordinates (latitude and longitude) of the Malaysian Grand Prix. This requires joining two tables: one containing circuit information and the other containing race information, and then filtering the results to find the specific race.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the URL of the constructor that achieved the highest points in a specific race (race No. 9). This requires identifying the race, joining relevant tables to get the constructor's details, filtering by race ID, and sorting by points in descending order to find the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the Q1 result of a specific driver, Lucas di Grassi, in a specific race (race No. 345). To achieve this, we need to join two tables: one containing qualifying results and another containing driver information, and then filter the results based on the driver's name and the race ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the nationality of a driver who had a specific Q2 time in a specific race. This requires joining two tables: one containing qualifying data and the other containing driver information, and filtering the results based on the given Q2 time and race ID.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the abbreviated code of the driver who had a Q3 time of 1:33 in race No. 45. This requires joining two tables: one containing qualifying results and the other containing driver information, and filtering the results based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the finish time of a specific driver, Bruce McLaren, in a specific race (race No. 743). This requires retrieving data from two related tables: one containing race results and the other containing driver information. The SQL query needs to join these tables based on the driver's ID and filter the results by the race ID and the driver's surname.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the forename and surname of the driver who finished in second place in the San Marino Grand Prix in the year 2006. This requires joining multiple tables to filter and sort the results based on specific conditions.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the URL of the season page for the year in which a specific race (identified by race ID 901) took place. This requires joining the `races` and `seasons` tables based on the year and filtering the results to find the URL for the specified race.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the number of drivers who did not finish the race that took place on 2015-11-29. This requires counting entries in the results table where the race date matches the given date and the position is greater than the number of laps.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the youngest driver who finished the game in a specific race (race No. 872). This requires filtering drivers by their race finish time, sorting them by their date of birth in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the full name of the driver who achieved the best lap time in a specific race (race No. 348). To achieve this, we need to join the `lapTimes` and `drivers` tables, filter the results for the specified race, and then sort the lap times to find the fastest one.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the nationality of the driver who achieved the fastest lap speed. This requires joining two tables (`drivers` and `results`), sorting the results by lap speed in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage difference in the fastest lap speed between Paul di Resta's finish in the 853rd race and the next race. This requires retrieving data from two related tables (`drivers` and `results`) and performing a calculation to find the percentage difference.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the race completion rate (i.e., the percentage of drivers who completed the race) for the drivers who participated in the race on July 16, 1983. This requires filtering the data by the race date, counting the number of drivers who completed the race, and dividing it by the total number of drivers who started the race.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the earliest year in which the Singapore Grand Prix was held. This requires identifying the first occurrence of the race name in the database and extracting the corresponding year.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the number of races that took place in the year 2005 and the names of all those races, sorted in descending order. This requires filtering data based on a specific year and then ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of all races that took place in the earliest recorded year and month. This requires filtering the data to find the minimum date and then selecting the race names for that date.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the name and date of the last race of the last round in the year 1999. This requires filtering the data by year, sorting by date in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to identify the year that has the highest number of races. This requires counting the number of races per year and then selecting the year with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of races that took place in the year 2017 but did not take place in the year 2000. This requires filtering and joining tables to exclude races that were also held in 2000.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ EXCEPT SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the country, circuit name, and location of the first European Grand Prix. This requires identifying the earliest occurrence of the \"European Grand Prix\" in the race names and retrieving the corresponding circuit details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the year of the last Formula 1 season where the British Grand Prix was held at Brands Hatch. This requires joining two tables: one containing circuit information and the other containing race information, and then filtering the results to find the most recent year.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the number of seasons in which the Silverstone Circuit has hosted the British Grand Prix. This requires counting the occurrences of a specific circuit and race name in a join of two tables.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of drivers who participated in the 2010 Singapore Grand Prix, sorted by their finishing positions. This requires joining multiple tables to filter and retrieve the necessary data.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _"
    },
    {
        "query_intent": "The question is looking for the driver who has scored the most points and their full name. This requires joining two tables (results and drivers), grouping the results by driver ID, summing the points for each driver, and then ordering the results to find the driver with the highest points.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ GROUP BY _, _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names and points of the top 3 drivers who participated in the 2017 Chinese Grand Prix. This requires joining multiple tables to filter and sort the results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the best lap time recorded across all races, including the driver and the race in which this lap time was recorded. This requires filtering the lap times to find the minimum value and then joining the lap times with the driver information to get the driver's details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average lap time of Lewis Hamilton during the 2009 Malaysian Grand Prix. To achieve this, we need to filter lap times by the driver's name, join the lap times with the races table to get the race name and date, and then calculate the average lap time for the specified race.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of times Lewis Hamilton was not in the first position (1st place) in the F1 circuit since 2010. This requires filtering data for the year 2010 and 2011, counting the instances where Hamilton was in the first position, and then calculating the percentage of times he was not in the first position.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the driver with the highest number of wins, including their nationality and maximum points scored. This requires joining multiple tables to aggregate data and then filtering to find the top result.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _, _, _, _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the age and name of the youngest Japanese driver. This requires calculating the age from the date of birth and filtering the results to find the youngest driver within the specified nationality.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for a list of unique circuits that hosted exactly 4 Formula 1 races between the years 1990 and 2000. This requires filtering and grouping data from two related tables: one containing circuit information and the other containing race information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ GROUP BY _ HAVING _ = _"
    },
    {
        "query_intent": "The question is looking for a list of circuits in the USA that hosted Formula 1 (F1) races in 2006. The output should include the name and location of each circuit and the name of the race it hosted. This requires joining two tables: one containing circuit information and the other containing race information, and filtering the results based on the year 2006 and the country being the USA.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of races, along with their circuit names and locations, for Formula 1 (F1) races hosted in September 2005. This requires joining two tables: one containing circuit information and the other containing race information, and filtering the results based on the date.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the race name where the driver Alex Yoong had a lap number less than 20. This requires joining the drivers and results tables, filtering based on the driver's name and lap number, and selecting the race name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the total number of wins by Michael Schumacher in races held at the Sepang International Circuit. To achieve this, we need to join multiple tables to match the driver, circuit, and race results, and then count the occurrences of wins.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the race name and year in which Michael Schumacher recorded his fastest lap. This requires joining multiple tables to match the driver's information with their lap times and race details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average points scored by the driver Eddie Irvine in the year 2000. This requires calculating the average from a subset of data filtered by the driver's name and the year.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the first race participated by Lewis Hamilton and the points he scored in that race. This requires identifying the earliest race he was involved in and retrieving the relevant points.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for a list of races that took place in 2017, along with the hosting country, sorted by the date of the event. This requires joining two tables: one containing circuit information and the other containing race information, and then filtering and ordering the results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _"
    },
    {
        "query_intent": "The question is looking for the race that had the most laps, including the name of the race, the year it was held, and the location of the circuit where it was hosted. This requires joining two tables (races and results), grouping the results by race, counting the number of laps per race, and then selecting the race with the highest count.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the percentage of European Grand Prix races that were hosted in Germany. This requires filtering the races by the 'Grand Prix' keyword, counting the races hosted in Germany, and calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the latitude and longitude coordinates of the Silverstone Circuit from a database. This requires selecting specific columns from a table where the circuit name matches \"Silverstone Circuit\".",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to determine which of the specified circuits has the highest latitude. This requires comparing the latitude values of the circuits \"Silverstone Circuit\", \"Hockenheimring\", and \"Hungaroring\" and selecting the one with the highest value.",
        "sql_skeleton": "SELECT CASE WHEN _ > _ THEN _ WHEN _ > _ THEN _ ELSE _ END FROM _ WHERE _ IN ( _, _, _)"
    },
    {
        "query_intent": "The question is asking for the reference name of a specific circuit, \"Marina Bay Street Circuit\". To achieve this, we need to retrieve data from a database table where the circuit name matches the given string.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the country where the circuit with the highest altitude is located. This requires identifying the maximum altitude and then finding the corresponding country.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of drivers who do not have a code assigned to them. This requires filtering the data to include only those records where the `code` field is null or an empty string, and then counting those records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the country where the oldest driver is from. This requires identifying the driver with the earliest date of birth and then retrieving their country.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE NOT _ IS NULL ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for a list of surnames of drivers who are Italian. This requires filtering the data based on the nationality attribute.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the URL of the website that provides information about a person named Anthony Davidson. To achieve this, we need to retrieve data from a database table where the forename is \"Anthony\" and the surname is \"Davidson\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the reference name of a driver named Lewis Hamilton from a database. To achieve this, we need to select specific columns from a table where the driver's forename and surname match 'Lewis' and 'Hamilton', respectively.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the circuit that hosted the 2009 Spanish Grand Prix. This requires retrieving data from two related tables: one containing circuit information and the other containing race information. The SQL query needs to filter the data based on the race name and year.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of unique years when the Silverstone Circuit was used in a Formula 1 race. This requires joining the circuits and races tables, filtering by the circuit name, and selecting distinct years.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for details about Formula 1 races that were held at the Silverstone Circuit. This requires retrieving data from two related tables: one containing circuit information and the other containing race information. The SQL query needs to filter the results to only include races held at the specified circuit.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the date and time of the 2010 Formula 1 race that took place at the Abu Dhabi Circuit. This requires filtering the races by year and circuit location, and then selecting the relevant date and time.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of Formula 1 races that took place on circuits located in Italy. This requires joining the circuits and races tables, filtering by the country 'Italy', and counting the resulting records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the dates of Formula 1 races that took place at the Barcelona-Catalunya circuit. This requires joining the circuits and races tables based on the circuit ID and filtering the results to only include the Barcelona-Catalunya circuit.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the URL of the circuit where the Spanish Grand Prix was held in 2009. This requires joining the circuits and races tables, filtering by the circuit name and race date, and selecting the URL of the circuit.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the fastest lap time ever recorded by Lewis Hamilton in any race. This requires filtering lap times by the driver's name and sorting them to find the minimum value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND NOT _ IS NULL ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the driver who achieved the fastest lap speed in a Formula 1 race, requiring both the driver's forename and surname. This involves identifying the maximum lap speed and then retrieving the corresponding driver details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the reference name of the driver who ranked first in the Canadian Grand Prix in 2007. This requires joining multiple tables to filter by specific conditions: the race name, year, and the driver's ranking.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of Formula 1 races in which Lewis Hamilton participated. This requires retrieving data from multiple related tables to match the driver's name with the race results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the specific Formula 1 race where Lewis Hamilton achieved his highest rank. This requires identifying the race with the highest rank (1) and the driver's name. The SQL query needs to filter results based on the driver's name and join tables to get the race details.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the fastest lap speed recorded by any driver during the 2009 Spanish Grand Prix. To achieve this, we need to filter the results to include only the 2009 Spanish Grand Prix and then find the maximum lap speed from those results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the years in which a specific driver, Lewis Hamilton, participated in Formula 1 races. This requires identifying the driver by name and then retrieving the associated race years.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the final rank (position) of the driver Lewis Hamilton in the 2008 Chinese Grand Prix. To achieve this, we need to join multiple tables to match the driver's name, the race's name, and the year, and then filter the results to find the specific rank.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the forename and surname of the driver who was in the 4th grid position when starting the Australian Grand Prix in 1989. This requires joining multiple tables to filter and retrieve the specific data.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of drivers who completed the race in the 2008 Australian Grand Prix. This requires filtering the data by specific conditions (race year, race name, and race completion status) and counting the relevant records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the fastest lap time achieved by Lewis Hamilton during the 2008 Australian Grand Prix. This requires joining multiple tables to filter the results by the driver's name, the specific race year, and the race name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the finish time of the driver who ranked second in the 2008 Australian Grand Prix. This requires filtering the data by year, round, and race name, and then selecting the time of the driver who ranked second.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the champion of the 2008 Australian Grand Prix, specifically the driver's name and a link to more information about them. This requires joining multiple tables to filter the results by the race name and year, and then selecting the relevant columns.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the number of drivers from the United Nations (UN) who participated in the 2008 Australian Grand Prix. To achieve this, we need to filter drivers by nationality and join tables to match drivers with the race they participated in.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the number of drivers who finished the 2008 Chinese Grand Prix and have participated in Formula 1 races. This requires filtering drivers based on race completion, joining tables to get driver information, and counting distinct drivers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of points earned by Lewis Hamilton across all Formula 1 races he participated in. This requires aggregating points data from multiple races and summing them up for the specified driver.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the average fastest lap time in seconds for the driver Lewis Hamilton across all Formula 1 races. This requires converting lap times into seconds, filtering by the driver's name, and then calculating the average.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the rate of drivers who completed all laps in the 2008 Australian Grand Prix. This involves counting the number of drivers who completed the race and dividing it by the total number of drivers who started the race. The SQL query needs to filter the data by year and race name, join relevant tables, and use conditional aggregation to count the drivers who completed all laps.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage difference in lap times between the winner and the last-place finisher in the 2008 Australian Grand Prix. This requires calculating the lap times in seconds, converting them to hours, and then finding the percentage difference between the two times.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the number of circuits located in Adelaide, Australia. To achieve this, we need to count the entries in the `circuits` table where the `location` matches \"Adelaide, Australia\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the latitude and longitude coordinates of circuits located in the United States. This requires filtering the data based on the country and selecting specific columns from the table.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of British drivers who were born after the year 1980. This requires filtering the data based on nationality and date of birth, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the maximum points earned by British constructors. This requires joining two tables (constructors and constructorResults), filtering by nationality, and finding the maximum points.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the constructor who has the highest points in a specific race. This requires joining the constructors and their results, filtering for the maximum points, and ordering the results in descending order.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for a list of constructor names that scored 0 points at a specific race identified by race ID 291. This requires joining two tables: one containing constructor results and the other containing constructor information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of Japanese constructors who have scored exactly 0 points in 2 different races. This requires filtering data based on nationality and points, and counting distinct results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of constructors who have been ranked first in any race. This requires joining the constructors and results tables, filtering for the top position (1), and grouping the results to get unique constructor names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the count of French constructors who have completed more than 50 laps. This requires joining tables to match constructors with their lap times and filtering based on nationality and lap count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of races completed by Japanese drivers between the years 2007 and 2009. This involves filtering data based on nationality and year, counting the total number of races and the number of completed races, and then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the average time in seconds of the champion for each year before the year 1975. This requires converting the time from a string format to seconds, filtering the data for years before 1975, and calculating the average time.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the forenames and surnames of drivers who were born after 1975 and have been ranked 2 in any race. This requires filtering and joining data from two tables: one containing driver information and another containing race results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of Italian drivers who did not finish the race. This requires filtering drivers by nationality and checking their race completion status.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the driver with the fastest lap time, specifically their forenames and surnames. This requires identifying the minimum lap time from the results and then retrieving the corresponding driver details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the fastest lap number of the champion in the year 2009. This requires identifying the champion by their position and then retrieving their fastest lap number. The SQL query needs to join tables to access the necessary information and filter the results based on the year 2009.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the average fastest lap speed from the results of the 2009 Spanish Grand Prix race. This requires filtering the race data by year and name, and then calculating the average of the fastest lap speeds.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the race with the shortest finishing time, which requires sorting the races by their finishing times in ascending order and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE NOT _ IS NULL ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of drivers, born before 1985, who had lap numbers greater than 50 during the years 2000 to 2005. This requires filtering data based on specific conditions and then performing a calculation to determine the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ < _"
    },
    {
        "query_intent": "The question is looking to count the number of French drivers who have lap times less than 2 minutes. This requires filtering the data based on nationality and lap time, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of driver codes for drivers who have a nationality of 'USA'. This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of race IDs that took place in the year 2009. To achieve this, you need to filter the records in the `races` table where the `year` column matches 2009.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of drivers who participated in a specific race identified by race ID number 18. To achieve this, we need to count the entries in the `results` table where the `raceId` matches 18.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the code numbers of the top 3 youngest drivers and counting how many of these drivers are from the Netherlands. This requires filtering, sorting, and counting data from the `drivers` table.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is asking for the reference name of a driver named Robert Kubica. To achieve this, we need to retrieve data from a database table that contains driver information and filter the results based on the driver's forename and surname.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of British drivers who were born in the year 1980. This requires filtering the data based on nationality and date of birth, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the top 3 German drivers born between 1980 and 1990 who have the earliest lap times. This requires filtering drivers by nationality and birth year, joining the lap times and drivers tables, sorting by lap time in ascending order, and limiting the results to the top 3.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _ GROUP BY _, _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is asking for the reference name of the oldest driver who is of German nationality. To achieve this, we need to filter the drivers by nationality, sort them by date of birth in ascending order, and select the top result.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the ID and code of drivers who were born in 1971 and have the fastest lap time in any race. This requires filtering drivers by birth year, joining the lap times table to get the fastest lap time, and then selecting the drivers who match this condition.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the top 10 Spanish drivers who were born before 1982 and have the latest lap time. This requires filtering drivers by nationality and birth year, sorting them by lap time in descending order, and limiting the results to the top 10.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ < _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the year in which the fastest lap time was recorded. This requires identifying the minimum lap time from the results and then finding the corresponding year from the races table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the year in which the lap time was the slowest. This requires identifying the minimum lap time and then finding the corresponding year.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the IDs of the top five drivers who achieved the fastest time during the first lap of the race. This requires filtering for the first lap and then sorting the results in descending order to get the fastest times.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of finishers who were disqualified in races numbered between 50 and 100. This requires filtering the results based on race numbers and disqualification status, and then counting the relevant entries.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the number of circuits held in Austria, along with their location and coordinates. This requires counting the entries and selecting specific columns from the table.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _ GROUP BY _, _, _"
    },
    {
        "query_intent": "The question is looking for the race number that has the highest number of finishers. This requires identifying races where the number of finishers is greater than or equal to the average number of finishers across all races and then finding the race with the maximum finishers among those identified.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ GROUP BY _, _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the reference name, nationality, and date of birth of drivers who completed the second qualifying lap during a specific race (race no. 23). This requires filtering data from two related tables: one containing qualifying information and the other containing driver details.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the year in which the youngest driver had their first qualifying race, along with the details of the race (name, date, and time). This requires identifying the youngest driver, finding their earliest qualifying record, and retrieving the corresponding race details.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking to count the number of American drivers who have a puncture status. This requires filtering drivers by nationality and joining tables to check for puncture status.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the Italian constructor who has the highest points to date and requires the introduction website of that constructor. This involves joining two tables (`constructors` and `constructorResults`), filtering by nationality, sorting by points in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the website URL of the constructor who has accumulated the most wins across all races. This requires aggregating win data, sorting by the total wins in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the driver who has the slowest time in the 3rd lap among those who participated in the French Grand Prix. This requires filtering the data by race name, identifying the 3rd lap, converting lap times to seconds, and then ordering the results to find the slowest time.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the race where the fastest lap time was recorded, and it requires indicating the time in milliseconds. This involves identifying the minimum lap time from a dataset and retrieving associated race information.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average fastest lap time of the top 10 drivers in the 2006 United States Grand Prix. This requires filtering the data by the specific race and year, joining tables to get the necessary information, sorting the results to get the top 10 drivers, and then calculating the average of their fastest lap times.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the top 3 German drivers who were born between 1980 and 1985 and have the shortest average pit stop duration. This requires filtering drivers based on nationality and birth year, calculating the average pit stop duration, and then sorting and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the champion (driver who finished first) of the Canadian Grand Prix in 2008 and their finish time. This requires filtering the results by race name and year, sorting by finish time, and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the constructor reference name and its website of the champion in the 2009 Singapore Grand Prix. This requires joining multiple tables to filter the results by the specific race name and year, and to ensure the champion is identified correctly.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the full names and dates of birth of drivers from Austria who were born between the years 1981 and 1991. This requires filtering the data based on nationality and date of birth.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the full name, Wiki Pedia page link, and date of birth of German drivers who were born between 1971 and 1985. The results should be listed in descending order of date of birth. This requires filtering the data based on nationality and date of birth, and then sorting the results.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ BETWEEN _ AND _ AND _ = _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking for the location, country, latitude, and longitude of the Hungaroring circuit from a database. This requires selecting specific columns from a table where a condition is met.",
        "sql_skeleton": "SELECT _, _, _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the constructor that scored the most points in the Monaco Grand Prix between the years 1980 and 2010. The required information includes the score, name, and nationality of this team. To achieve this, we need to join multiple tables to filter the data by race name, year, and score, and then sort and limit the results to find the top scorer.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average score (points) of the driver Lewis Hamilton in all instances of the Turkish Grand Prix. This requires filtering the results to include only those from the Turkish Grand Prix and then calculating the average points for Lewis Hamilton.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the average number of races held per year during the first 10 years of the 21st century. This requires calculating the total number of races and dividing it by the number of years (10) to get the average. The SQL query needs to filter the data to only include the first decade of the 21st century (2000-2009).",
        "sql_skeleton": "SELECT _ AS avg FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking to identify the nationality of the drivers that constitutes the majority. This requires counting the number of drivers for each nationality and then selecting the one with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the total number of victories (wins) acquired by the driver who ranked 91st in terms of the number of points they have. This requires joining tables to match drivers with their standings, filtering by the specific rank, and summing up the wins.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the race that recorded the fastest lap speed by a racer. This requires identifying the race with the minimum lap time and retrieving its name. The SQL query needs to join tables to access race names and lap times, and then sort the results to find the minimum lap time.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the location of the racetrack that hosted the most recent race. This requires identifying the latest race and then retrieving the corresponding circuit's location.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the full name (forename and surname) of the driver who ranked 1st in the 3rd qualifying race held at the Marina Bay Street Circuit in 2008. This requires joining multiple tables to match the race details with the driver's results and their names.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the full name, nationality, and the name of the first race of the youngest racer as of the current date. This requires filtering by the current date, sorting by date of birth in descending order, and limiting the result to the youngest racer.",
        "sql_skeleton": "SELECT _, _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the number of accidents (or laps with a position of 1) made by the driver who had the highest number of accidents in the Canadian Grand Prix. This requires identifying the driver with the maximum number of accidents and then counting the specific type of accidents (laps with a position of 1) for that driver.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the number of wins achieved by the oldest driver and their full name. This requires identifying the oldest driver based on their date of birth and then retrieving their wins and full name from related tables.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _, _, _, _, _ ORDER BY _ DESC LIMIT _)"
    },
    {
        "query_intent": "The question is looking for the maximum duration a driver has ever spent at a pit stop. This requires calculating the maximum value from a specific column in a table.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the fastest lap time among all lap records set on various circuits. This requires identifying the minimum time from a dataset of lap times.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the maximum duration (in seconds) that Lewis Hamilton spent at a pit stop. This requires filtering the data to include only Lewis Hamilton's pit stop records, converting the duration from a string to seconds, and then finding the maximum value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the lap number on which Lewis Hamilton took a pit stop during the 2011 Australian Grand Prix. This requires joining multiple tables to filter and retrieve the specific lap number.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the duration each driver spent at the pit stop during the 2011 Australian Grand Prix. This requires joining two tables: one containing race information and the other containing pit stop information, and filtering the results based on the race name and year.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the lap record (fastest lap time) set by the driver Lewis Hamilton in a Formula 1 race. This requires joining two tables: one containing driver information and the other containing race results, and then filtering the results to find the fastest lap time for Lewis Hamilton.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the full names of the top 20 drivers who have achieved the shortest lap time ever recorded in a Formula 1 race. This requires joining two tables (drivers and lapTimes), converting lap times to seconds, sorting in ascending order, and limiting the results to the top 20.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the position of the circuits during Lewis Hamilton's fastest lap in a Formula 1 race. This requires identifying the fastest lap time and then determining the position of the circuit at that time. The SQL query needs to join tables containing lap times, driver information, and circuit information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the fastest lap time recorded at the Austrian Grand Prix Circuit. This requires retrieving data from two related tables: one containing circuit information and the other containing lap times. The SQL query needs to filter the data to only include laps at the specified circuit and then sort the results to find the fastest lap time.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of lap records for circuits located in Italy. This requires retrieving data from two related tables: one containing circuit information and the other containing lap time records. The SQL query needs to filter the results to include only those circuits located in Italy.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _, _ HAVING _ = _"
    },
    {
        "query_intent": "The question is looking for the Formula 1 race in which the lap record for the Austrian Grand Prix Circuit was set. This requires identifying the race with the fastest lap time for the specified circuit. The SQL query needs to join the circuits and lap times tables, filter by the circuit's name, and sort by lap time in descending order, then limit the result to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the duration of the pit stop for the driver who set the lap record at the Austrian Grand Prix Circuit. This requires joining multiple tables to match the driver's lap time record with their pit stop duration.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the latitude and longitude coordinates of circuits where the lap record time is 1:29.488. This requires joining two tables: one containing circuit information and the other containing lap time records, and then filtering the results based on the lap time condition.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average time in milliseconds that Lewis Hamilton spent at a pit stop during Formula 1 races. This requires filtering the data to include only records associated with Lewis Hamilton and then calculating the average duration of his pit stops.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average lap time in milliseconds for all lap records set on various circuits in Italy. This requires aggregating lap times by circuit and then calculating the average of these aggregated values.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the player who has the highest overall rating, and it requires the player's API ID. This involves selecting data from a table, ordering the results by the overall rating in descending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the height of the tallest player and his name. This requires identifying the maximum height from the player data and retrieving the corresponding player name.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the preferred foot when attacking of the player who has the lowest potential. This requires identifying the player with the minimum potential and then retrieving their preferred foot when attacking.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of players who have an overall rating between 60 and 65 and are more likely to be involved in attacking moves rather than defensive moves. This requires filtering players based on their overall rating and their attacking work rate.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the top 5 players who have the highest crossing performance, and it requires identifying their player IDs. This involves sorting the players based on their crossing scores in descending order and selecting the top 5 results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = (SELECT _ FROM _) LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the league that had the highest average number of goals in the 2016 season. This requires calculating the average goals per match for each league in the specified season and then identifying the league with the highest average.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the home team that has lost the fewest matches in the 2016 season. This requires identifying teams that have lost matches and then selecting the one with the minimum number of losses.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the full names of the top 10 players who have the highest number of penalties, which requires joining two tables (`Player` and `Player_Attributes`), sorting the results by the number of penalties in descending order, and limiting the output to the top 10 results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the away team that won the most matches in the Scotland Premier League during the 2010 season. This requires identifying matches, counting wins, and determining the team with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the build-up play speeds of the top 4 teams that have the highest build-up play speeds. This requires sorting the teams by their build-up play speeds in descending order and selecting the top 4 results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the league that had the most matches end as a draw in the 2016 season. This requires identifying matches that ended as a draw, counting the occurrences for each league, and then selecting the league with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the age of players who have a sprint speed of at least 97 between the years 2013 and 2015. This requires filtering the data based on the sprint speed and date range, and then calculating the age by subtracting the birth year from the current year.",
        "sql_skeleton": "SELECT _ AS age FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the name of the league that has hosted the most matches of all time and the total number of matches played in that league. This requires identifying the league with the maximum number of matches and counting the matches for that league.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the average height of players who were born between the years 1990 and 1995. This requires filtering the data based on a date range and then computing the average of the height attribute.",
        "sql_skeleton": "SELECT _ FROM _ WHERE SUBSTRING(_, _, _) BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the player API IDs of players who had the highest overall ratings above the average overall rating in the year 2010. This requires calculating the average overall rating for the year 2010 and then finding the players whose overall ratings exceed this average.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the `team_fifa_api_id` of teams whose `buildUpPlaySpeed` attribute falls within the range of 50 to 60. This requires filtering the data based on a range of values and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the long names of teams that have a build-up play passing attribute above the average for the year 2012. This requires filtering data based on the date, calculating the average build-up play passing for that date, and then comparing each team's build-up play passing to this average.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ > (SELECT _ FROM _ WHERE _ = _)"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of players who prefer to use their left foot and were born between the years 1987 and 1992. This requires filtering players based on their birth year and preferred foot, counting the relevant players, and then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking to list the top 5 leagues in ascending order based on the total number of goals made in all seasons combined. This requires aggregating data from multiple seasons, counting goals, and then sorting the results.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the average value of the \"long_shots\" attribute for a player named Ahmed Samir Farag from the \"Player_Attributes\" table. This requires filtering the data by the player's name and then computing the average of the \"long_shots\" attribute.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the top 10 players' names whose heights are above 180, sorted in descending order of their average heading accuracy. This requires joining two tables, filtering, grouping, ordering, and limiting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of teams that have a normal build-up play dribbling class in 2014 and have less than the average chance creation passing. The results should be sorted in descending order of chance creation passing.  This requires filtering and joining data from multiple tables, calculating the average, and sorting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ < (SELECT _ FROM _) ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking for the names of leagues where the average number of goals scored by the home team is higher than the average number of goals scored by the away team, specifically for the 2009/2010 season. This requires calculating the average goals for both home and away teams and comparing them.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is asking for the short name of a football team by its long name. This requires querying a database to find a match between the long name and the short name of the team.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of football players who were born in October 1970. This requires filtering the data based on specific conditions for the birth month and year.",
        "sql_skeleton": "SELECT _ FROM _ WHERE SUBSTRING(_, _, _) = _ AND SUBSTRING(_, _, _) = _"
    },
    {
        "query_intent": "The question is looking for the attacking work rate of a specific football player named Franco Zennaro. To achieve this, we need to retrieve data from two related tables: one containing player information and the other containing player attributes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the team's freedom of movement in the first two-thirds of the pitch for the ADO Den Haag team. This requires retrieving specific data from a database by joining tables and filtering results based on team name and specific attributes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the finishing rate of a football player named Francois Affolter on a specific date, which requires retrieving data from two related tables: `Player` and `Player_Attributes`.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the overall rating of a football player named Gabriel Tamas for the year 2011. This requires filtering data by the player's name and the year, and then selecting the relevant attribute (overall rating).",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the total number of matches that took place in the 2015/2016 season within the Scottish Premier League. To achieve this, you need to join the `Match` and `League` tables, filter by season and league name, and count the matching records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the preferred foot when attacking of the youngest football player. This requires identifying the player with the latest birthday and then retrieving their preferred foot when attacking.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for a list of football players who have the highest potential score. This requires identifying the maximum potential score and then retrieving the names of all players who have that score.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the count of players who have a weight under 130 and prefer their left foot when attacking. This requires filtering the data based on conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is asking for a list of football teams that have a \"Risky\" chance creation passing class, and only their short names should be displayed. This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the defensive work rate of a football player named David Wilson. To achieve this, we need to retrieve data from two related tables: one containing player information and the other containing player attributes. The SQL query will need to join these tables based on a common key and filter the results by the player's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the birthday of the football player who has the highest overall rating. This requires joining two tables (`Player` and `Player_Attributes`), sorting the results by the overall rating in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the football league that is located in the Netherlands. This requires joining two tables: one containing country information and the other containing league information, and then filtering the results based on the country name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the average number of home team goals scored in matches that took place in the 2010/2011 season within the country of Poland. This requires filtering the data by season and country, and then computing the average of the home team goals.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the player with the highest average finishing rate, specifically comparing the average finishing rates of the tallest and shortest football players. This requires calculating averages and comparing them within a single SQL query.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _) OR _ = (SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ ASC LIMIT _)"
    },
    {
        "query_intent": "The question is asking to retrieve a list of player names whose height is greater than 180. This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the total number of players who were born after the year 1990. To achieve this, we need to count the number of records in the `Player` table where the `birthday` column is greater than '1990'.",
        "sql_skeleton": "SELECT _ FROM _ WHERE SUBSTRING(_, _, _) > _"
    },
    {
        "query_intent": "The question is looking for the count of players whose first names are \"Adam\" and have a weight greater than 170. This requires filtering the data based on conditions and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the names of players who had an overall rating greater than 80 between the years 2008 and 2010. This requires filtering data based on date and rating, joining tables to get player names, and grouping results to ensure distinct player names.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the potential score of a player named Aaron Doran. This requires retrieving data from two related tables: one containing player attributes and the other containing player information. The SQL query needs to filter the results by the player's name and join the two tables based on a common identifier.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique player names whose preferred foot is left. This requires filtering the data based on the `preferred_foot` attribute and selecting distinct values of the `player_name` attribute.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of teams that have a build-up play speed classified as \"fast\". This requires joining two tables (`Team` and `Team_Attributes`) and filtering the results based on a specific condition.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the \"buildUpPlayPassingClass\" attribute of the team identified by \"CLB\" in the `Team_Attributes` table. This requires filtering the data to find the specific team and then selecting the relevant attribute.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the short names of teams that have a build-up play passing attribute greater than 70. This requires filtering data from a table based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the average overall rating of players whose heights are greater than 170, specifically from the years 2010 to 2015. This requires filtering data based on conditions and calculating an average value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the football player with the shortest height, which requires identifying the minimum height and then retrieving the corresponding player's name. This involves using aggregate functions to find the minimum value and a subquery to filter the results.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the country where the league \"Italy Serie A\" is located. This requires joining two tables: one containing country information and the other containing league information, and then filtering the results based on the league name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for football teams that meet specific criteria regarding their build-up play speed, dribbling, and passing. The SQL query needs to filter and join tables to retrieve the short names of these teams.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the average overall rating of a football player named Aaron Doran. This requires calculating the average value from a specific column in a table where the player's name matches a given condition.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of matches that took place in the German league \"Germany 1. Bundesliga\" during the months of August to October 2008. This requires filtering matches by league name, date, and season, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the short names of football teams that had a home team goal of 10. This requires joining the `Team` and `Match` tables based on the team API ID and filtering the results where the home team goal is 10.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of football players who have the highest balance score and a potential score of 61. This requires filtering the players based on their potential score and then selecting the player with the highest balance score.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the difference between the average ball control scores of two specific players, Abdou Diallo and Aaron Appindangoye. This requires joining two tables (`Player` and `Player_Attributes`), filtering by player names, calculating the average ball control score for each player, and then finding the difference between these two averages.",
        "sql_skeleton": "SELECT _ AS diff FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the full name of a team whose short name is \"GEN\". This requires selecting specific data from a database table based on a condition.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking to compare the ages of two players, Aaron Lennon and Abdelaziz Barrada, and determine which one is older. This requires filtering the players by their names, sorting them by their birthdates, and then selecting the older one.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ OR _ = _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking for the player who has the maximum height. To achieve this, we need to retrieve the player's name and height from the database, sort the results by height in descending order, and select the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of players who have their preferred foot as the left foot when attacking and would remain in their position when the team is defending. This requires filtering and joining tables to match the conditions specified.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to identify the country associated with the \"Belgium Jupiler League\". This requires querying a database to match the league name with the country name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of leagues that are located in Germany. This requires joining two tables: one containing country information and the other containing league information, and then filtering the results based on the country name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the player who has the highest overall strength, which requires identifying the player with the maximum value in the `strength` attribute from the `Player_Attributes` table.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of players born before the year 1986 who have a high overall rating and prefer to maintain their position while the team attacks. This requires filtering players based on their birth year, overall rating, and work rate, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to determine which player among Alexis, Ariel Borysiuk, and Arouna Kone has the highest crossing score. This requires filtering players by name, joining tables to access crossing scores, sorting the results by crossing score in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _ OR _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the heading accuracy attribute of a player named Ariel Borysiuk. This requires retrieving data from two related tables: one containing player attributes and the other containing player information. The SQL query needs to join these tables based on a common identifier and filter the results by the player's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of players who have a height greater than 180 and a volley score greater than 70. This requires filtering and joining data from two tables: one containing player attributes and the other containing player details.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the names of players whose volley score and dribbling score are both greater than 70. This requires filtering records based on conditions and joining two tables to access the necessary data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of matches that took place in Belgium during the 2008/2009 season. This requires filtering matches by season and country, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the long passing score of the player who is the oldest in terms of age. This requires joining two tables, sorting the results by birthdate in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the total number of matches that took place in the Belgium Jupiler League during April 2009. To achieve this, we need to filter the matches by league name and date, and then count the number of matching records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the league that had the most matches in the 2008/2009 season. This requires counting the number of matches for each league and then identifying the league with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average overall rating of players who were born before the year 1986. This requires filtering players based on their birth year and then calculating the average of their overall ratings.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE SUBSTRING(_, _, _) < _"
    },
    {
        "query_intent": "The question is looking for the percentage difference in overall ratings between two specific players, Ariel Borysiuk and Paulin Puel. This requires calculating the percentage increase of Ariel Borysiuk's overall rating over Paulin Puel's overall rating.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average build-up play speed of the Heart of Midlothian team, which requires aggregating data from multiple related tables. The SQL query needs to filter the data by the team's name, join tables to access the necessary attributes, and calculate the average.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the average overall rating of a specific player, Pietro Marino. This requires retrieving data from two related tables (Player and Player_Attributes) and performing an aggregate calculation.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the total crossing score of a player named Aaron Lennox. This requires aggregating data from multiple records that are associated with this player.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the highest chance creation passing score and its corresponding classification for the team named Ajax. This requires identifying the relevant columns and tables, sorting the data to find the maximum value, and ensuring that the results are distinct.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to determine the preferred foot of a football player named Abdou Diallo. This requires querying a database to find the foot preference associated with the player's name.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the maximum overall rating from the player named Dorlan Pabon. This requires joining two tables (`Player` and `Player_Attributes`), filtering by the player's name, and then finding the highest rating.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average number of goals scored by Parma when they are the away team in Italy. This requires filtering matches by the away team and the country, then calculating the average of the away team's goals.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the oldest player who had a specific overall rating on a particular date. This requires filtering the data based on the date and overall rating, joining tables to get the player names, and then sorting the results to find the oldest player.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY SUBSTRING(_, -_, _) DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the overall rating of a specific player, Aaron Mooy, on a specific date, 2016/2/4. This requires joining two tables: one containing player information and the other containing player attributes, and then filtering the results based on the player's name and the date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the potential attribute of a player named Francesco Parravicini on a specific date (2010/8/30). To achieve this, we need to retrieve data from two related tables: one containing player attributes and the other containing player information. The SQL query will need to join these tables based on a common key and filter the results by the player's name and the specified date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the attacking work rate of a specific player, Francesco Migliore, on a specific date, 2015/5/1. This requires retrieving data from two related tables: one containing player attributes and the other containing player details. The SQL query needs to join these tables based on a common key and filter the results by the player's name and the specific date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the defensive work rate of a specific player, Kevin Berigaud, on a specific date, 2013/2/22. This requires joining two tables: one containing player attributes and the other containing player information, and then filtering the results based on the player's name and the date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the earliest date on which Kevin Constant had the highest crossing score. This requires identifying the maximum crossing score for Kevin Constant and then finding the earliest date associated with that score.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the build-up play speed class of the team \"Willem II\" on a specific date (2011/2/22). To achieve this, we need to join two tables: one containing team information and the other containing team attributes, and then filter the results based on the date and team name.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the build-up play dribbling class of the team \"LEI\" on a specific date (2015/9/10). To achieve this, we need to filter the data based on the team name and date, and then select the relevant attribute.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the \"build Up play passing class\" for the football team \"FC Lorient\" on a specific date, \"2010/2/22\". To achieve this, you need to retrieve data from two related tables: one containing team information and the other containing team attributes.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the chance creation passing class of the team \"PEC Zwolle\" on a specific date, 2013/9/20. To achieve this, you need to join two tables: one containing team information and the other containing team attributes, and then filter the results based on the date and team name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the chance creation crossing class of \"Hull City\" on a specific date (2010/2/22). This requires joining two tables: one containing team information and the other containing team attributes, and filtering the results based on the team name and date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the defence aggression class of the team \"Hannover 96\" on a specific date, 2015/9/10. This requires retrieving data from two related tables: one containing team information and the other containing team attributes. The SQL query needs to filter the data based on the team name and the date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the average overall rating of a specific player, Marko Arnautovic, within a specified date range. This requires filtering the data by the player's name and date range, and then calculating the average overall rating.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage difference in overall ratings between two players, Landon Donovan and Jordan Bowery, on a specific date (2013/7/12). This requires calculating the difference in their ratings and then expressing it as a percentage of Jordan Bowery's rating.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ OR _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the names of the tallest players from a database. This requires selecting specific columns from a table, ordering the results by height in descending order, and limiting the output to the top result.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the player API IDs of the 10 heaviest players from a database. This requires selecting specific data, ordering it by weight in descending order, and limiting the results to the top 10 entries.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for a list of player names who are 35 years old or older. This requires filtering players based on their age and selecting their names.",
        "sql_skeleton": "SELECT _ FROM _ WHERE SUBSTRING(_, _, _) > _"
    },
    {
        "query_intent": "The question is looking to count the number of goals scored by a specific player (Aaron Lennon) while playing as the home team. This requires joining the `Player` and `Match` tables and filtering the results based on the player's name and their role as the home team's player.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the total number of goals scored by the away team when both Daan Smith and Filipe Ferreira are playing. This requires summing up the goals scored by each player and then adding those sums together.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ OR _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the total number of goals scored by home team players who are 30 years old and below. This requires filtering players based on their age and then summing up the goals they scored.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking for the name of the player with the highest overall rating. This requires selecting data from a database, joining two tables, sorting the results by the overall rating in descending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the player who has the highest potential, which involves joining two tables, filtering, sorting, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of players who tend to be attacking when their teammates are making attacking moves. This requires identifying players with a high attacking work rate and their mates having a high attacking work rate. The SQL query needs to filter and join tables to achieve this.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the oldest player who has a finishing rate of 1. This requires filtering the players based on their finishing rate, sorting them by their birthdate in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY SUBSTRING(_, _, STR_POSITION(_, _) - _) DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the names of players who were born in Belgium. This requires filtering players based on their birth country and selecting their names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for players who have a vision score of 90 or above and are from a country where at least one player meets this criterion. This requires joining multiple tables to filter and aggregate data.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the country whose players have the heaviest average weights. This requires calculating the average weight of players from each country and then identifying the country with the highest average weight.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the long names of teams that have a slow build-up play speed. This requires filtering the teams based on their build-up play speed class and selecting the relevant long names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the short names of teams that have a specific defensive attribute (playing safe) and a chance creation passing attribute (passing). This requires filtering and joining data from two tables: `Team` and `Team_Attributes`.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the average height of players from Italy. To achieve this, we need to join two tables: one containing country information and the other containing player information, and then calculate the average height for players from Italy.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the names of the top three football players who are taller than 180 cm, sorted in alphabetical order. This requires filtering the data based on height, selecting the top results, and ordering the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ ORDER BY _ LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of football players born after the 1990s who have the first name \"Aaron\". This requires filtering players based on their birth year and first name, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE SUBSTRING(_, _, _) > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the difference between the jumping scores of two specific players (players 6 and 23) from a dataset. This requires retrieving data from a table and performing an arithmetic operation.",
        "sql_skeleton": "SELECT _ AS DIFFERENCE FROM _"
    },
    {
        "query_intent": "The question is looking for the top five football players who have the lowest potential ratings and prefer to use their right foot when attacking. This requires filtering players based on their attacking work rate and sorting them by their potential in ascending order.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = (SELECT _ FROM _) LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of players who have the highest potential score for crossing and prefer to use their left foot while attacking. This requires filtering players based on their preferred foot and sorting them by their crossing potential in descending order, then selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of players whose strength and stamina scores are both more than 80. This requires filtering the data, counting the relevant records, and calculating the percentage relative to the total number of records.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the country where the Poland Ekstraklasa league took place. This requires joining two tables: one containing country information and the other containing league information, and then filtering the results to find the specific league.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the final score of a specific match that took place on September 24, 2008, within the Belgian Jupiler League. This requires joining tables that contain match details and team information, filtering by date and league name, and calculating the difference between the home and away team goals.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for specific player attributes (sprint speed, agility, and acceleration) for a player named Alexis Blin. To achieve this, we need to join two tables (`Player` and `Player_Attributes`) based on a common identifier (`player_api_id`) and filter the results by the player's name.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to determine the build-up play speed class of the KSV Cercle Brugge team. This requires filtering the data to find the team by its long name and then selecting the corresponding build-up play speed class.",
        "sql_skeleton": "SELECT DISTINCT CASE WHEN _ = _ THEN _ WHEN _ = _ THEN _ ELSE _ END FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the total number of games played in the 2015-2016 season within the Italian Serie A league. This requires counting the matches that took place in that specific league and season.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the maximum score achieved by the home team in matches from the Netherlands Eredivisie league. To achieve this, we need to filter the data to include only matches from the specified league and then find the highest home team score.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the finishing rate and curve score of the player who has the heaviest weight. This requires joining two tables (`Player` and `Player_Attributes`), sorting the results by weight in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the top 4 leagues that had the most games in the 2015-2016 season. This requires counting the number of games for each league and then selecting the top 4 leagues with the highest counts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the full name of the away team that has scored the highest number of goals in a match. This requires identifying the team with the maximum goals scored and retrieving its full name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE NOT _ IS NULL ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of a player who has the highest overall strength. This requires identifying the player with the maximum value in the `strength` attribute and then retrieving their name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the percentage of players under 180 cm in height who have an overall strength of more than 70. This requires filtering the data based on height and strength, counting the relevant records, and calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking to compare the number of male in-patients to the number of male out-patients and calculate the percentage deviation between these two groups. This requires counting the male patients in both categories and then calculating the difference in percentages.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of female patients who were born after the year 1930. This requires filtering the data based on the birth year and gender, counting the relevant records, and then calculating the percentage of these records out of the total number of female patients.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the percentage of patients born between the years 1930 and 1940 who were inpatients. This requires filtering patients based on their birth year, counting the number of inpatients, and calculating the percentage of inpatients out of the total number of patients in the specified birth year range.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the ratio of patients diagnosed with 'SLE' who received outpatient to inpatient followed-up treatment. This requires counting the number of outpatient and inpatient cases and then calculating their ratio.",
        "sql_skeleton": "SELECT _ AS RATIO FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the diagnosis of a specific patient (ID '30609') and a list of all dates of laboratory tests conducted for this patient. This requires retrieving data from two related tables: one containing patient information and the other containing laboratory test results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for specific details (sex, birthday) of a patient with a given ID ('163109') and also requires the date of the examination and the symptom associated with that patient. This involves retrieving data from two related tables: `Patient` and `Examination`.",
        "sql_skeleton": "SELECT _, _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the patient ID, sex, and birthday of patients whose LDH levels are beyond the normal range. This requires joining two tables (Patient and Laboratory) and filtering the results based on the LDH value.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the ID and age of patients who have a positive degree of coagulation. This requires filtering patients based on their coagulation status and calculating their age from their birthdate.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the ID, sex, and diagnosis of patients who have a severe degree of thrombosis. This requires filtering patients based on their thrombosis severity and retrieving specific columns from the patient data.",
        "sql_skeleton": "SELECT DISTINCT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of patients born in 1937 whose total cholesterol levels are above the normal range. This requires filtering patients based on their birth year and cholesterol levels, and joining patient data with laboratory results.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is asking to retrieve the ID, sex, and diagnosis of patients who have an albumin level lower than 3.5. This requires joining two tables (Patient and Laboratory) based on a common identifier (ID), filtering the results based on the albumin level, and selecting specific columns.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of female patients whose total protein levels are not within the normal range. This requires filtering the data based on gender and protein levels, counting the relevant cases, and then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < _ OR _ > _"
    },
    {
        "query_intent": "The question is looking to calculate the average concentration of anti-cardiolipin antibody (IgG) for in-patients who are 50 years or older. This requires filtering patients based on age and their admission status, and then computing the average value of the relevant antibody concentration.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of female patients who visited the hospital in 1997 and were immediately followed up at the outpatient clinic. This requires filtering patients by gender, year of admission, and admission type.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the age of the youngest patient when they initially arrived at the hospital. This requires calculating the difference between the arrival date and the birth date for each patient and then finding the minimum of these differences.",
        "sql_skeleton": "SELECT _ AS AGE FROM _ WHERE NOT _ IS NULL"
    },
    {
        "query_intent": "The question is looking to count the number of female patients who had the most serious thrombosis cases and were examined in the year 1997. This requires filtering data based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the age difference between the youngest and oldest patient who has a normal triglyceride level. This involves filtering patients based on their triglyceride levels, calculating their ages, and then finding the difference between the minimum and maximum ages.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ <= _"
    },
    {
        "query_intent": "The question is looking for the symptoms and diagnosis of the youngest patient who has ever undergone a medical examination. This requires identifying the youngest patient based on their birthdate and then retrieving their symptoms and diagnosis.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE NOT _ IS NULL ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the average number of male patients tested in the lab each month for the year ending December 31, 1998. This requires filtering patients by gender, counting them, and then calculating the average count per month.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ <= _"
    },
    {
        "query_intent": "The question is looking for the date when the medical laboratory work was completed for the oldest patient diagnosed with SJS and the age of the patient at the time of their initial hospital admission. This requires identifying the patient with the earliest birthdate who has been diagnosed with SJS and then calculating their age at the time of the first hospital admission.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the ratio of male to female patients who have abnormal uric acid counts. This requires filtering patients based on their uric acid levels, counting the number of male and female patients, and then calculating the ratio.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have not undergone a medical examination at least one year after their initial hospital visit. This requires filtering patients based on their first date of admission and the examination date, and then counting those who meet the criteria.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of underage patients who were examined over a three-year period from 1990 to 1993. This requires filtering patients based on their age at the time of examination and counting the occurrences within the specified date range.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ < _"
    },
    {
        "query_intent": "The question is looking to count the number of male patients who have an elevated total bilirubin count. This requires filtering the data based on gender and bilirubin levels, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the most common illness identified among patients whose lab work was done within a specific date range (1985-01-01 to 1995-12-31). This requires identifying the diagnosis with the highest frequency during this period.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average age of patients who were examined in the laboratory during October 1991. To achieve this, we need to calculate the age of the patients as of the year 1999 and then find the average of those ages. This involves joining two tables: one containing patient information and the other containing examination information, filtering by the examination date, and calculating the age difference.",
        "sql_skeleton": "SELECT _ AS avg_age FROM _ JOIN _ ON _ = _ WHERE SUBSTRING(_, _, _) = _ AND SUBSTRING(_, _, _) = _"
    },
    {
        "query_intent": "The question is looking for the age of the patient who had the highest hemoglobin count at the time of the examination and the doctor's diagnosis. This requires calculating the age from the birthdate, joining patient data with laboratory data, sorting by hemoglobin count in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the anti-nucleus antibody (ANA) concentration level for a specific patient on a specific date. To achieve this, we need to retrieve data from a database table where the patient ID and examination date match the specified values.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to determine if the total cholesterol level for a specific patient on a specific date is within the normal range. This requires filtering the data based on patient ID and date, and then checking the cholesterol level against a predefined threshold.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the gender of the first patient diagnosed with AORTITIS. This requires filtering the patients by diagnosis, sorting them by their first diagnosis date, and selecting the gender of the earliest patient.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the anti-Cardiolipin antibody concentration status of a specific patient on a particular date. The patient in question was diagnosed with SLE on a specific date and the concentration status is needed for another specific date. The SQL query needs to join two tables (`Patient` and `Examination`) based on the patient's ID and filter the results based on the diagnosis date and the date for which the concentration status is required.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to identify whether a patient was male or female based on their ALT glutamic pyruvic transaminase (ALT) status being 9 on a specific date (1992-06-12). The SQL query needs to filter records based on these conditions and return the gender of the patient.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the age of a patient at the time of a specific laboratory test, given the uric acid level result. This requires joining patient information with laboratory test results and calculating the age based on the birthdate and the test date.",
        "sql_skeleton": "SELECT _ AS age FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of laboratory tests performed in 1995 for a specific patient who first visited the hospital on June 13, 1991, and has a diagnosis of SJS. This requires joining patient and laboratory data, filtering by the patient's first visit date and diagnosis, and counting the laboratory tests within a specific year.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the original diagnosis of a patient who was diagnosed with SLE on a specific date (1997/1/27). This requires retrieving data from two related tables: one containing patient information and the other containing examination results. The SQL query needs to filter records based on the diagnosis date and join the tables on a common patient ID.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the symptoms of a patient who had their birthday in 1959 and underwent an examination on September 27, 1993. This requires joining two tables (`Patient` and `Examination`) based on a common identifier (`ID`), filtering the results by the patient's birthday and the examination date, and selecting the distinct symptoms.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage decrease in the patient's total cholesterol from November to December 1981, specifically for the patient born on February 18, 1959. This requires calculating the difference in total cholesterol levels between the two months and then expressing that difference as a percentage of the November value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for a list of unique patient IDs who were diagnosed with Behcet's and had their examinations conducted within a specific date range (from January 1, 1970, to December 31, 1997). The SQL query needs to filter records based on these conditions and ensure that only distinct patient IDs are returned.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the IDs of patients who were examined within a specific date range (1987-07-06 to 1996-01-31) and have a GPT level greater than 30 and an ALB level less than 4. This requires filtering and joining data from two tables: `Patient` and `Laboratory`.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ > _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the number of female patients born in 1964 who were admitted to the hospital and requires listing their IDs. This involves filtering patients based on their birth year, admission status, and gender, and then counting and listing the matching IDs.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of patients who meet specific criteria: a thrombosis level of 2, an ANA pattern of only S, and an anti-Cardiolipin antibody (IgM) level that is 20% higher than the average. This requires filtering and joining tables, calculating averages, and conditional counting.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ > _ * (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the percentage of patients whose proteinuria levels are within the normal range and whose uric acid levels are below the normal range. This requires filtering, joining tables, and calculating a percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of male patients who first presented to the hospital in 1981 and were diagnosed with BEHCET. This requires filtering the data based on specific conditions and then calculating the percentage of those who meet both criteria.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique patient IDs who were followed up at the outpatient clinic, underwent a laboratory test in October 1991, and had a total blood bilirubin level within the normal range. This requires filtering and joining data from two tables: one containing patient information and the other containing laboratory test results.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _ AND _ <= _"
    },
    {
        "query_intent": "The question is looking to count the number of female patients born between 1980 and 1989, excluding those with the 'P' ANA pattern. This requires filtering the data based on specific conditions and then counting the remaining records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking for the sex of a patient who meets specific medical and laboratory criteria. This involves joining two tables (Patient and Laboratory) based on a common ID and filtering the results based on conditions related to diagnosis, C-reactive protein levels, creatinine levels, and LDH levels.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the average blood albumin levels of female patients who have been diagnosed with SLE and have a platelet count greater than 400. This requires filtering patients based on their gender, diagnosis, and platelet count, and then calculating the average blood albumin levels for these filtered patients.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the most frequently occurring symptom among patients diagnosed with SLE (Systemic Lupus Erythematosus) disease. This requires identifying the symptom with the highest count of occurrences.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the date when the medical information of a specific patient (ID 48473) was first documented and the diagnosis associated with that patient. This requires retrieving specific columns from a database table where a condition is met.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of female patients who have been diagnosed with Antiphospholipid Syndrome (APS). This requires filtering patients by gender and diagnosis, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of unique patients who underwent testing in 1997 and had protein levels (specifically, ALB, UA, UN) outside the normal range. This requires filtering data based on specific conditions and counting distinct patient IDs.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _ AND _ > _ OR _ < _"
    },
    {
        "query_intent": "The question is looking for the percentage of patients who had signs of thrombocytopenia and were diagnosed with Systemic Lupus Erythematosus (SLE). This requires filtering patients based on thrombocytopenia and SLE diagnosis, then calculating the proportion of those diagnosed with SLE.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of female patients who were born in 1980 and diagnosed with RA. This requires filtering the data based on specific conditions and then performing a calculation to determine the percentage of women within that filtered dataset.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of male patients who were tested between 1995 and 1997, diagnosed with Behcet disease, and did not stay in the hospital for treatment. This requires filtering and joining data from multiple tables.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of female patients whose white blood cell (WBC) count is below 3.5. This requires filtering based on gender and WBC count, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking to calculate the time difference between the patient's first arrival at the hospital and the start of their evaluation. This requires joining two tables (`Patient` and `Examination`) based on a common identifier (`ID`) and then computing the difference between two specific dates.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to determine if the uric acid level of a specific patient (ID 57266) falls within a normal range. This requires filtering the data based on the patient's ID and checking the uric acid value against a predefined normal range.",
        "sql_skeleton": "SELECT CASE WHEN _ BETWEEN _ AND _ THEN _ ELSE _ END FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the specific dates when a patient identified by '48473' had a laboratory examination where their AST (GOT) index was above the normal range. This requires filtering the data based on the patient's ID and the GOT value, and then selecting the relevant date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of patients, including their sex and date of birth, who have a GOT index within the normal range during the laboratory examination in 1994. This requires filtering the data based on specific conditions and joining two tables to get the necessary information.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of male patients whose ALT glutamic pyruvic transaminase (GPT) levels are above the normal range. This requires filtering the data based on gender and GPT levels, and then selecting the relevant IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the diagnosis of patients whose ALT (glutamic pyruvic transaminase) levels are above the normal range, sorted by their date of birth in ascending order. This requires joining patient information with laboratory results, filtering based on ALT levels, and ordering the results by birth date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ ORDER BY _ ASC"
    },
    {
        "query_intent": "The question is looking for the average value of the lactate dehydrogenase (LDH) levels in patients whose LDH levels are within the normal range. This requires filtering the data to include only those with normal LDH levels and then calculating the average of the filtered data.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the ID and age of patients whose lactate dehydrogenase (LDH) levels fall within the range of 100 to 300 units above the normal range. This requires filtering the data based on a condition and selecting specific columns.",
        "sql_skeleton": "SELECT _, CAST((_) AS INT) FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking to determine the treatment status (inpatient or outpatient) of patients whose alkaline phosphatase (ALP) levels are within the normal range. This requires filtering patients based on their ALP levels and then checking their treatment status.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the ID of a patient born on April 1st, 1982, and whether their alkaline phosphatase (ALP) levels are within the normal range. This requires joining two tables: one containing patient information and the other containing laboratory results. The query needs to filter records based on the birthdate and check the ALP levels against a specific threshold.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the ID, sex, and date of birth of patients whose total protein (TP) levels are below the lower range of the normal index. This requires filtering data based on a condition and selecting specific columns from two related tables.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking for the deviation of the total protein (TP) index from the normal for all female patients whose total protein levels are beyond the normal index. This requires filtering patients by sex and TP levels, calculating the deviation from the normal TP index, and then computing the standard deviation of these deviations.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to sort all male patients by their birthday in descending order, but only include those whose albumin levels are not within a specified range. This requires filtering, joining tables, and sorting.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _ OR _ > _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking to determine if the albumin levels of patients born in 1982 are within the normal range. This requires filtering patients by birth year, joining patient records with laboratory results, and comparing albumin levels to a specified range.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of female patients whose uric acid (UA) levels are beyond the normal range. This requires filtering the data based on gender and UA levels, counting the relevant records, and then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the average uric acid (UA) index for all patients who have normal UA levels, considering their latest laboratory examination results. This requires filtering patients based on their UA levels and then calculating the average UA index for those patients.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the ID, sex, and birthday of patients whose urea nitrogen (UN) levels are within a specified borderline range (between 10 and 25). This requires filtering records based on a range of values and selecting specific columns from a joined table.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the ID, sex, and birthday of patients who have been diagnosed with 'RA' and have a UN value within the normal index. This requires filtering and joining data from two tables: one containing patient information and the other containing laboratory results.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the count of male patients who have a creatinine index that is out of the normal range. This requires filtering patients based on their sex and the creatinine index, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to determine if there is a difference in the number of male and female patients who have creatinine levels outside the normal range. This requires filtering patients based on their creatinine levels and comparing the counts of male and female patients in this filtered group.",
        "sql_skeleton": "SELECT CASE WHEN _ > _ THEN _ ELSE _ END AS TOrF FROM _ JOIN _ ON _ = _ WHERE _ > _ OR _ < _"
    },
    {
        "query_intent": "The question is looking for the highest total bilirubin level recorded in the laboratory and the corresponding patient details (ID, sex, and birthday) associated with that reading. This requires identifying the maximum value in the total bilirubin column and then retrieving the relevant patient information.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking to list and group all patients by their sex who have a total bilirubin (T-BIL) level that is not within the normal range. This requires filtering patients based on their T-BIL levels and then grouping them by their sex.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ > _ OR _ < _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the oldest patient (based on birthdate) who has the highest total cholesterol (T-CHO) level. This requires joining two tables (Patient and Laboratory), filtering, sorting, and selecting specific columns.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC, _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the average age of male patients who have high cholesterol levels. This requires filtering the data based on gender and cholesterol levels, and then computing the average age.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of patients along with their diagnoses, where the triglyceride (TG) index is greater than 100 of the normal range. This requires joining patient data with laboratory results and filtering based on the TG index.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have a triglyceride (TG) level above the normal range and are older than 50 years. This requires filtering patients based on their TG levels and age, and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for a list of unique patient IDs who are outpatients and have their creatinine phosphokinase (CPK) levels within the normal range. This requires filtering based on admission status and CPK values, and then selecting distinct IDs.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking to count the number of male patients born between 1936 and 1956 who have creatinine phosphokinase (CPK) levels beyond the normal range. This requires filtering patients based on their birth year, gender, and CPK levels, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the ID, sex, and age of patients whose blood glucose levels are not within the normal range but have total cholesterol levels within the normal range. This requires filtering and joining data from two tables: `Laboratory` and `Patient`.",
        "sql_skeleton": "SELECT _, _, CAST((_) AS FLOAT) / _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for a list of unique patient IDs along with their blood glucose (GLU) levels, specifically for those patients whose first recorded data was in the year 1991. This requires filtering the data based on the year of the first recorded date and ensuring that the blood glucose levels are within a normal range.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for a list of patient IDs, their sex, and their birthdays, grouped by sex, where the white blood cell count is abnormal. The results should be sorted by the patients' ages in ascending order.  To achieve this, we need to:  1. Filter the records where the white blood cell count is above or below a certain threshold (considering it as abnormal). 2. Join the relevant tables to get the patient's sex and birthday. 3. Group the results by sex. 4. Order the results by the patients' ages in ascending order.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ > _ OR _ < _ GROUP BY _ ORDER BY SUBSTRING(_, _, _) + SUBSTRING(_, _, _) + SUBSTRING(_, _, _) ASC"
    },
    {
        "query_intent": "The question is looking for the diagnosis, ID, and age of patients who have a lower red blood cell (RBC) count compared to the average RBC count. This requires filtering based on a condition and joining two tables to get the necessary information.",
        "sql_skeleton": "SELECT DISTINCT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking for female patients aged 50 and above who have an abnormal red blood cell (RBC) count. The query needs to filter patients based on their age, gender, and RBC count, and then determine if they were admitted to the hospital.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for a list of unique IDs and their corresponding sexes for outpatients who have a low hemoglobin level. This requires filtering outpatients with hemoglobin levels below a certain threshold and then retrieving their IDs and sexes.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the patient diagnosed with SLE who has the highest age and a normal hemoglobin level. The SQL query needs to filter patients by diagnosis, join patient information with laboratory results, ensure hemoglobin levels are within a normal range, sort the results by age in descending order, and limit the result to the oldest patient.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the ID and age of patients who have had two or more laboratory examinations where their hematocrit (HCT) level exceeded the normal range. This requires joining patient data with laboratory results, filtering based on HCT levels, and counting the number of qualifying laboratory results per patient.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ < _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the average hematocrit (HCT) level from laboratory examinations conducted in 1991, specifically for values that are lower than the normal range. This requires filtering the data based on the year and the HCT level, and then calculating the average of the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ < _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to determine the number of patients with platelet levels below the normal range and compare it to the number of patients with platelet levels above the normal range. This requires filtering patients based on their platelet levels and counting the occurrences in each category.",
        "sql_skeleton": "SELECT _ AS lower, _ AS higher FROM _ JOIN _ ON _ = _ WHERE _ < _ OR _ > _"
    },
    {
        "query_intent": "The question is looking for a list of patients who are below 50 years old and had laboratory examinations taken in 1984 with normal platelet levels. This requires filtering patients based on age, date of examination, and platelet levels, and then joining relevant tables to get the necessary information.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the percentage of female patients older than 55 years who have an abnormal prothrombin time (PT). This requires filtering patients based on age and gender, counting the total number of patients, and counting those with abnormal PT values, then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for a list of unique patient IDs who visited the hospital for the first time after the year 1992 and have a normal prothrombin time (PT) level. This requires filtering and joining data from two tables: `Patient` and `Laboratory`.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the count of examinations conducted after January 1, 1997, where the result of the inactivated partial prothrombin time (PT) is greater than 1.5 times the control (KCT). This requires filtering the data based on the examination date and the PT result, and then counting the relevant records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have an abnormal activated partial prothrombin time (APTT) and do not have thrombosis. This requires filtering patients based on their APTT values and thrombosis status, and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of male patients who have a normal white blood cell count but an abnormal fibrinogen level. This requires filtering based on gender, white blood cell count, and fibrinogen level, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who were born after January 1, 1980, and have an abnormal fibrinogen level. This requires filtering patients based on their birth year and checking their fibrinogen levels.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the disease names of patients who have a proteinuria level higher than normal. This requires joining patient and laboratory data, filtering based on proteinuria levels, and selecting distinct disease names.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the patient ID of patients who have a normal proteinuria level and are diagnosed with SLE. This requires filtering based on specific conditions and joining two tables: one containing patient information and the other containing laboratory results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the count of unique patients whose IgG levels are higher than normal. This requires filtering the data based on the IgG levels and then counting the distinct patient IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of unique patients who have a normal IgG level and also have symptoms. This requires filtering patients based on their IgG levels and the presence of symptoms, and then counting the distinct patient IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the diagnosis of the patient who has the highest IgA levels within the normal range. This requires identifying the patient with the highest IgA value and then retrieving their diagnosis.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of patients who have a normal Ig A level and were admitted to the hospital after January 1, 1990. This requires filtering patients based on their Ig A levels and admission date, and then counting the number of such patients.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the most common disease diagnosis among patients who have an abnormal IgM level. This requires filtering patients based on their IgM levels, grouping the results by diagnosis, and then identifying the most frequent diagnosis.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the count of patients who have an abnormal C-reactive protein (CRP) level and do not have their data recorded in the description field. This requires filtering based on CRP levels and checking for null or empty descriptions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ IS NULL"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have an abnormal creatinine level and are under the age of 70. This requires filtering patients based on their creatinine levels and their age, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the count of patients who have a normal Rheumatoid Factor (RF) and a positive measure of the degree of coagulation (LAC). This requires filtering and joining data from two tables: one containing patient information and the other containing laboratory results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of diseases for patients who were born after January 1, 1985, and have a normal Rheumatoid Factor (RF). This requires filtering patients based on their birthdate and RF levels, and then retrieving their diagnoses.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of patients who have a normal RF level and are older than 60 years. This requires filtering patients based on their age and RF level, and then retrieving their IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have a normal Rheumatoid Factor (RF) and do not have thrombosis. This requires filtering and joining data from two tables: `Patient` and `Examination`.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have a normal level of complement 3 and exhibit a 'P' pattern in their ANA examination. This requires filtering and joining data from two tables: one containing patient information and the other containing examination results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the ID of the patient with the highest anti-Cardiolipin antibody concentration among those who have a hematocrit (HCT) level that is not within the normal range. This requires filtering patients based on their HCT levels, sorting them by their anti-Cardiolipin antibody concentrations in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have blood clots in veins and have a normal level of complement 4 (C4). This requires filtering patients based on their diagnosis and C4 levels, and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have a normal level of anti-ribonuclear protein (RNP) and have been admitted to the hospital. This requires filtering patients based on their RNP levels and admission status.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the youngest patient who has an abnormal anti-ribonuclear protein (RNP) level, specifically their date of birth. This requires filtering patients based on their RNP levels, joining relevant tables, and sorting the results to find the youngest patient.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of unique patients who have normal anti-SM levels and do not have thrombosis. This requires filtering the data based on specific conditions and counting distinct patient IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the IDs of the three youngest patients who have an abnormal anti-SM result. This requires filtering patients based on their anti-SM test results and then sorting them by their birthdate to find the youngest ones.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the IDs of patients who underwent an examination after January 1, 1997, and had a normal anti-scl70 result. This requires filtering records based on the examination date and anti-scl70 value, and then joining tables to get the patient IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of female patients who have a normal anti-scl70 level and do not exhibit any symptoms. This requires filtering patients based on their gender, anti-scl70 levels, and symptoms, and then counting the resulting set of patients.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ IS NULL"
    },
    {
        "query_intent": "The question is looking to count the number of unique patients who have a normal anti-SSA result and visited the hospital before the year 2000. This requires filtering records based on the anti-SSA result and the hospital visit date, and then counting distinct patient IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the ID of the first patient who has an abnormal anti-SSA result and has come to the hospital. This requires identifying the earliest record that meets these criteria.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have a normal anti-SSB result and are diagnosed with Systemic Lupus Erythematosus (SLE) during the examination. This requires filtering and joining data from two tables: one containing examination results and the other containing patient information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have normal anti-SSB levels and have other symptoms observed during their examination. This requires filtering patients based on their anti-SSB levels and their symptoms, and then counting the number of matching records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ <> _"
    },
    {
        "query_intent": "The question is looking to count the number of male patients who have normal levels of anti-centromere and anti-SSB. This requires filtering patients based on their gender and laboratory results, and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of diseases diagnosed in patients who have an abnormal level of anti-DNA. This requires joining two tables (Patient and Examination) based on a common identifier (ID), filtering the results where the anti-DNA level is above a certain threshold, and grouping the results to eliminate duplicates.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have a normal anti-DNA level and whose data are not recorded. This requires filtering based on the anti-DNA level and checking for missing or null values in the relevant fields.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of unique patients who have a normal level of IGG and have been admitted to the hospital. This requires filtering patients based on their IGG levels and admission status, and then counting the distinct patient IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the percentage of patients who have an abnormal level of glutamic oxaloacetic transaminase (GOT) and are diagnosed with Systemic Lupus Erythematosus (SLE). This requires filtering patients based on their diagnosis and GOT levels, counting the relevant cases, and calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking to count the number of male patients whose glutamic oxaloacetic transaminase (GOT) levels are within the normal range. This requires filtering the data based on gender and GOT levels, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the birthdate of the youngest patient who has an abnormal level of glutamic oxaloacetic transaminase (GOT). This requires filtering patients based on their GOT levels, sorting them by birthdate in ascending order, and selecting the earliest birthdate.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the birthdays of the top three patients who have the highest levels of glutamic pyruvic transaminase (GPT) within the normal range. This requires filtering the data to include only those with GPT levels between 0 and 50, sorting these results in descending order, and limiting the output to the top three entries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of male patients who have a normal glutamic pyruvic transaminase (GPT) level. This requires filtering patients based on their gender and GPT levels, and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the earliest recorded date for the patient who has the highest lactate dehydrogenase (LDH) value within the normal range. This requires identifying the patient with the maximum LDH value and then finding their first recorded date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the latest recorded medical data of a patient who has an abnormal level of lactate dehydrogenase (LDH). This requires identifying the patient with the highest LDH value and then retrieving their latest recorded medical data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the count of patients who have an abnormal alkaline phosphatase (ALP) level and are admitted to the hospital. This requires filtering patients based on their ALP levels and admission status, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who are followed at an outpatient clinic and have a normal level of alkaline phosphatase (ALP). This requires filtering patients based on their admission status and their ALP levels.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ <= _"
    },
    {
        "query_intent": "The question is looking for the diagnoses of patients whose total protein levels are below the normal range. This requires filtering the data based on a condition and joining two tables to retrieve the necessary information.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking to count the number of patients diagnosed with Stevens-Johnson Syndrome (SJS) who have a normal level of total protein. This requires filtering patients based on their diagnosis and then checking their total protein levels.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the examination date of the patient who has the highest albumin level within the normal range. This requires filtering out albumin levels that are outside the normal range and then finding the maximum value among the remaining ones.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of male patients whose levels of albumin (ALB) and total protein (TP) are within the normal range. This requires filtering based on gender and specific laboratory results, and then counting the filtered records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the anti-cardiolipin antibody concentration of the female patient who has the highest uric acid level within the normal range. This requires filtering patients based on gender and uric acid levels, joining relevant tables, and sorting the results to find the maximum value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the highest anti-nucleus antibody (ANA) concentration level from patients who have a normal creatinine level. This requires filtering patients based on their creatinine levels and then finding the maximum ANA value among those patients.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the patient IDs of individuals whose creatinine levels are within the normal range and who have the highest concentration of anti-Cardiolipin antibodies. This requires filtering based on a specific range of creatinine levels and joining two tables to find the maximum anti-Cardiolipin antibody concentration.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of patients whose total bilirubin levels are above the normal range and who have a peripheral pattern observed in the ANA examination. This requires filtering and joining data from two tables: one containing laboratory results and the other containing examination results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the anti-nucleus antibody (ANA) concentration of the patient who has the highest total bilirubin (T-BIL) value within the normal range (less than 1.2 mg/dL). This requires filtering the data based on the T-BIL value and sorting the results to find the maximum value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of patients whose total cholesterol levels are higher than normal and who have a negative measure of the degree of coagulation. This requires filtering patients based on their cholesterol levels and their coagulation measurement, and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ < _ AND _ < _"
    },
    {
        "query_intent": "The question is looking to count the number of unique patients whose total cholesterol levels are within the normal range and who have a specific pattern (P) observed in the ANA examination. This requires filtering patients based on their cholesterol levels and ANA examination results, and then counting distinct patient IDs.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have a normal level of triglycerides and also exhibit other symptoms. This requires filtering patients based on their triglyceride levels and then checking for the presence of other symptoms.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the disease name of the patient who has the highest level of triglycerides within the normal range. This requires identifying patients with triglyceride levels below 150 and then finding the patient with the highest triglyceride value among those.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the IDs of patients who do not have thrombosis and have an abnormal level of creatinine phosphokinase (CPK). This requires filtering and joining data from two tables: one containing patient information and the other containing laboratory results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have a normal range of creatinine phosphokinase (CPK) levels and a positive measure of degree of coagulation (represented by a non-zero value of the CPK result). This requires filtering and counting data from two related tables: `Laboratory` and `Patient`.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the birthday of the oldest patient whose blood glucose level is considered abnormal. This requires filtering patients with abnormal blood glucose levels and then finding the patient with the earliest birthday among them.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have normal blood glucose levels and do not have thrombosis. This requires filtering patients based on their blood glucose levels and thrombosis status, and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients who have been admitted to the hospital and have a normal level of white blood cells. This requires filtering patients based on their admission status and white blood cell (WBC) levels, and then counting the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of patients diagnosed with Systemic Lupus Erythematosus (SLE) who have a normal white blood cell (WBC) level. This requires filtering patients based on their diagnosis and WBC levels, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique patient IDs who have an abnormal level of red blood cells and are being followed at the outpatient clinic. This requires filtering patients based on their red blood cell (RBC) levels and admission status.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ OR _ < _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of unique patients who have a normal platelet level and have observed symptoms. This requires filtering patients based on their platelet levels and checking for non-null symptoms.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the platelet levels of patients who are diagnosed with MCTD and have platelet levels within the normal range. This requires filtering and joining data from two tables: one containing patient diagnoses and the other containing laboratory results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the average prothrombin time (PT) of male patients who have a normal prothrombin time. This requires filtering the data based on gender and PT values, and then calculating the average of the filtered data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking for the count of patients who have severe thrombosis and a normal prothrombin time. This requires filtering patients based on their thrombosis severity and prothrombin time values, and then counting the resulting set of patients.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking to retrieve the major of a member named Angela Sanders. This requires joining two tables: one containing member information and the other containing major information, and then filtering the results based on the member's first and last name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of students who are part of the Student_Club and are from the College of Engineering. This requires joining two tables (member and major) based on a common field (link_to_major), filtering the results to include only those from the College of Engineering, and then counting the number of matching records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the full names (first and last names) of students who are part of the Student_Club and belong to the Art and Design Department. To achieve this, we need to join two tables: one containing member information and another containing major information, and then filter the results based on the department name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of students who have attended a specific event named \"Women's Soccer\". This requires joining two tables: one containing event information and another containing attendance records, and then filtering based on the event name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the phone numbers of students who have attended a specific event named \"Women's Soccer\". This requires joining multiple tables to match event attendees with their phone numbers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of students from the Student_Club who attended the event \"Women's Soccer\" and have a T-shirt size of medium. This requires filtering data from multiple tables based on specific conditions and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the event name that has the highest attendance of students from the Student_Club. This requires joining the attendance and event tables, grouping by event, counting the attendees, and then ordering the results to find the event with the maximum count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify the college associated with the Vice President of the Student Club. This requires joining two tables: one containing major information and another containing member information, and then filtering the results to find the Vice President's college.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of event names that were attended by a specific individual, Maya Mclean. This requires joining two tables: one containing event information and the other containing attendance records, and filtering the results based on the individual's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the number of events attended by a specific member (Sacha Harrison) in the year 2019. This requires filtering events by date and joining attendance and member tables to match the member with their attendance records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking to count the number of events that are categorized as'meetings' and have been attended by more than 10 members of the Student_Club. This requires filtering events based on their type and attendance count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the names of events that had an attendance of more than 20 students and were not fundraisers. This requires filtering events based on attendance and type, and joining the attendance and event tables to get the event names.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ <> _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking for the average number of attendees at meetings held in the year 2020. To achieve this, we need to count the number of attendees per meeting and then calculate the average of these counts for all meetings in 2020.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the description of the most expensive item that was spent in support of club events. This requires identifying the maximum cost from the expense records and retrieving the corresponding description.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of members in the Student_Club who have majored in Environmental Engineering. This requires joining two tables (member and major) and filtering the results based on the major name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the full names (first and last names) of all members who attended the \"Laugh Out Loud\" event. This requires joining multiple tables to match event attendees with their member information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the last names of students who have a specific major, \"Law and Constitutional Studies\". This requires joining two tables: one containing student information and another containing major information, and then filtering the results based on the major name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the county where Sherri Ramsey grew up, which requires retrieving data from two related tables: one containing member information and the other containing zip code information. The SQL query needs to join these tables based on the zip code and filter the results by Sherri Ramsey's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the college that offers the major taken by a specific individual, Tyler Hewitt. This requires joining two tables: one containing major information and the other containing member information, and then filtering the results based on the individual's first and last name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total amount of funds received by the Vice President. This requires aggregating the income data and filtering it based on the position of the member.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the total amount of money spent by Student_Club members on food during the September Meeting. To achieve this, we need to aggregate the spending data from the budget and event tables, filtering by the event name and category.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the city and state where the President of the Student Club grew up. This requires retrieving data from two related tables: one containing member information and the other containing zip code information. The SQL query needs to filter the data to find the President and then retrieve the corresponding city and state.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the full names (first and last names) of members who grew up in the state of Illinois. This requires joining two tables: one containing member information and the other containing zip code information, and filtering the results based on the state being 'IL'.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the amount spent by the Student_Club members on advertisement during the September Meeting. To achieve this, we need to retrieve data from two related tables: one containing event details and the other containing budget details. The SQL query will need to filter records based on the event date and category, and then sum the spending amounts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the department that offers the major taken by individuals named Pierce and Guidi. This requires joining two tables: one containing member information and the other containing major information, and then filtering the results based on the first and last names of the members.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total budgeted amount for all categories associated with the \"October Speaker\" event. This requires aggregating data from the budget table, joining it with the event table, and filtering based on the event name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to determine whether each expense related to the 'October Meeting' on October 8, 2019, has been approved. This requires joining multiple tables to filter and retrieve the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the average cost of expenses incurred by a specific individual (Elijah Allen) during the months of September and October. This requires filtering the data based on the individual's name and the date range, and then computing the average cost.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the difference in the total amount spent by the Student_Club on events between the years 2019 and 2020. This requires aggregating data by year and then finding the difference between the sums of the spent amounts for those two years.",
        "sql_skeleton": "SELECT _ AS diff FROM _ WHERE _ IN ( _, _) AND _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the location associated with an event named \"Spring Budget Review\" from a database. This requires selecting specific data from a table where a condition is met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the specific cost associated with the expense description \"Posters\" on the date 2019/9/4. To retrieve this information, we need to filter the records in the expense table based on the given description and date.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the remaining budget for the \"Food\" category, specifically the largest budget within that category. This requires identifying the maximum budget amount and then retrieving the corresponding remaining amount.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the specific notes associated with a fundraising event that took place on September 14, 2019. To achieve this, we need to retrieve data from two related tables: one containing event details and the other containing budget details, and then filter the results based on the event date and type.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the total number of majors available in the \"College of Humanities and Social Sciences\". To achieve this, we need to count the entries in the \"major\" table where the \"college\" column matches the specified value.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to retrieve the phone number of a specific individual identified by their first and last names from a database. This requires selecting specific columns from a table where the conditions on the first and last names are met.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the county associated with the hometown of a person named \"Adela O'Gallagher\". To achieve this, we need to join two tables: one containing member information and the other containing zip code data. We will filter the results to match the given first and last names and then select the county.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the count of budgets associated with the \"November Meeting\" event that have exceeded their allocated budget. This requires filtering the budgets by event name, checking if the spent amount is greater than the remaining amount, and counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is asking for the total budget amount allocated to the event named \"September Speaker\". This requires aggregating the budget amounts associated with this event from the budget table, joining it with the event table to filter by event name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the status of an event associated with a specific expense description and date. To achieve this, we need to join two tables: one containing event details and the other containing expense details, and then filter the results based on the given date and expense description.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the major of a specific individual, Brent Thomason, by joining two tables: one containing member information and the other containing major information. The SQL query needs to filter the results based on the individual's first and last name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of club members who have a major in \"Business\" and wear a medium-sized t-shirt. This requires filtering the data based on the major and t-shirt size, and then counting the resulting records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the type of zip code associated with a specific individual, Christof Nielson. This requires joining two tables: one containing zip code information and the other containing member information, and then filtering the results based on the individual's name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the major associated with the Vice President of the club. This requires joining two tables: one containing member information and the other containing major information, and then filtering the results to find the Vice President's major.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to find the state associated with the hometown of a person named \"Sacha Harrison\" by joining two tables: one containing zip code information and the other containing member information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the department associated with the President of the club. This requires joining two tables: one containing member information and another containing major information, and then filtering the results to find the President's department.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the date on which a specific individual, Connor Hilton, paid their dues. This requires retrieving data from two related tables: one containing member information and the other containing payment details. The SQL query needs to join these tables based on a common key and filter the results to find the specific payment date for the given individual.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the full name (first and last name) of the first member who paid their dues. This requires identifying the earliest payment date and then retrieving the corresponding member's details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking to compare the budget spent on \"Advertisement\" for the \"Yearly Kickoff\" meeting to the budget spent on \"Advertisement\" for the \"October Meeting\". This requires calculating the difference in spending between these two events.",
        "sql_skeleton": "SELECT _ AS diff FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for the percentage of the budget allocated to the \"Parking\" category out of the total budget for the \"November Speaker\" event. This requires calculating the ratio of the \"Parking\" budget to the total budget and then converting it into a percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the total cost associated with pizzas for all events. This requires aggregating data from a table that contains expense records, filtering for records where the description includes \"pizza\", and summing the costs of those records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of cities located in Orange County, Virginia. To achieve this, we need to count the entries in the database that meet these criteria. This requires filtering the data based on county and state, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of departments that belong to the College of Humanities and Social Sciences. This requires retrieving data from a database table where the college matches the specified criteria.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the city and state information of Amy Firth's hometown from a database. This requires joining two tables (`member` and `zip_code`) based on a common field (`zip`) and filtering the results to find the specific individual.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the expenses associated with the budget that has the lowest remaining amount. This requires joining the budget and expense tables, sorting the results by the remaining amount in ascending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for a list of members who attended a specific event named \"October Meeting\". This requires joining two tables: one containing attendance records and the other containing event details, and then filtering the results based on the event name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the college that the majority of members attend. This requires joining two tables (member and major), grouping the results by college, counting the number of members in each college, and then selecting the college with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the major of a person who has a specific phone number. This requires joining two tables: one containing member information and the other containing major information, and then filtering the results based on the phone number.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the event that has the highest budget amount. To achieve this, we need to join the event and budget tables, group the results by event name, and then sort and limit the results to the top one.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for a list of all expenses incurred by the vice president. This requires retrieving data from two related tables: one containing member information and the other containing expense details. The SQL query needs to filter the data based on the vice president's position and join the two tables on a common key.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of members who attended a specific event named \"Women's Soccer\". To achieve this, we need to count the entries in the attendance table where the corresponding event is \"Women's Soccer\". This requires joining the attendance and event tables based on a common key and filtering the results by the event name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the specific date when a member named Casey Mason received income. To achieve this, we need to retrieve data from two related tables: one containing member information and the other containing income details. The SQL query should join these tables based on a common key and filter the results to find the income received by Casey Mason.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the count of members whose hometowns are located in the state of Maryland. To achieve this, we need to join the `member` table with the `zip_code` table on the zip code and filter the results to include only those where the state is Maryland.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of events attended by a member with a specific phone number. This requires joining two tables (attendance and member) based on a common key (member_id) and filtering the results by the phone number.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of members who belong to the \"School of Applied Sciences, Technology and Education\" department. This requires joining two tables: one containing major information and the other containing member information, and then filtering based on the department name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the event with the highest spend-to-budget ratio among all closed events. This requires calculating the ratio of spent amount to budget amount for each event and then identifying the event with the highest ratio.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the number of students who hold the position of \"President\" within a dataset. To achieve this, we need to count the entries in a table where the \"position\" column matches \"President\".",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the maximum value of the budget spend for events. This requires identifying the highest value in a specific column within a table.",
        "sql_skeleton": "SELECT _ FROM _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the count of events that are classified as'meeting' and were held in the year 2020. To achieve this, you need to filter records based on the event type and date, and then count the number of matching records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the total amount of money spent on food from a budget table. To achieve this, we need to aggregate the spending data by summing the values in the'spent' column for the 'Food' category.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of students who have attended more than 7 events. This requires joining the attendance and member tables, grouping the results by student, and filtering groups based on the count of events attended.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ GROUP BY _, _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for students who are majoring in interior design and have attended an event named \"Community Theater\". This requires filtering and joining tables to match students with their majors and event attendance.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the names (first and last) of students who are located in Georgetown, South Carolina. To achieve this, we need to join two tables: one containing student information and another containing zip code information, and then filter the results based on the city and state.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of income records associated with a member named Grant Gilmour. This requires joining the member and income tables on a common key and filtering the results based on the member's first and last name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the first and last names of students who have generated income greater than $40. This requires joining the `member` and `income` tables, filtering the results based on the income amount, and selecting the relevant columns.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is asking for the total expense associated with the event named \"Yearly Kickoff\". To achieve this, we need to aggregate the cost data from the `expense` table, joining it with the `budget` table to ensure we're considering the correct event expenses.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the student who has been assigned to manage the budget for the \"Yearly Kickoff\" event. This requires joining multiple tables to find the relevant student's details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the student who has generated the highest income, including their full name and the source of that income. This requires joining two tables (member and income), filtering for non-null income amounts, sorting by the income in descending order, and limiting the result to the top entry.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the event that has the lowest associated cost. This requires identifying the event with the minimum cost by joining relevant tables and sorting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the percentage of the total cost that is attributed to the 'Yearly Kickoff' event. This requires calculating the total cost of all events and then finding the proportion of the cost associated with the 'Yearly Kickoff' event. The SQL query needs to join tables to access event names and their respective costs, filter for the 'Yearly Kickoff' event, and perform the necessary calculations.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the ratio of the number of students majoring in finance to the number of students majoring in physics. This requires counting the number of students in each major and then calculating the ratio.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking to identify the primary source of funds received in September 2019, sorted by the amount received in descending order. This requires filtering the data by date, grouping by source, and ordering the results by the sum of the amounts in descending order.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to retrieve the first name, last name, and email address of the individual who holds the position of Secretary within the Student_Club. This requires filtering the data based on the position and selecting specific columns.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of members in the Student_Club who have a major in 'Physics Teaching'. This requires joining two tables: one containing member information and the other containing major information, and then filtering the results based on the major name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the number of members who attended a specific event, 'Community Theater', in the year 2019. This requires counting the entries in the `attendance` table that are linked to the `event` table where the event name is 'Community Theater' and the event date is in 2019.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the count of events attended by a specific member, Luisa Guidi, and also her major. This requires joining multiple tables to retrieve the necessary information and filtering based on the member's first and last name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the average spending on food by the Student_Club for typical events in the past. This requires calculating the average value of the `spent` column for events where the `category` is 'Food' and the `event_status` is 'Past'.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the event that has the highest expenditure on advertisement. This requires joining two tables (event and budget), filtering for the 'Advertisement' category, sorting by the spent amount in descending order, and selecting the top result.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to determine whether a specific individual, Maya Mclean, attended a particular event named 'Women's Soccer'. This requires checking if there is a record in the attendance table that links Maya Mclean to the 'Women's Soccer' event.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of events held by the Student_Club in 2019 that are related to 'Community Service'. This requires filtering events by date and type, counting the total number of events, and counting the number of events related to 'Community Service', then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _ AND _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the cost associated with posters for a specific event named 'September Speaker'. To achieve this, we need to join two tables (`budget` and `event`) and filter the results based on the event name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to determine the most frequently ordered t-shirt size by club members. This requires counting the occurrences of each t-shirt size and then selecting the one with the highest count.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the name of the closed event that has the highest difference between its budget and actual cost. This requires joining two tables (`event` and `budget`), filtering for closed events, calculating the difference between budget and cost, and then selecting the event with the maximum difference.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify the types of expenses and their total value that were approved for an event named 'October Meeting'. This requires joining multiple tables to filter and aggregate the data.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is asking to calculate the total budgeted amount for the 'April Speaker' event and to list all the budgeted categories for this event in ascending order based on their budgeted amounts. This requires joining two tables (`event` and `budget`), filtering by event name, summing the budgeted amounts, and ordering the categories by their amounts.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _"
    },
    {
        "query_intent": "The question is looking for the budget with the highest amount allocated to the 'Food' category. This requires identifying the maximum value within a specific subset of data.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the top three budgets with the highest budgeted amount in the Advertising category. This requires sorting the budgets by their amount in descending order and limiting the results to the top three entries.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking to calculate the total amount spent on 'Parking' from a list of expenses. This requires aggregating data from a table where expenses are recorded and filtering the results to only include those related to 'Parking'.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total amount of money spent on a specific date, which requires summing up the costs from the expense records for that date. The SQL query needs to filter the records by date and then calculate the sum of the costs.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the full name and total cost associated with a specific member identified by their member ID. This requires retrieving data from two related tables: one containing member details and the other containing expense details. The SQL query needs to join these tables based on the member ID and sum the costs for the specified member.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the specific descriptions of expenses incurred by a member named Sacha Harrison. This requires joining two tables: one containing member information and the other containing expense details, and then filtering the results based on the member's name.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the descriptions of expenses incurred by members who have an X-Large size tee shirt. This requires joining two tables: one containing member information and the other containing expense details, and filtering the results based on the tee shirt size.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the zip code of members whose expenses are less than 50 USD. This requires joining multiple tables to link members with their expenses and filtering the results based on the expense amount.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking for the name of the major that a specific individual, Phillip Cullen, has joined. This requires retrieving data from two related tables: one containing major information and the other containing member information. The SQL query needs to join these tables based on a common key and filter the results by the individual's first and last name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the positions of members who have joined the major of \"Business\". This requires joining two tables: one containing member information and the other containing major information, and then filtering the results based on the major name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of members who have a major in Business and a medium-sized tee shirt. This requires joining two tables (member and major) and filtering based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique event types that have a remaining budget greater than 30 USD. This requires joining two tables (event and budget) and filtering based on the remaining budget condition.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the categories of events that were held at a specific location, \"MU 215\". This requires joining two tables: one containing event details and the other containing budget details, and filtering the results based on the location.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the category of an event that occurred on a specific date (2020-03-24T12:00:00). To achieve this, we need to join two tables: one containing event details and the other containing budget details, and then filter the results based on the event date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of the major that a person with the title 'Vice President' has joined. This requires joining two tables: one containing member information and another containing major information, and filtering the results based on the member's position.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of members who are majoring in Business from a given list of members. This requires filtering the members by their major, counting the total number of members, and then calculating the percentage of those who are majoring in Business.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is asking for the category of events that were held at a specific location, \"MU 215\". To achieve this, we need to join two tables: one containing event details and the other containing budget details, and then filter the results based on the location.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of income records that have an amount of 50. To achieve this, we need to filter the records based on the amount and then count the number of filtered records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the count of members who have an extra large t-shirt size. This requires filtering the data to include only those with the specified t-shirt size and then counting the number of records that meet this criterion.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of majors within a specific department and college. This requires filtering the data based on department and college, and then counting the relevant records.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the last names of members who have a major in Environmental Engineering, along with the department and college name associated with that major. This requires joining two tables: one containing member information and the other containing major information, and filtering based on the major name.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the budget categories of events that are located at a specific location (MU 215) and have a guest speaker type with a budget of 0. This requires filtering and joining data from two tables: one containing event details and the other containing budget details.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for a list of cities and states of members who are enrolled in the Electrical and Computer Engineering department. This requires joining multiple tables to filter and retrieve the necessary information.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the name of a social event that was attended by the vice president of the Student Club, specifically located at 900 E. Washington St. This requires joining multiple tables to match the event location, attendee's position, and event type.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the last name and position of a student who made a specific purchase (buying pizza) on a specific date (09/10/2019). To achieve this, we need to join two tables: one containing member information and the other containing expense details, and then filter the results based on the date and description of the purchase.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the last names of club members who attended a specific event, specifically the women's soccer event. This requires joining two tables: one containing event information and the other containing attendance information, and filtering the results based on the event type.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of members with a t-shirt size of 'M' (medium) who have received an amount of 50 from the Student_Club. This requires filtering the data, counting the relevant members, and calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for a list of unique countries that have zip codes specifically designated for post office boxes. This requires filtering and grouping data from a database.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for zip codes that are post office boxes, located in the San Juan Municipio county of Puerto Rico. This requires filtering the data based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the names of events that are categorized as \"game\", are closed, and occurred between the dates March 15, 2019, and March 20, 2020. The SQL query needs to filter events based on these conditions and join the event and budget tables to get the event names.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for links to events that are associated with members who have paid more than 50 dollars. This requires joining multiple tables to filter the data based on the payment amount.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for members who were approved within a specific date range and have attended an event, along with the link to their event. This requires filtering based on date and approval status, joining tables to get necessary information, and ensuring unique results.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the college of a person named Katy who is associated with a specific major identified by the link \"rec1N0upiVLy5esTO\". This requires joining two tables: one containing member information and the other containing major information, and then filtering the results based on the given conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the phone numbers of members who have a major in business within the College of Agriculture and Applied Sciences. This requires joining two tables: one containing member information and the other containing major information, and then filtering the results based on specific conditions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the email addresses of members who have made payments exceeding $20 within a specific date range (from September 10, 2019, to November 19, 2019). This requires joining multiple tables to filter and retrieve the necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ > _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking for the number of members who have an education major in the College of Education & Human Services. This requires counting the members based on their major and college affiliation.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of events that had a budget expenditure exceeding their allocated amount. This requires counting the events with a positive difference between the spent and remaining budget amounts, and then dividing this count by the total number of events to get the percentage.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is asking for specific details (event ID, location, and status) of events that took place within a specified date range (November 2019 to March 2020). To achieve this, we need to filter the data based on the event date.",
        "sql_skeleton": "SELECT _, _, _ FROM _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for a list of expense descriptions where the average cost of each expense is greater than fifty dollars. This requires filtering expenses based on an average cost condition.",
        "sql_skeleton": "SELECT _ FROM _ GROUP BY _ HAVING _ > _"
    },
    {
        "query_intent": "The question is looking for the full names (first and last names) of members who have an extra-large t-shirt size. This requires filtering the data based on a specific condition.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the percentage of zip codes that are designated as PO boxes. This requires counting the total number of zip codes and the number of PO box zip codes, then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the names and locations of events that have spent less than their allocated budget. This requires filtering and joining data from two tables: `event` and `budget`.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ < _"
    },
    {
        "query_intent": "The question is looking for the names and dates of events that have expenses for pizza within a specific cost range (more than fifty dollars but less than a hundred dollars). This requires joining two tables (`event` and `expense`) and applying a filter condition.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ LIKE _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the names and majors of members who have incurred expenses exceeding $100. This requires joining multiple tables to match members with their expenses and filtering the results based on the expense amount.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for a list of cities and countries where events with more than forty associated incomes are taking place. This requires joining multiple tables to filter and aggregate the data accordingly.",
        "sql_skeleton": "SELECT DISTINCT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _"
    },
    {
        "query_intent": "The question is looking for the member who has incurred expenses in more than one event and has paid the highest total amount. This requires joining tables to match members with their expenses, grouping by member IDs to count the number of expenses, filtering for those with more than one expense, and then ordering by the sum of costs to find the highest.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ > _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average amount of money paid by students who are not members. This requires filtering the data based on the position of the students and then calculating the average of the relevant amounts.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ <> _"
    },
    {
        "query_intent": "The question is looking for the names of events that have a parking cost less than the average parking cost across all events. This requires filtering and joining tables to get the necessary data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ < (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the percentage of the total cost attributed to meeting events. This requires calculating the sum of costs for meeting events, dividing it by the total sum of costs, and then converting this ratio into a percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the budget ID that allocated the highest amount of money for expenses categorized as 'water', 'chips', and 'cookies'. This requires filtering and joining tables to match budget entries with their corresponding descriptions, and then identifying the maximum spending value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ IN ( _, _, _) ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the full names (first and last names) of the top five members who have spent the most money, sorted in descending order of their spending. This requires joining multiple tables to match members with their expenses and then filtering and ordering the results.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the full names and contact numbers of members who have spent more than the average amount on each expense. This requires joining multiple tables to access the necessary data and calculating the average expense.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ > (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is asking to calculate the difference in the percentage of members from New Jersey and Vermont. This involves counting the members from each state and then computing the percentage difference.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the major and department associated with a specific member, Garrett Gerke. To achieve this, we need to join two tables: one containing member information and the other containing major information, and then filter the results based on the member's first and last name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the full name (first and last name) of the member who incurred expenses for 'water','veggie tray', and'supplies', along with the total cost of these expenses. This requires joining two tables (`member` and `expense`) and filtering based on specific expense descriptions.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to retrieve the last names and phone numbers of students who are majoring in Elementary Education. This requires joining two tables: one containing student information and another containing major information, and filtering the results based on the major name.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the category and the amount budgeted for the 'January Speaker' event. This requires retrieving data from two related tables: one containing event details and the other containing budget details. The SQL query needs to join these tables based on a common key and filter the results to only include the 'January Speaker' event.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the names of events that were budgeted for food expenses. This requires joining two tables: one containing event details and the other containing budget details, and filtering the results based on the category \"Food\".",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the full names (first and last names) of students who received funds on a specific date (9/9/2019) and the amount they received. This requires joining two tables: one containing member information and the other containing income information, and filtering the results based on the date.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the budget category associated with a specific expense description, 'Posters'. This requires joining two tables, `budget` and `expense`, on a common key, and filtering the results based on the expense description.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the full name and the college affiliation of the club member who holds the position of 'Secretary'. This requires retrieving data from two related tables: one containing member information and the other containing major information.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking to calculate the total amount spent on speaker gifts and to list the names of the events where these expenses were incurred. This requires aggregating data from two related tables: one containing budget information and the other containing event details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _"
    },
    {
        "query_intent": "The question is looking for the hometown (city) of a person named Garrett Gerke by joining two tables: one containing zip codes and their corresponding cities and another containing member information. The SQL query needs to filter the results to match the specified first and last name.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the full name and position of a student who resides in Lincolnton, North Carolina, specifically with the zip code 28092. This requires joining two tables: one containing student information and the other containing zip code data. The SQL query needs to filter the results based on the city, state, and zip code.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of gas stations in the Czech Republic (CZE) that offer Premium gas. This requires filtering the data based on country and gas segment, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the ratio of customers who pay in EUR to those who pay in CZK. This requires counting the number of customers in each currency group and then calculating the ratio.",
        "sql_skeleton": "SELECT _ FROM _"
    },
    {
        "query_intent": "The question is looking for the customer who had the lowest consumption in the LAM segment for the year 2012. This requires filtering data by segment and year, grouping by customer, and then ordering the results to find the minimum consumption.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ LIKE _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the average monthly consumption of customers classified as 'SME' for the year 2013. This requires filtering the data by the 'SME' segment, summing the consumption for the year 2013, and then dividing by 12 to get the average monthly consumption.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is looking for the customer who consumed the most gas in the year 2011, specifically for those customers who pay in CZK. This requires identifying the highest consumption among these customers within the specified year.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to count the number of customers within the \"KAM\" segment who had a consumption of less than 30,000 units for the year 2012. This requires filtering data based on specific conditions and joining tables to access necessary information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ < _"
    },
    {
        "query_intent": "The question is looking to calculate the difference in gas consumption between two groups of customers based on their currency preferences (CZK and EUR) for the year 2012. This requires aggregating data by customer segment and then finding the difference between the sums of their consumptions.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the year that recorded the highest gas consumption paid in EUR. This requires aggregating gas consumption data by year, filtering by the EUR currency, and then identifying the year with the maximum consumption.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify the segment that had the lowest total consumption. This requires aggregating consumption data by segment and then selecting the segment with the minimum total consumption.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking to identify the year with the highest gas consumption paid in CZK. This requires filtering the data by currency, grouping the data by year, calculating the total consumption for each year, and then selecting the year with the maximum consumption.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the month (in terms of year and month) when the gas consumption by SME customers peaked in the year 2013. This requires identifying the maximum gas consumption value for SME customers within the specified year and then extracting the relevant month and year.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the differences in annual average consumption between specific segments (SME, LAM, and KAM) of customers who paid in CZK for the year 2013. This requires filtering the data based on the year and currency, grouping the data by segment, calculating the average consumption, and then finding the differences between these averages.",
        "sql_skeleton": "SELECT _ AS diflamkam, _ AS difkamsme, _ AS difsme FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ IN ( _, _, _)"
    },
    {
        "query_intent": "The question is looking for the segment (SME, LAM, or KAM) with the highest and lowest percentage increases in consumption paid in EUR between the years 2012 and 2013. This requires calculating the percentage change in consumption for each segment and then identifying the maximum and minimum values.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC, _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the total consumption of a specific customer (customer 6) over a period of three months (August to November 2013). This requires aggregating data from a table that tracks customer consumption on a monthly basis.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ BETWEEN _ AND _ AND _ = _"
    },
    {
        "query_intent": "The question is asking for the difference in the number of \"discount\" gas stations between the Czech Republic and Slovakia. This requires counting the number of \"discount\" gas stations in each country and then calculating the difference between these counts.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the difference in consumption between two specific customers (customer 7 and customer 5) for the month of April 2013. This requires filtering the data by date, joining tables to match customer IDs, and then performing an aggregation to sum the consumption values.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking to compare the number of SME customers who pay in Czech koruna to those who pay in euros. It requires counting the customers based on their payment currency and segment type, and then calculating the difference between these counts.",
        "sql_skeleton": "SELECT CASE WHEN _ > _ THEN _ ELSE _ END AS diff FROM _ JOIN _ ON _ = _"
    },
    {
        "query_intent": "The question is looking for the LAM customer who used the Euro as their currency and had the highest consumption in October 2013. This requires joining two tables (`customers` and `yearmonth`), filtering by the customer segment and currency, and then finding the maximum consumption for that subset of customers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ AND _ LIKE _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the customer who belongs to the 'KAM' segment and has the highest consumption, along with the amount of consumption. This requires identifying the maximum consumption within the 'KAM' segment and then retrieving the corresponding customer details.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking to calculate the total consumption of customers who belong to the 'KAM' segment during May 2013. This requires aggregating data from two tables: one containing customer information and the other containing consumption data, and filtering the data based on the specified segment and date.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of 'LAM' customers who have a consumption value greater than 46.73. This requires filtering the data based on customer segment, joining tables to access necessary data, and calculating a percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the country with the highest number of \"value for money\" gas stations and to count the total number of such gas stations in each country. This requires filtering, grouping, and counting data from a database table.",
        "sql_skeleton": "SELECT _, _ FROM _ WHERE _ = _ GROUP BY _ ORDER BY _ DESC"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of customers in the 'KAM' segment who pay in euros. This requires filtering the data, counting the relevant records, and then calculating the percentage of those records out of the total count of 'KAM' customers.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of customers in February 2012 who consumed more than 528.3 units. This requires filtering data by date, summing the consumption values, counting the total number of customers, and then calculating the percentage of customers who exceeded the specified consumption.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of gas stations in Slovakia that are classified as premium. This requires filtering the data to include only Slovakian gas stations and then calculating the proportion of those that are premium.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the client ID that had the highest consumption in September 2013. This requires filtering data by date, grouping by client ID, summing the consumption, and then identifying the client ID with the maximum sum.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the client segment that had the lowest consumption in September 2013. This requires aggregating consumption data by client segment and date, filtering for September 2013, and then finding the minimum value within that filtered dataset.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ LIKE _ GROUP BY _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the customer ID of the SME (Small and Medium-sized Enterprises) customer who had the lowest consumption in June 2012. This requires filtering the data by customer segment, date range, and summing the consumption values to find the minimum.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ ASC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the highest monthly consumption recorded in the year 2012. This requires identifying the maximum value of consumption for each month of the year and then finding the highest of these values.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ LIKE _"
    },
    {
        "query_intent": "The question is looking for the highest monthly consumption of customers who use the euro as their currency. This requires aggregating consumption data by month and filtering based on currency, then finding the maximum value.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ GROUP BY _, _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for a list of product descriptions that were consumed in September 2013. This requires joining multiple tables to filter transactions by date and then retrieving the corresponding product descriptions.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE SUBSTRING(_, _, _) = _"
    },
    {
        "query_intent": "The question is looking for a list of unique countries where gas stations had transactions in June 2013. This requires filtering transactions by date and joining the transactions with gas station information to get the corresponding countries.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _"
    },
    {
        "query_intent": "The question is asking to identify the unique gas station chains that have transactions conducted in euros. This requires filtering transactions based on the currency and then joining the transactions with the gas stations to get the corresponding chains.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the descriptions of products that were bought using transactions in euros. This requires filtering transactions based on the currency and then retrieving the corresponding product descriptions.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the average total price of transactions that occurred in January 2012. This requires filtering transactions by date and then calculating the average price.",
        "sql_skeleton": "SELECT _ FROM _ WHERE SUBSTRING(_, _, _) = _ AND SUBSTRING(_, _, _) = _"
    },
    {
        "query_intent": "The question is looking to count the number of customers who paid in euros and have a monthly consumption of more than 1000. This requires filtering and joining data from two tables: one containing customer information and another containing consumption data.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is asking for a list of product descriptions from transactions that occurred at gas stations located in the Czech Republic. This requires joining multiple tables to filter transactions based on the country of the gas stations.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for a list of unique transaction times from transactions that took place at gas stations belonging to chain number 11. This requires filtering transactions based on the gas station chain and ensuring that only distinct times are included in the result.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of transactions that occurred in gas stations located in the Czech Republic, where the transaction price exceeds 1000. This requires filtering transactions based on the country and price, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking for the count of transactions that occurred in gas stations located in the Czech Republic after January 1, 2012. This requires filtering transactions by date and location, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    },
    {
        "query_intent": "The question is looking to calculate the average total price of transactions that occurred at gas stations located in the Czech Republic. This requires filtering transactions based on the country of the gas stations and then computing the average price.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the average total price of transactions for customers who paid in euros. This requires filtering transactions based on the currency and then computing the average price.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the customer who made the highest payment on August 25, 2012. To achieve this, we need to identify the customer with the maximum transaction amount for that specific date.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the country of the gas station that had the first transaction on August 25, 2012. To achieve this, we need to filter transactions by date, join gas stations with transactions, and sort the results to find the earliest transaction.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the type of currency used by a customer during a specific transaction, which occurred at a given date and time. To achieve this, we need to join two tables: one containing transaction details and the other containing customer details, and filter the results based on the specified date and time.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to identify the segment of a customer based on a specific transaction date and time. To achieve this, we need to join the transactions table with the customers table using the customer ID and filter the results based on the given date and time.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of transactions that occurred in the morning of August 26, 2012, specifically for transactions paid in CZK. This requires filtering transactions based on the date, time, and currency, and then counting the results.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ LIKE _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the segment of the earliest customer based on their earliest transaction date. This requires identifying the earliest transaction, then finding the corresponding customer segment.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _)"
    },
    {
        "query_intent": "The question is looking for the country associated with a specific transaction that occurred at a given date and time. To achieve this, we need to join the transactions table with the gas stations table to match the transaction details with the gas station information.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the product ID associated with a specific transaction that occurred at a given date and time. To achieve this, we need to filter the transactions based on the date and time and then select the product ID from the filtered results.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the total amount spent by a specific customer in January 2012, along with the exact date and expenses. This requires retrieving data from two different tables (`transactions_1k` and `yearmonth`) and joining them based on the customer ID. The results need to be filtered by the given date (2012/8/24) and the customer's payment amount (124.05).",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to count the number of transactions that occurred within a specific time frame (8:00-9:00) on a specific date (2012-08-26) at gas stations located in the Czech Republic (CZE). The SQL query needs to filter records based on date, time, and country, and then count the matching records.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ BETWEEN _ AND _ AND _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to identify the currency used by a customer who spent a specific amount in June 2013. This requires joining two tables (`customers` and `yearmonth`) based on the customer ID, filtering the transactions by date and amount, and selecting the distinct currency.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to identify the country associated with a specific card owner identified by their card ID. This requires joining multiple tables to link the card owner's information to their country.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking to identify the nationality of a customer based on a specific transaction date and amount. This requires joining multiple tables to link the transaction to the customer's nationality.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking to calculate the percentage of customers who used EUR currency on a specific date (2012/8/25). This requires counting the total number of customers and the number of customers who used EUR, then calculating the percentage.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is looking for the consumption decrease rate of a specific customer from the year 2012 to 2013. This requires calculating the difference in consumption between the two years and then expressing this difference as a rate relative to the consumption in 2012. The SQL query needs to join tables, filter data by specific date and transaction amount, and perform date manipulation to get the year and month components.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _"
    },
    {
        "query_intent": "The question is looking for the gas station that has generated the highest total revenue from transactions. This requires aggregating the revenue data by gas station and then identifying the gas station with the maximum revenue.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is asking for the percentage of customers who are classified as \"Premium\" within the country \"SVK\". This requires filtering the data by country, counting the number of \"Premium\" customers, and calculating the percentage of these customers out of the total number of customers in that country.",
        "sql_skeleton": "SELECT _ FROM _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the total amount spent by a specific customer at gas stations and the amount spent by that customer in January 2012. This requires retrieving data from two different tables (`transactions_1k` and `yearmonth`) and performing calculations based on the customer's ID.",
        "sql_skeleton": "SELECT _, _ FROM _ JOIN _ ON _ = _ WHERE _ = _"
    },
    {
        "query_intent": "The question is asking for the top five best-selling products, which requires identifying the products with the highest sales and retrieving their full names. This involves aggregating sales data by product, sorting the results, and limiting the output to the top five entries.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ GROUP BY _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the top spending customer, their average price per item purchased, and the currency used. This requires identifying the customer with the highest total expenditure and calculating their average price per item, as well as the currency they used.",
        "sql_skeleton": "SELECT _, _, _ FROM _ JOIN _ ON _ = _ JOIN _ ON _ = _ WHERE _ = (SELECT _ FROM _ ORDER BY _ DESC LIMIT _)"
    },
    {
        "query_intent": "The question is looking for the country of the gas station that sold the most expensive unit of product with ID 2. This requires identifying the gas station with the highest price for this specific product. The SQL query needs to filter by product ID, sort by price in descending order, and limit the result to the top entry.",
        "sql_skeleton": "SELECT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ = _ ORDER BY _ DESC LIMIT _"
    },
    {
        "query_intent": "The question is looking for the consumption status of customers who paid more than 29.00 per unit for product ID 5 in August 2012. This requires filtering transactions based on price and product ID, and then retrieving consumption data for those customers in the specified month.",
        "sql_skeleton": "SELECT DISTINCT _ FROM _ JOIN _ ON _ = _ WHERE _ = _ AND _ > _"
    }
]